import {
  $e,
  $i,
  Ah,
  Ao,
  As,
  Au,
  Bo,
  Bu,
  Co,
  Cu,
  Du,
  Eh,
  Eu,
  Gu,
  Ir,
  Iu,
  Jf,
  Ju,
  Lt,
  Mh,
  Ms,
  Mu,
  Nh,
  Nu,
  Ou,
  Pe,
  Pu,
  Ru,
  Sh,
  Sr,
  Su,
  Uu,
  Vr,
  Wr,
  Xr,
  Yi,
  Yt,
  Yu,
  _o,
  _u,
  ah,
  as,
  bh,
  bi,
  bs,
  bu,
  ch,
  cu,
  decodeJWT,
  dh,
  ds,
  encodeIss,
  er,
  es,
  fh,
  fn,
  generateKeyPair,
  gh,
  gr,
  gs,
  hh,
  init_tslib_es6,
  io,
  is,
  ku,
  lh,
  ls,
  lu,
  me,
  mh,
  mn,
  ms,
  mu,
  nh,
  oh,
  ph,
  pr,
  ps,
  qu,
  require_cjs,
  rr,
  sh,
  signJWT,
  ss,
  toString,
  ts,
  tslib_es6_exports,
  uh,
  vh,
  vs,
  ws,
  wu,
  xe,
  xs,
  yh,
  ys,
  yu
} from "./chunk-3WVNEP6P.js";
import {
  A,
  AccountController,
  ApiController,
  AssetController,
  AssetUtil,
  BlockchainApiController,
  CaipNetworksUtil,
  ChainController,
  ConnectionController,
  ConnectorController,
  ConstantsUtil,
  ConstantsUtil2,
  CoreHelperUtil,
  DateUtil,
  E,
  EnsController,
  EventsController,
  InputUtil,
  LitElement,
  MathUtil,
  ModalController,
  NavigationUtil,
  NetworkController,
  NumberUtil,
  OnRampController,
  OptionsController,
  PublicStateController,
  RouterController,
  SafeLocalStorage,
  SafeLocalStorageKeys,
  SendController,
  SnackController,
  StorageUtil,
  SwapController,
  ThemeController,
  TooltipController,
  TransactionUtil,
  TransactionsController,
  UiHelperUtil,
  W3mFrameHelpers,
  W3mFrameRpcConstants,
  createRef,
  css,
  customElement,
  getW3mThemeVariables,
  html,
  ifDefined,
  import_pino,
  k,
  property,
  proxy,
  ref,
  ref2,
  safeJsonParse,
  safeJsonStringify,
  setColorTheme,
  setThemeVariables,
  state,
  subscribe,
  subscribeKey,
  y
} from "./chunk-DRP2SV7D.js";
import {
  __commonJS,
  __export,
  __reExport,
  __toCommonJS,
  __toESM
} from "./chunk-256EKJAK.js";

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R2 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R2 && typeof R2.ownKeys === "function") {
      ReflectOwnKeys = R2.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n4) {
      if (typeof n4 !== "number" || n4 < 0 || NumberIsNaN(n4)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n4 + ".");
      }
      this._maxListeners = n4;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i3 = 1; i3 < arguments.length; i3++) args.push(arguments[i3]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er3;
        if (args.length > 0)
          er3 = args[0];
        if (er3 instanceof Error) {
          throw er3;
        }
        var err = new Error("Unhandled error." + (er3 ? " (" + er3.message + ")" : ""));
        err.context = er3;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i3 = 0; i3 < len; ++i3)
          ReflectApply(listeners[i3], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m2;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m2 = _getMaxListeners(target);
        if (m2 > 0 && existing.length > m2 && !existing.warned) {
          existing.warned = true;
          var w4 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w4.name = "MaxListenersExceededWarning";
          w4.emitter = target;
          w4.type = type;
          w4.count = existing.length;
          ProcessEmitWarning(w4);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state3 = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state3);
      wrapped.listener = listener;
      state3.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i3, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i3 = list.length - 1; i3 >= 0; i3--) {
          if (list[i3] === listener || list[i3].listener === listener) {
            originalListener = list[i3].listener;
            position = i3;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i3;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        var key;
        for (i3 = 0; i3 < keys2.length; ++i3) {
          key = keys2[i3];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i3 = listeners.length - 1; i3 >= 0; i3--) {
          this.removeListener(type, listeners[i3]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n4) {
      var copy = new Array(n4);
      for (var i3 = 0; i3 < n4; ++i3)
        copy[i3] = arr[i3];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i3 = 0; i3 < ret.length; ++i3) {
        ret[i3] = arr[i3].listener || arr[i3];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto;
    function getSubtleCrypto() {
      const browserCrypto = getBrowerCrypto();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto() && !!getSubtleCrypto();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative;
    function isNode2() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode2;
    function isBrowser() {
      return !isReactNative() && !isNode2();
    }
    exports.isBrowser = isBrowser;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_crypto(), exports);
    tslib_1.__exportStar(require_env(), exports);
  }
});

// node_modules/@walletconnect/jsonrpc-ws-connection/node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/@walletconnect/jsonrpc-ws-connection/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n4, iteratee) {
      var index = -1, result = Array(n4);
      while (++index < n4) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data3 = this.__data__;
      if (nativeCreate) {
        var result = data3[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data3, key) ? data3[key] : void 0;
    }
    function hashHas(key) {
      var data3 = this.__data__;
      return nativeCreate ? data3[key] !== void 0 : hasOwnProperty.call(data3, key);
    }
    function hashSet(key, value) {
      var data3 = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data3[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data3 = this.__data__, index = assocIndexOf(data3, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data3.length - 1;
      if (index == lastIndex) {
        data3.pop();
      } else {
        splice.call(data3, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data3 = this.__data__, index = assocIndexOf(data3, key);
      return index < 0 ? void 0 : data3[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data3 = this.__data__, index = assocIndexOf(data3, key);
      if (index < 0) {
        ++this.size;
        data3.push([key, value]);
      } else {
        data3[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data3 = getMapData(this, key), size = data3.size;
      data3.set(key, value);
      this.size += data3.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data3 = this.__data__ = new ListCache(entries);
      this.size = data3.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data3 = this.__data__, result = data3["delete"](key);
      this.size = data3.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data3 = this.__data__;
      if (data3 instanceof ListCache) {
        var pairs = data3.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data3.size;
          return this;
        }
        data3 = this.__data__ = new MapCache(pairs);
      }
      data3.set(key, value);
      this.size = data3.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys2, getSymbols);
    }
    function getMapData(map, key) {
      var data3 = map.__data__;
      return isKeyable(key) ? data3[typeof key == "string" ? "string" : "hash"] : data3.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys2(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/@walletconnect/jsonrpc-http-connection/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/@walletconnect/jsonrpc-http-connection/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var global2 = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F3() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F3.prototype = global2;
      return new F3();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e2) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i3 = 0; i3 < view.length; i3++) {
            chars[i3] = String.fromCharCode(view[i3]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch2;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/@reown/appkit/dist/esm/src/utils/HelpersUtil.js
var WcHelpersUtil = {
  getMethodsByChainNamespace(chainNamespace) {
    switch (chainNamespace) {
      case "solana":
        return [
          "solana_signMessage",
          "solana_signTransaction",
          "solana_requestAccounts",
          "solana_getAccounts"
        ];
      case "eip155":
        return [
          "personal_sign",
          "eth_sign",
          "eth_signTransaction",
          "eth_signTypedData",
          "eth_signTypedData_v3",
          "eth_signTypedData_v4",
          "eth_sendRawTransaction",
          "eth_sendTransaction",
          "wallet_getCapabilities",
          "wallet_sendCalls",
          "wallet_showCallsStatus",
          "wallet_getCallsStatus",
          "wallet_switchEthereumChain"
        ];
      default:
        return [];
    }
  },
  createNamespaces(caipNetworks) {
    return caipNetworks.reduce((acc, chain) => {
      const { chainId, chainNamespace, rpcUrl } = chain;
      const methods = this.getMethodsByChainNamespace(chainNamespace);
      if (!acc[chainNamespace]) {
        acc[chainNamespace] = {
          methods,
          events: ["accountsChanged", "chainChanged"],
          chains: [],
          rpcMap: {}
        };
      }
      const fullChainId = `${chainNamespace}:${chainId}`;
      const namespace = acc[chainNamespace];
      namespace.chains.push(fullChainId);
      if (namespace == null ? void 0 : namespace.rpcMap) {
        namespace.rpcMap[chainId] = rpcUrl;
      }
      return acc;
    }, {});
  }
};

// node_modules/@reown/appkit-utils/dist/esm/src/ConstantsUtil.js
var ConstantsUtil3 = {
  WALLET_CONNECT_CONNECTOR_ID: "walletConnect",
  INJECTED_CONNECTOR_ID: "injected",
  WALLET_STANDARD_CONNECTOR_ID: "announced",
  COINBASE_CONNECTOR_ID: "coinbaseWallet",
  COINBASE_SDK_CONNECTOR_ID: "coinbaseWalletSDK",
  SAFE_CONNECTOR_ID: "safe",
  LEDGER_CONNECTOR_ID: "ledger",
  EIP6963_CONNECTOR_ID: "eip6963",
  AUTH_CONNECTOR_ID: "w3mAuth",
  EIP155: "eip155",
  ADD_CHAIN_METHOD: "wallet_addEthereumChain",
  EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
  EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
  CONNECTOR_RDNS_MAP: {
    coinbaseWallet: "com.coinbase.wallet",
    coinbaseWalletSDK: "com.coinbase.wallet"
  }
};

// node_modules/@reown/appkit-utils/dist/esm/src/PresetsUtil.js
var PresetsUtil = {
  ConnectorExplorerIds: {
    [ConstantsUtil3.COINBASE_CONNECTOR_ID]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [ConstantsUtil3.COINBASE_SDK_CONNECTOR_ID]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [ConstantsUtil3.SAFE_CONNECTOR_ID]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
    [ConstantsUtil3.LEDGER_CONNECTOR_ID]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927"
  },
  NetworkImageIds: {
    1: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
    42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
    43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
    56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
    250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
    10: "ab9c186a-c52f-464b-2906-ca59d760a400",
    137: "41d04d42-da3b-4453-8506-668cc0727900",
    100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
    9001: "f926ff41-260d-4028-635e-91913fc28e00",
    324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
    314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
    4689: "34e68754-e536-40da-c153-6ef2e7188a00",
    1088: "3897a66d-40b9-4833-162f-a2c90531c900",
    1284: "161038da-44ae-4ec7-1208-0ea569454b00",
    1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
    7777777: "845c60df-d429-4991-e687-91ae45791600",
    42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
    8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
    1313161554: "3ff73439-a619-4894-9262-4470c773a100",
    2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
    2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
    "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": "a1b58899-f671-4276-6a5e-56ca5bd59700",
    "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z": "a1b58899-f671-4276-6a5e-56ca5bd59700",
    EtWTRABZaYq6iMfeYKouRu166VU2xqa1: "a1b58899-f671-4276-6a5e-56ca5bd59700"
  },
  ConnectorImageIds: {
    [ConstantsUtil3.COINBASE_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [ConstantsUtil3.COINBASE_SDK_CONNECTOR_ID]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [ConstantsUtil3.SAFE_CONNECTOR_ID]: "461db637-8616-43ce-035a-d89b8a1d5800",
    [ConstantsUtil3.LEDGER_CONNECTOR_ID]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
    [ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
    [ConstantsUtil3.INJECTED_CONNECTOR_ID]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
  },
  ConnectorNamesMap: {
    [ConstantsUtil3.INJECTED_CONNECTOR_ID]: "Browser Wallet",
    [ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID]: "WalletConnect",
    [ConstantsUtil3.COINBASE_CONNECTOR_ID]: "Coinbase",
    [ConstantsUtil3.COINBASE_SDK_CONNECTOR_ID]: "Coinbase",
    [ConstantsUtil3.LEDGER_CONNECTOR_ID]: "Ledger",
    [ConstantsUtil3.SAFE_CONNECTOR_ID]: "Safe"
  },
  ConnectorTypesMap: {
    [ConstantsUtil3.INJECTED_CONNECTOR_ID]: "INJECTED",
    [ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID]: "WALLET_CONNECT",
    [ConstantsUtil3.EIP6963_CONNECTOR_ID]: "ANNOUNCED",
    [ConstantsUtil3.AUTH_CONNECTOR_ID]: "AUTH"
  },
  WalletConnectRpcChainIds: [
    1,
    5,
    11155111,
    10,
    420,
    42161,
    421613,
    137,
    80001,
    42220,
    1313161554,
    1313161555,
    56,
    97,
    43114,
    43113,
    100,
    8453,
    84531,
    7777777,
    999,
    324,
    280
  ]
};

// node_modules/@reown/appkit-utils/dist/esm/src/HelpersUtil.js
var HelpersUtil = {
  getCaipTokens(tokens) {
    if (!tokens) {
      return void 0;
    }
    const caipTokens = {};
    Object.entries(tokens).forEach(([id, token]) => {
      caipTokens[`${ConstantsUtil3.EIP155}:${id}`] = token;
    });
    return caipTokens;
  }
};

// node_modules/@reown/appkit-utils/dist/esm/src/TypeUtil.js
var SocialProviderEnum;
(function(SocialProviderEnum2) {
  SocialProviderEnum2["Google"] = "google";
  SocialProviderEnum2["Github"] = "github";
  SocialProviderEnum2["Apple"] = "apple";
  SocialProviderEnum2["Facebook"] = "facebook";
  SocialProviderEnum2["X"] = "x";
  SocialProviderEnum2["Discord"] = "discord";
  SocialProviderEnum2["Farcaster"] = "farcaster";
})(SocialProviderEnum || (SocialProviderEnum = {}));

// node_modules/@walletconnect/core/dist/index.es.js
var import_events7 = __toESM(require_events());

// node_modules/destr/dist/index.mjs
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  const _value = value.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    value[0] === '"' && value.endsWith('"') && !value.includes("\\")
  ) {
    return _value.slice(1, -1);
  }
  if (_value.length <= 9) {
    const _lval = _value.toLowerCase();
    if (_lval === "true") {
      return true;
    }
    if (_lval === "false") {
      return false;
    }
    if (_lval === "undefined") {
      return void 0;
    }
    if (_lval === "null") {
      return null;
    }
    if (_lval === "nan") {
      return Number.NaN;
    }
    if (_lval === "infinity") {
      return Number.POSITIVE_INFINITY;
    }
    if (_lval === "-infinity") {
      return Number.NEGATIVE_INFINITY;
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// node_modules/unstorage/dist/shared/unstorage.d569726e.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
function checkBufferSupport() {
  if (typeof Buffer === "undefined") {
    throw new TypeError("[unstorage] Buffer is not supported!");
  }
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  checkBufferSupport();
  const base64 = Buffer.from(value).toString("base64");
  return BASE64_PREFIX + base64;
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  checkBufferSupport();
  return Buffer.from(value.slice(BASE64_PREFIX.length), "base64");
}
function normalizeKey(key) {
  if (!key) {
    return "";
  }
  return key.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "");
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base) {
  base = normalizeKey(base);
  return base ? base + ":" : "";
}

// node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data3 = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data3,
    hasItem(key) {
      return data3.has(key);
    },
    getItem(key) {
      return data3.get(key) ?? null;
    },
    getItemRaw(key) {
      return data3.get(key) ?? null;
    },
    setItem(key, value) {
      data3.set(key, value);
    },
    setItemRaw(key, value) {
      data3.set(key, value);
    },
    removeItem(key) {
      data3.delete(key);
    },
    getKeys() {
      return [...data3.keys()];
    },
    clear() {
      data3.clear();
    },
    dispose() {
      data3.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base of context.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r3) => r3.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r3) => r3.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      base = normalizeBaseKey(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      for (const mount of mounts) {
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p3) => fullKey.startsWith(p3))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p3) => !p3.startsWith(mount.mountpoint))
        ];
      }
      return base ? allKeys.filter(
        (key) => key.startsWith(base) && key[key.length - 1] !== "$"
      ) : allKeys.filter((key) => key[key.length - 1] !== "$");
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey(base);
      await Promise.all(
        getMounts(base, false).map(async (m2) => {
          if (m2.driver.clear) {
            return asyncCall(m2.driver.clear, m2.relativeBase, opts);
          }
          if (m2.driver.removeItem) {
            const keys2 = await m2.driver.getKeys(m2.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m2.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey(base);
      if (base && context.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context.mountpoints.push(base);
        context.mountpoints.sort((a4, b3) => b3.length - a4.length);
      }
      context.mounts[base] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {
          context.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      base = normalizeBaseKey(base);
      if (!base || !context.mounts[base]) {
        return;
      }
      if (context.watching && base in context.unwatch) {
        context.unwatch[base]();
        delete context.unwatch[base];
      }
      if (_dispose) {
        await dispose(context.mounts[base]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base);
      delete context.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m2 = getMount(key);
      return {
        driver: m2.driver,
        base: m2.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m2) => ({
        driver: m2.driver,
        base: m2.mountpoint
      }));
    },
    // Aliases
    keys: (base, opts = {}) => storage.getKeys(base, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  const request = indexedDB.open(dbName);
  request.onupgradeneeded = () => request.result.createObjectStore(storeName);
  const dbp = promisifyRequest(request);
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}

// node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x = "idb-keyval";
var z = (i3 = {}) => {
  const t = i3.base && i3.base.length > 0 ? `${i3.base}:` : "", e2 = (s2) => t + s2;
  let n4;
  return i3.dbName && i3.storeName && (n4 = createStore(i3.dbName, i3.storeName)), { name: x, options: i3, async hasItem(s2) {
    return !(typeof await get(e2(s2), n4) > "u");
  }, async getItem(s2) {
    return await get(e2(s2), n4) ?? null;
  }, setItem(s2, a4) {
    return set(e2(s2), a4, n4);
  }, removeItem(s2) {
    return del(e2(s2), n4);
  }, getKeys() {
    return keys(n4);
  }, clear() {
    return clear(n4);
  } };
};
var D = "WALLET_CONNECT_V2_INDEXED_DB";
var E2 = "keyvaluestorage";
var _ = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z({ dbName: D, storeName: E2 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e2 = await this.indexedDb.getItem(t);
    if (e2 !== null) return e2;
  }
  async setItem(t, e2) {
    await this.indexedDb.setItem(t, safeJsonStringify(e2));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i3;
  function t() {
  }
  i3 = t, i3.prototype.getItem = function(e2) {
    return this.hasOwnProperty(e2) ? String(this[e2]) : null;
  }, i3.prototype.setItem = function(e2, n4) {
    this[e2] = String(n4);
  }, i3.prototype.removeItem = function(e2) {
    delete this[e2];
  }, i3.prototype.clear = function() {
    const e2 = this;
    Object.keys(e2).forEach(function(n4) {
      e2[n4] = void 0, delete e2[n4];
    });
  }, i3.prototype.key = function(e2) {
    return e2 = e2 || 0, Object.keys(this)[e2];
  }, i3.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l < "u" && l.localStorage ? c.exports = l.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
})();
function k2(i3) {
  var t;
  return [i3[0], safeJsonParse((t = i3[1]) != null ? t : "")];
}
var K = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k2);
  }
  async getItem(t) {
    const e2 = this.localStorage.getItem(t);
    if (e2 !== null) return safeJsonParse(e2);
  }
  async setItem(t, e2) {
    this.localStorage.setItem(t, safeJsonStringify(e2));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N = "wc_storage_version";
var y2 = 1;
var O = async (i3, t, e2) => {
  const n4 = N, s2 = await t.getItem(n4);
  if (s2 && s2 >= y2) {
    e2(t);
    return;
  }
  const a4 = await i3.getKeys();
  if (!a4.length) {
    e2(t);
    return;
  }
  const m2 = [];
  for (; a4.length; ) {
    const r3 = a4.shift();
    if (!r3) continue;
    const o5 = r3.toLowerCase();
    if (o5.includes("wc@") || o5.includes("walletconnect") || o5.includes("wc_") || o5.includes("wallet_connect")) {
      const f4 = await i3.getItem(r3);
      await t.setItem(r3, f4), m2.push(r3);
    }
  }
  await t.setItem(n4, y2), e2(t), j(i3, m2);
};
var j = async (i3, t) => {
  t.length && t.forEach(async (e2) => {
    await i3.removeItem(e2);
  });
};
var h = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e2) => {
      this.storage = e2, this.initialized = true;
    };
    const t = new K();
    this.storage = t;
    try {
      const e2 = new _();
      O(t, e2, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e2) {
    return await this.initialize(), this.storage.setItem(t, e2);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e2 = setInterval(() => {
        this.initialized && (clearInterval(e2), t());
      }, 20);
    });
  }
};

// node_modules/@walletconnect/heartbeat/dist/index.es.js
var import_events = __toESM(require_events());
var import_time = __toESM(require_cjs());

// node_modules/@walletconnect/events/dist/esm/events.js
var IEvents = class {
};

// node_modules/@walletconnect/heartbeat/dist/index.es.js
var n = class extends IEvents {
  constructor(e2) {
    super();
  }
};
var s = import_time.FIVE_SECONDS;
var r = { pulse: "heartbeat_pulse" };
var i = class _i extends n {
  constructor(e2) {
    super(e2), this.events = new import_events.EventEmitter(), this.interval = s, this.interval = (e2 == null ? void 0 : e2.interval) || s;
  }
  static async init(e2) {
    const t = new _i(e2);
    return await t.init(), t;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), (0, import_time.toMiliseconds)(this.interval));
  }
  pulse() {
    this.events.emit(r.pulse);
  }
};

// node_modules/@walletconnect/types/dist/index.es.js
var import_events4 = __toESM(require_events());
var n2 = class extends IEvents {
  constructor(s2) {
    super(), this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var h2 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a2 = class {
  constructor(s2, t) {
    this.logger = s2, this.core = t;
  }
};
var g = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var u = class extends IEvents {
  constructor(s2) {
    super();
  }
};
var p = class {
  constructor(s2, t, e2, f4) {
    this.core = s2, this.logger = t, this.name = e2;
  }
};
var d = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var x2 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t;
  }
};
var y3 = class {
  constructor(s2, t, e2) {
    this.core = s2, this.logger = t, this.store = e2;
  }
};
var v = class {
  constructor(s2, t) {
    this.projectId = s2, this.logger = t;
  }
};
var C = class {
  constructor(s2, t, e2) {
    this.core = s2, this.logger = t, this.telemetryEnabled = e2;
  }
};
var S = class {
  constructor(s2) {
    this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var M = class {
  constructor(s2) {
    this.client = s2;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());

// node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var import_events5 = __toESM(require_events());

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => n3,
  IEvents: () => e,
  IJsonRpcConnection: () => o2,
  IJsonRpcProvider: () => r2,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getBigIntRpcId: () => getBigIntRpcId,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR = "PARSE_ERROR";
var INVALID_REQUEST = "INVALID_REQUEST";
var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
var INVALID_PARAMS = "INVALID_PARAMS";
var INTERNAL_ERROR = "INTERNAL_ERROR";
var SERVER_ERROR = "SERVER_ERROR";
var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
var STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};
var DEFAULT_ERROR = SERVER_ERROR;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code) {
  return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
  return RESERVED_ERROR_CODES.includes(code);
}
function isValidErrorCode(code) {
  return typeof code === "number";
}
function getError(type) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e2) => e2.code === code);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e2, url, type) {
  return e2.message.includes("getaddrinfo ENOTFOUND") || e2.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e2;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment = __toESM(require_cjs2());
__reExport(env_exports, __toESM(require_cjs2()));
var isNodeJs = import_environment.isNode;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
__reExport(esm_exports, env_exports);

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId(entropy = 3) {
  const date = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error, data3) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data3)
  };
}
function formatErrorMessage(error, data3) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (typeof data3 !== "undefined") {
    error.data = data3;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x3) => x3.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

// node_modules/@walletconnect/jsonrpc-types/dist/index.es.js
var e = class {
};
var o2 = class extends e {
  constructor(c5) {
    super();
  }
};
var n3 = class extends e {
  constructor() {
    super();
  }
};
var r2 = class extends n3 {
  constructor(c5) {
    super();
  }
};

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
var HTTP_REGEX = "^https?:";
var WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}

// node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var o3 = class extends r2 {
  constructor(t) {
    super(t), this.events = new import_events5.EventEmitter(), this.hasRegisteredEventListeners = false, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners();
  }
  async connect(t = this.connection) {
    await this.open(t);
  }
  async disconnect() {
    await this.close();
  }
  on(t, e2) {
    this.events.on(t, e2);
  }
  once(t, e2) {
    this.events.once(t, e2);
  }
  off(t, e2) {
    this.events.off(t, e2);
  }
  removeListener(t, e2) {
    this.events.removeListener(t, e2);
  }
  async request(t, e2) {
    return this.requestStrict(formatJsonRpcRequest(t.method, t.params || [], t.id || getBigIntRpcId().toString()), e2);
  }
  async requestStrict(t, e2) {
    return new Promise(async (i3, s2) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (n4) {
        s2(n4);
      }
      this.events.on(`${t.id}`, (n4) => {
        isJsonRpcError(n4) ? s2(n4.error) : i3(n4.result);
      });
      try {
        await this.connection.send(t, e2);
      } catch (n4) {
        s2(n4);
      }
    });
  }
  setConnection(t = this.connection) {
    return t;
  }
  onPayload(t) {
    this.events.emit("payload", t), isJsonRpcResponse(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", { type: t.method, data: t.params });
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason ? `(${t.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t) => this.onPayload(t)), this.connection.on("close", (t) => this.onClose(t)), this.connection.on("error", (t) => this.events.emit("error", t)), this.connection.on("register_error", (t) => this.onClose()), this.hasRegisteredEventListeners = true);
  }
};

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_events6 = __toESM(require_events());
var w = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser();
var b = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var a3 = (c5) => c5.split("?")[0];
var h3 = 10;
var S2 = w();
var f = class {
  constructor(e2) {
    if (this.url = e2, this.events = new import_events6.EventEmitter(), this.registering = false, !isWsUrl(e2)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e2}`);
    this.url = e2;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async open(e2 = this.url) {
    await this.register(e2);
  }
  async close() {
    return new Promise((e2, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n4) => {
        this.onClose(n4), e2();
      }, this.socket.close();
    });
  }
  async send(e2) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e2));
    } catch (t) {
      this.onError(e2.id, t);
    }
  }
  register(e2 = this.url) {
    if (!isWsUrl(e2)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e2}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n4, o5) => {
        this.events.once("register_error", (s2) => {
          this.resetMaxListeners(), o5(s2);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return o5(new Error("WebSocket connection is missing or invalid"));
          n4(this.socket);
        });
      });
    }
    return this.url = e2, this.registering = true, new Promise((t, n4) => {
      const o5 = new URLSearchParams(e2).get("origin"), s2 = (0, esm_exports.isReactNative)() ? { headers: { origin: o5 } } : { rejectUnauthorized: !isLocalhostUrl(e2) }, i3 = new S2(e2, [], s2);
      b() ? i3.onerror = (r3) => {
        const l4 = r3;
        n4(this.emitError(l4.error));
      } : i3.on("error", (r3) => {
        n4(this.emitError(r3));
      }), i3.onopen = () => {
        this.onOpen(i3), t(i3);
      };
    });
  }
  onOpen(e2) {
    e2.onmessage = (t) => this.onPayload(t), e2.onclose = (t) => this.onClose(t), this.socket = e2, this.registering = false, this.events.emit("open");
  }
  onClose(e2) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e2);
  }
  onPayload(e2) {
    if (typeof e2.data > "u") return;
    const t = typeof e2.data == "string" ? safeJsonParse(e2.data) : e2.data;
    this.events.emit("payload", t);
  }
  onError(e2, t) {
    const n4 = this.parseError(t), o5 = n4.message || n4.toString(), s2 = formatJsonRpcError(e2, o5);
    this.events.emit("payload", s2);
  }
  parseError(e2, t = this.url) {
    return parseConnectionError(e2, a3(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h3 && this.events.setMaxListeners(h3);
  }
  emitError(e2) {
    const t = this.parseError(new Error((e2 == null ? void 0 : e2.message) || `WebSocket connection failed for host: ${a3(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_lodash = __toESM(require_lodash());
function Ds(o5, e2) {
  if (o5.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), s2 = 0; s2 < t.length; s2++) t[s2] = 255;
  for (var i3 = 0; i3 < o5.length; i3++) {
    var r3 = o5.charAt(i3), n4 = r3.charCodeAt(0);
    if (t[n4] !== 255) throw new TypeError(r3 + " is ambiguous");
    t[n4] = i3;
  }
  var a4 = o5.length, c5 = o5.charAt(0), h4 = Math.log(a4) / Math.log(256), d3 = Math.log(256) / Math.log(a4);
  function g3(l4) {
    if (l4 instanceof Uint8Array || (ArrayBuffer.isView(l4) ? l4 = new Uint8Array(l4.buffer, l4.byteOffset, l4.byteLength) : Array.isArray(l4) && (l4 = Uint8Array.from(l4))), !(l4 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (l4.length === 0) return "";
    for (var p3 = 0, _2 = 0, D2 = 0, E4 = l4.length; D2 !== E4 && l4[D2] === 0; ) D2++, p3++;
    for (var N2 = (E4 - D2) * d3 + 1 >>> 0, C2 = new Uint8Array(N2); D2 !== E4; ) {
      for (var L3 = l4[D2], k3 = 0, x3 = N2 - 1; (L3 !== 0 || k3 < _2) && x3 !== -1; x3--, k3++) L3 += 256 * C2[x3] >>> 0, C2[x3] = L3 % a4 >>> 0, L3 = L3 / a4 >>> 0;
      if (L3 !== 0) throw new Error("Non-zero carry");
      _2 = k3, D2++;
    }
    for (var M2 = N2 - _2; M2 !== N2 && C2[M2] === 0; ) M2++;
    for (var ie = c5.repeat(p3); M2 < N2; ++M2) ie += o5.charAt(C2[M2]);
    return ie;
  }
  function m2(l4) {
    if (typeof l4 != "string") throw new TypeError("Expected String");
    if (l4.length === 0) return new Uint8Array();
    var p3 = 0;
    if (l4[p3] !== " ") {
      for (var _2 = 0, D2 = 0; l4[p3] === c5; ) _2++, p3++;
      for (var E4 = (l4.length - p3) * h4 + 1 >>> 0, N2 = new Uint8Array(E4); l4[p3]; ) {
        var C2 = t[l4.charCodeAt(p3)];
        if (C2 === 255) return;
        for (var L3 = 0, k3 = E4 - 1; (C2 !== 0 || L3 < D2) && k3 !== -1; k3--, L3++) C2 += a4 * N2[k3] >>> 0, N2[k3] = C2 % 256 >>> 0, C2 = C2 / 256 >>> 0;
        if (C2 !== 0) throw new Error("Non-zero carry");
        D2 = L3, p3++;
      }
      if (l4[p3] !== " ") {
        for (var x3 = E4 - D2; x3 !== E4 && N2[x3] === 0; ) x3++;
        for (var M2 = new Uint8Array(_2 + (E4 - x3)), ie = _2; x3 !== E4; ) M2[ie++] = N2[x3++];
        return M2;
      }
    }
  }
  function b3(l4) {
    var p3 = m2(l4);
    if (p3) return p3;
    throw new Error(`Non-${e2} character`);
  }
  return { encode: g3, decodeUnsafe: m2, decode: b3 };
}
var ms2 = Ds;
var bs2 = ms2;
var Ye = (o5) => {
  if (o5 instanceof Uint8Array && o5.constructor.name === "Uint8Array") return o5;
  if (o5 instanceof ArrayBuffer) return new Uint8Array(o5);
  if (ArrayBuffer.isView(o5)) return new Uint8Array(o5.buffer, o5.byteOffset, o5.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var fs = (o5) => new TextEncoder().encode(o5);
var _s = (o5) => new TextDecoder().decode(o5);
var Es = class {
  constructor(e2, t, s2) {
    this.name = e2, this.prefix = t, this.baseEncode = s2;
  }
  encode(e2) {
    if (e2 instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e2)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var vs2 = class {
  constructor(e2, t, s2) {
    if (this.name = e2, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s2;
  }
  decode(e2) {
    if (typeof e2 == "string") {
      if (e2.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e2.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e2) {
    return Je(this, e2);
  }
};
var ws2 = class {
  constructor(e2) {
    this.decoders = e2;
  }
  or(e2) {
    return Je(this, e2);
  }
  decode(e2) {
    const t = e2[0], s2 = this.decoders[t];
    if (s2) return s2.decode(e2);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Je = (o5, e2) => new ws2({ ...o5.decoders || { [o5.prefix]: o5 }, ...e2.decoders || { [e2.prefix]: e2 } });
var Is = class {
  constructor(e2, t, s2, i3) {
    this.name = e2, this.prefix = t, this.baseEncode = s2, this.baseDecode = i3, this.encoder = new Es(e2, t, s2), this.decoder = new vs2(e2, t, i3);
  }
  encode(e2) {
    return this.encoder.encode(e2);
  }
  decode(e2) {
    return this.decoder.decode(e2);
  }
};
var ne = ({ name: o5, prefix: e2, encode: t, decode: s2 }) => new Is(o5, e2, t, s2);
var X = ({ prefix: o5, name: e2, alphabet: t }) => {
  const { encode: s2, decode: i3 } = bs2(t, e2);
  return ne({ prefix: o5, name: e2, encode: s2, decode: (r3) => Ye(i3(r3)) });
};
var Ts = (o5, e2, t, s2) => {
  const i3 = {};
  for (let d3 = 0; d3 < e2.length; ++d3) i3[e2[d3]] = d3;
  let r3 = o5.length;
  for (; o5[r3 - 1] === "="; ) --r3;
  const n4 = new Uint8Array(r3 * t / 8 | 0);
  let a4 = 0, c5 = 0, h4 = 0;
  for (let d3 = 0; d3 < r3; ++d3) {
    const g3 = i3[o5[d3]];
    if (g3 === void 0) throw new SyntaxError(`Non-${s2} character`);
    c5 = c5 << t | g3, a4 += t, a4 >= 8 && (a4 -= 8, n4[h4++] = 255 & c5 >> a4);
  }
  if (a4 >= t || 255 & c5 << 8 - a4) throw new SyntaxError("Unexpected end of data");
  return n4;
};
var Cs = (o5, e2, t) => {
  const s2 = e2[e2.length - 1] === "=", i3 = (1 << t) - 1;
  let r3 = "", n4 = 0, a4 = 0;
  for (let c5 = 0; c5 < o5.length; ++c5) for (a4 = a4 << 8 | o5[c5], n4 += 8; n4 > t; ) n4 -= t, r3 += e2[i3 & a4 >> n4];
  if (n4 && (r3 += e2[i3 & a4 << t - n4]), s2) for (; r3.length * t & 7; ) r3 += "=";
  return r3;
};
var f2 = ({ name: o5, prefix: e2, bitsPerChar: t, alphabet: s2 }) => ne({ prefix: e2, name: o5, encode(i3) {
  return Cs(i3, s2, t);
}, decode(i3) {
  return Ts(i3, s2, t, o5);
} });
var Ss = ne({ prefix: "\0", name: "identity", encode: (o5) => _s(o5), decode: (o5) => fs(o5) });
var Ps = Object.freeze({ __proto__: null, identity: Ss });
var Rs = f2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var xs2 = Object.freeze({ __proto__: null, base2: Rs });
var Os = f2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var As2 = Object.freeze({ __proto__: null, base8: Os });
var Ns = X({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Ls = Object.freeze({ __proto__: null, base10: Ns });
var zs = f2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Ms2 = f2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var $s = Object.freeze({ __proto__: null, base16: zs, base16upper: Ms2 });
var ks = f2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Fs = f2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Us = f2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Ks = f2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Bs = f2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var Vs = f2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var js = f2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var qs = f2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var Gs = f2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Hs = Object.freeze({ __proto__: null, base32: ks, base32upper: Fs, base32pad: Us, base32padupper: Ks, base32hex: Bs, base32hexupper: Vs, base32hexpad: js, base32hexpadupper: qs, base32z: Gs });
var Ys = X({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Js = X({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Ws = Object.freeze({ __proto__: null, base36: Ys, base36upper: Js });
var Xs = X({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Zs = X({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Qs = Object.freeze({ __proto__: null, base58btc: Xs, base58flickr: Zs });
var er2 = f2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var tr = f2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var ir = f2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var sr = f2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var rr2 = Object.freeze({ __proto__: null, base64: er2, base64pad: tr, base64url: ir, base64urlpad: sr });
var We = Array.from("");
var nr = We.reduce((o5, e2, t) => (o5[t] = e2, o5), []);
var or = We.reduce((o5, e2, t) => (o5[e2.codePointAt(0)] = t, o5), []);
function ar(o5) {
  return o5.reduce((e2, t) => (e2 += nr[t], e2), "");
}
function cr(o5) {
  const e2 = [];
  for (const t of o5) {
    const s2 = or[t.codePointAt(0)];
    if (s2 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e2.push(s2);
  }
  return new Uint8Array(e2);
}
var hr = ne({ prefix: "", name: "base256emoji", encode: ar, decode: cr });
var lr = Object.freeze({ __proto__: null, base256emoji: hr });
var ur = Ze;
var Xe = 128;
var dr = 127;
var gr2 = ~dr;
var pr2 = Math.pow(2, 31);
function Ze(o5, e2, t) {
  e2 = e2 || [], t = t || 0;
  for (var s2 = t; o5 >= pr2; ) e2[t++] = o5 & 255 | Xe, o5 /= 128;
  for (; o5 & gr2; ) e2[t++] = o5 & 255 | Xe, o5 >>>= 7;
  return e2[t] = o5 | 0, Ze.bytes = t - s2 + 1, e2;
}
var yr = be;
var Dr = 128;
var Qe = 127;
function be(o5, s2) {
  var t = 0, s2 = s2 || 0, i3 = 0, r3 = s2, n4, a4 = o5.length;
  do {
    if (r3 >= a4) throw be.bytes = 0, new RangeError("Could not decode varint");
    n4 = o5[r3++], t += i3 < 28 ? (n4 & Qe) << i3 : (n4 & Qe) * Math.pow(2, i3), i3 += 7;
  } while (n4 >= Dr);
  return be.bytes = r3 - s2, t;
}
var mr = Math.pow(2, 7);
var br = Math.pow(2, 14);
var fr = Math.pow(2, 21);
var _r = Math.pow(2, 28);
var Er = Math.pow(2, 35);
var vr = Math.pow(2, 42);
var wr = Math.pow(2, 49);
var Ir2 = Math.pow(2, 56);
var Tr = Math.pow(2, 63);
var Cr = function(o5) {
  return o5 < mr ? 1 : o5 < br ? 2 : o5 < fr ? 3 : o5 < _r ? 4 : o5 < Er ? 5 : o5 < vr ? 6 : o5 < wr ? 7 : o5 < Ir2 ? 8 : o5 < Tr ? 9 : 10;
};
var Sr2 = { encode: ur, decode: yr, encodingLength: Cr };
var et = Sr2;
var tt = (o5, e2, t = 0) => (et.encode(o5, e2, t), e2);
var it = (o5) => et.encodingLength(o5);
var fe = (o5, e2) => {
  const t = e2.byteLength, s2 = it(o5), i3 = s2 + it(t), r3 = new Uint8Array(i3 + t);
  return tt(o5, r3, 0), tt(t, r3, s2), r3.set(e2, i3), new Pr(o5, t, e2, r3);
};
var Pr = class {
  constructor(e2, t, s2, i3) {
    this.code = e2, this.size = t, this.digest = s2, this.bytes = i3;
  }
};
var st = ({ name: o5, code: e2, encode: t }) => new Rr(o5, e2, t);
var Rr = class {
  constructor(e2, t, s2) {
    this.name = e2, this.code = t, this.encode = s2;
  }
  digest(e2) {
    if (e2 instanceof Uint8Array) {
      const t = this.encode(e2);
      return t instanceof Uint8Array ? fe(this.code, t) : t.then((s2) => fe(this.code, s2));
    } else throw Error("Unknown type, must be binary type");
  }
};
var rt = (o5) => async (e2) => new Uint8Array(await crypto.subtle.digest(o5, e2));
var xr = st({ name: "sha2-256", code: 18, encode: rt("SHA-256") });
var Or = st({ name: "sha2-512", code: 19, encode: rt("SHA-512") });
var Ar = Object.freeze({ __proto__: null, sha256: xr, sha512: Or });
var nt = 0;
var Nr = "identity";
var ot = Ye;
var Lr = (o5) => fe(nt, ot(o5));
var zr = { code: nt, name: Nr, encode: ot, digest: Lr };
var Mr = Object.freeze({ __proto__: null, identity: zr });
new TextEncoder(), new TextDecoder();
var at = { ...Ps, ...xs2, ...As2, ...Ls, ...$s, ...Hs, ...Ws, ...Qs, ...rr2, ...lr };
({ ...Ar, ...Mr });
function $r(o5 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(o5) : new Uint8Array(o5);
}
function ct(o5, e2, t, s2) {
  return { name: o5, prefix: e2, encoder: { name: o5, prefix: e2, encode: t }, decoder: { decode: s2 } };
}
var ht = ct("utf8", "u", (o5) => "u" + new TextDecoder("utf8").decode(o5), (o5) => new TextEncoder().encode(o5.substring(1)));
var _e = ct("ascii", "a", (o5) => {
  let e2 = "a";
  for (let t = 0; t < o5.length; t++) e2 += String.fromCharCode(o5[t]);
  return e2;
}, (o5) => {
  o5 = o5.substring(1);
  const e2 = $r(o5.length);
  for (let t = 0; t < o5.length; t++) e2[t] = o5.charCodeAt(t);
  return e2;
});
var kr = { utf8: ht, "utf-8": ht, hex: at.base16, latin1: _e, ascii: _e, binary: _e, ...at };
function Fr(o5, e2 = "utf8") {
  const t = kr[e2];
  if (!t) throw new Error(`Unsupported encoding "${e2}"`);
  return (e2 === "utf8" || e2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(o5, "utf8") : t.decoder.decode(`${t.prefix}${o5}`);
}
var Ee = "wc";
var ve = 2;
var oe = "core";
var O2 = `${Ee}@2:${oe}:`;
var lt = { name: oe, logger: "error" };
var ut = { database: ":memory:" };
var dt = "crypto";
var we = "client_ed25519_seed";
var gt = import_time2.ONE_DAY;
var pt = "keychain";
var yt = "0.3";
var Dt = "messages";
var mt = "0.3";
var bt = import_time2.SIX_HOURS;
var ft = "publisher";
var _t = "irn";
var Et = "error";
var Ie = "wss://relay.walletconnect.org";
var vt = "relayer";
var w2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var wt = "_subscription";
var T = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var It = 0.1;
var Te = "2.16.1";
var F = { link_mode: "link_mode", relay: "relay" };
var Tt = "0.3";
var Ct = "WALLETCONNECT_CLIENT_ID";
var Ce = "WALLETCONNECT_LINK_MODE_APPS";
var A2 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var St = "subscription";
var Pt = "0.3";
var Rt = import_time2.FIVE_SECONDS * 1e3;
var xt = "pairing";
var Ot = "0.3";
var j2 = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var Z = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var P = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var At = "history";
var Nt = "0.3";
var Lt2 = "expirer";
var R = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var zt = "0.3";
var Mt = "verify-api";
var qr = "https://verify.walletconnect.com";
var $t = "https://verify.walletconnect.org";
var Q = $t;
var kt = `${Q}/v3`;
var Ft = [qr, $t];
var Ut = "echo";
var Kt = "https://echo.walletconnect.com";
var z2 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var $ = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var Hr = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var Yr = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var Jr = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var Wr2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Bt = 0.1;
var Vt = "event-client";
var jt = 86400;
var qt = "https://pulse.walletconnect.com/batch";
var Gt = class {
  constructor(e2, t) {
    this.core = e2, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = pt, this.version = yt, this.initialized = false, this.storagePrefix = O2, this.init = async () => {
      if (!this.initialized) {
        const s2 = await this.getKeyChain();
        typeof s2 < "u" && (this.keychain = s2), this.initialized = true;
      }
    }, this.has = (s2) => (this.isInitialized(), this.keychain.has(s2)), this.set = async (s2, i3) => {
      this.isInitialized(), this.keychain.set(s2, i3), await this.persist();
    }, this.get = (s2) => {
      this.isInitialized();
      const i3 = this.keychain.get(s2);
      if (typeof i3 > "u") {
        const { message: r3 } = xe("NO_MATCHING_KEY", `${this.name}: ${s2}`);
        throw new Error(r3);
      }
      return i3;
    }, this.del = async (s2) => {
      this.isInitialized(), this.keychain.delete(s2), await this.persist();
    }, this.core = e2, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e2) {
    await this.core.storage.setItem(this.storageKey, ss(e2));
  }
  async getKeyChain() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? as(e2) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Ht = class {
  constructor(e2, t, s2) {
    this.core = e2, this.logger = t, this.name = dt, this.randomSessionIdentifier = Eu(), this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (i3) => (this.isInitialized(), this.keychain.has(i3)), this.getClientId = async () => {
      this.isInitialized();
      const i3 = await this.getClientSeed(), r3 = generateKeyPair(i3);
      return encodeIss(r3.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i3 = Mu();
      return this.setPrivateKey(i3.publicKey, i3.privateKey);
    }, this.signJWT = async (i3) => {
      this.isInitialized();
      const r3 = await this.getClientSeed(), n4 = generateKeyPair(r3), a4 = this.randomSessionIdentifier, c5 = gt;
      return await signJWT(a4, i3, c5, n4);
    }, this.generateSharedKey = (i3, r3, n4) => {
      this.isInitialized();
      const a4 = this.getPrivateKey(i3), c5 = Su(a4, r3);
      return this.setSymKey(c5, n4);
    }, this.setSymKey = async (i3, r3) => {
      this.isInitialized();
      const n4 = r3 || Nu(i3);
      return await this.keychain.set(n4, i3), n4;
    }, this.deleteKeyPair = async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }, this.deleteSymKey = async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }, this.encode = async (i3, r3, n4) => {
      this.isInitialized();
      const a4 = io(n4), c5 = safeJsonStringify(r3);
      if (Du(a4)) return Bu(c5, n4 == null ? void 0 : n4.encoding);
      if (Pu(a4)) {
        const m2 = a4.senderPublicKey, b3 = a4.receiverPublicKey;
        i3 = await this.generateSharedKey(m2, b3);
      }
      const h4 = this.getSymKey(i3), { type: d3, senderPublicKey: g3 } = a4;
      return _u({ type: d3, symKey: h4, message: c5, senderPublicKey: g3, encoding: n4 == null ? void 0 : n4.encoding });
    }, this.decode = async (i3, r3, n4) => {
      this.isInitialized();
      const a4 = Ou(r3, n4);
      if (Du(a4)) {
        const c5 = Ru(r3, n4 == null ? void 0 : n4.encoding);
        return safeJsonParse(c5);
      }
      if (Pu(a4)) {
        const c5 = a4.receiverPublicKey, h4 = a4.senderPublicKey;
        i3 = await this.generateSharedKey(c5, h4);
      }
      try {
        const c5 = this.getSymKey(i3), h4 = Cu({ symKey: c5, encoded: r3, encoding: n4 == null ? void 0 : n4.encoding });
        return safeJsonParse(h4);
      } catch (c5) {
        this.logger.error(`Failed to decode message from topic: '${i3}', clientId: '${await this.getClientId()}'`), this.logger.error(c5);
      }
    }, this.getPayloadType = (i3, r3 = $i) => {
      const n4 = Wr({ encoded: i3, encoding: r3 });
      return $e(n4.type);
    }, this.getPayloadSenderPublicKey = (i3, r3 = $i) => {
      const n4 = Wr({ encoded: i3, encoding: r3 });
      return n4.senderPublicKey ? toString(n4.senderPublicKey, Lt) : void 0;
    }, this.core = e2, this.logger = E(t, this.name), this.keychain = s2 || new Gt(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e2, t) {
    return await this.keychain.set(e2, t), e2;
  }
  getPrivateKey(e2) {
    return this.keychain.get(e2);
  }
  async getClientSeed() {
    let e2 = "";
    try {
      e2 = this.keychain.get(we);
    } catch {
      e2 = Eu(), await this.keychain.set(we, e2);
    }
    return Fr(e2, "base16");
  }
  getSymKey(e2) {
    return this.keychain.get(e2);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Yt2 = class extends a2 {
  constructor(e2, t) {
    super(e2, t), this.logger = e2, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = Dt, this.version = mt, this.initialized = false, this.storagePrefix = O2, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s2 = await this.getRelayerMessages();
          typeof s2 < "u" && (this.messages = s2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s2);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (s2, i3) => {
      this.isInitialized();
      const r3 = Iu(i3);
      let n4 = this.messages.get(s2);
      return typeof n4 > "u" && (n4 = {}), typeof n4[r3] < "u" || (n4[r3] = i3, this.messages.set(s2, n4), await this.persist()), r3;
    }, this.get = (s2) => {
      this.isInitialized();
      let i3 = this.messages.get(s2);
      return typeof i3 > "u" && (i3 = {}), i3;
    }, this.has = (s2, i3) => {
      this.isInitialized();
      const r3 = this.get(s2), n4 = Iu(i3);
      return typeof r3[n4] < "u";
    }, this.del = async (s2) => {
      this.isInitialized(), this.messages.delete(s2), await this.persist();
    }, this.logger = E(e2, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e2) {
    await this.core.storage.setItem(this.storageKey, ss(e2));
  }
  async getRelayerMessages() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? as(e2) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Xr2 = class extends g {
  constructor(e2, t) {
    super(e2, t), this.relayer = e2, this.logger = t, this.events = new import_events7.EventEmitter(), this.name = ft, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE), this.failedPublishTimeout = (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND), this.needsTransportRestart = false, this.publish = async (s2, i3, r3) => {
      var n4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s2, message: i3, opts: r3 } });
      const a4 = (r3 == null ? void 0 : r3.ttl) || bt, c5 = ku(r3), h4 = (r3 == null ? void 0 : r3.prompt) || false, d3 = (r3 == null ? void 0 : r3.tag) || 0, g3 = (r3 == null ? void 0 : r3.id) || getBigIntRpcId().toString(), m2 = { topic: s2, message: i3, opts: { ttl: a4, relay: c5, prompt: h4, tag: d3, id: g3, attestation: r3 == null ? void 0 : r3.attestation } }, b3 = `Failed to publish payload, please try again. id:${g3} tag:${d3}`, l4 = Date.now();
      let p3, _2 = 1;
      try {
        for (; p3 === void 0; ) {
          if (Date.now() - l4 > this.publishTimeout) throw new Error(b3);
          this.logger.trace({ id: g3, attempts: _2 }, `publisher.publish - attempt ${_2}`), p3 = await await ds(this.rpcPublish(s2, i3, a4, c5, h4, d3, g3, r3 == null ? void 0 : r3.attestation).catch((D2) => this.logger.warn(D2)), this.publishTimeout, b3), _2++, p3 || await new Promise((D2) => setTimeout(D2, this.failedPublishTimeout));
        }
        this.relayer.events.emit(w2.publish, m2), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: g3, topic: s2, message: i3, opts: r3 } });
      } catch (D2) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(D2), (n4 = r3 == null ? void 0 : r3.internal) != null && n4.throwOnFailedPublish) throw D2;
        this.queue.set(g3, m2);
      }
    }, this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.relayer = e2, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  rpcPublish(e2, t, s2, i3, r3, n4, a4, c5) {
    var h4, d3, g3, m2;
    const b3 = { method: qu(i3.protocol).publish, params: { topic: e2, message: t, ttl: s2, prompt: r3, tag: n4, attestation: c5 }, id: a4 };
    return Pe((h4 = b3.params) == null ? void 0 : h4.prompt) && ((d3 = b3.params) == null || delete d3.prompt), Pe((g3 = b3.params) == null ? void 0 : g3.tag) && ((m2 = b3.params) == null || delete m2.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: b3 }), this.relayer.request(b3);
  }
  removeRequestFromQueue(e2) {
    this.queue.delete(e2);
  }
  checkQueue() {
    this.queue.forEach(async (e2) => {
      const { topic: t, message: s2, opts: i3 } = e2;
      await this.publish(t, s2, i3);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(w2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(w2.message_ack, (e2) => {
      this.removeRequestFromQueue(e2.id.toString());
    });
  }
};
var Zr = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e2, t) => {
      const s2 = this.get(e2);
      this.exists(e2, t) || this.map.set(e2, [...s2, t]);
    }, this.get = (e2) => this.map.get(e2) || [], this.exists = (e2, t) => this.get(e2).includes(t), this.delete = (e2, t) => {
      if (typeof t > "u") {
        this.map.delete(e2);
        return;
      }
      if (!this.map.has(e2)) return;
      const s2 = this.get(e2);
      if (!this.exists(e2, t)) return;
      const i3 = s2.filter((r3) => r3 !== t);
      if (!i3.length) {
        this.map.delete(e2);
        return;
      }
      this.map.set(e2, i3);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var Qr = Object.defineProperty;
var en = Object.defineProperties;
var tn = Object.getOwnPropertyDescriptors;
var Jt = Object.getOwnPropertySymbols;
var sn = Object.prototype.hasOwnProperty;
var rn = Object.prototype.propertyIsEnumerable;
var Wt = (o5, e2, t) => e2 in o5 ? Qr(o5, e2, { enumerable: true, configurable: true, writable: true, value: t }) : o5[e2] = t;
var ee = (o5, e2) => {
  for (var t in e2 || (e2 = {})) sn.call(e2, t) && Wt(o5, t, e2[t]);
  if (Jt) for (var t of Jt(e2)) rn.call(e2, t) && Wt(o5, t, e2[t]);
  return o5;
};
var Se = (o5, e2) => en(o5, tn(e2));
var Xt = class extends d {
  constructor(e2, t) {
    super(e2, t), this.relayer = e2, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new Zr(), this.events = new import_events7.EventEmitter(), this.name = St, this.version = Pt, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = O2, this.subscribeTimeout = (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE), this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = true;
    }, this.subscribe = async (s2, i3) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i3 } });
      try {
        const r3 = ku(i3), n4 = { topic: s2, relay: r3, transportType: i3 == null ? void 0 : i3.transportType };
        this.pending.set(s2, n4);
        const a4 = await this.rpcSubscribe(s2, r3, i3 == null ? void 0 : i3.transportType);
        return typeof a4 == "string" && (this.onSubscribe(a4, n4), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i3 } })), a4;
      } catch (r3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r3), r3;
      }
    }, this.unsubscribe = async (s2, i3) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i3 == null ? void 0 : i3.id) < "u" ? await this.unsubscribeById(s2, i3.id, i3) : await this.unsubscribeByTopic(s2, i3);
    }, this.isSubscribed = async (s2) => {
      if (this.topics.includes(s2)) return true;
      const i3 = `${this.pendingSubscriptionWatchLabel}_${s2}`;
      return await new Promise((r3, n4) => {
        const a4 = new import_time2.Watch();
        a4.start(i3);
        const c5 = setInterval(() => {
          !this.pending.has(s2) && this.topics.includes(s2) && (clearInterval(c5), a4.stop(i3), r3(true)), a4.elapsed(i3) >= Rt && (clearInterval(c5), a4.stop(i3), n4(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }, this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e2, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e2, t) {
    let s2 = false;
    try {
      s2 = this.getSubscription(e2).topic === t;
    } catch {
    }
    return s2;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e2, t) {
    const s2 = this.topicMap.get(e2);
    await Promise.all(s2.map(async (i3) => await this.unsubscribeById(e2, i3, t)));
  }
  async unsubscribeById(e2, t, s2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t, opts: s2 } });
    try {
      const i3 = ku(s2);
      await this.rpcUnsubscribe(e2, t, i3);
      const r3 = er("USER_DISCONNECTED", `${this.name}, ${e2}`);
      await this.onUnsubscribe(e2, t, r3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t, opts: s2 } });
    } catch (i3) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i3), i3;
    }
  }
  async rpcSubscribe(e2, t, s2 = F.relay) {
    s2 === F.relay && await this.restartToComplete();
    const i3 = { method: qu(t.protocol).subscribe, params: { topic: e2 } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      const r3 = Iu(e2 + this.clientId);
      return s2 === F.link_mode ? (setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(i3).catch((n4) => this.logger.warn(n4));
      }, (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), r3) : await await ds(this.relayer.request(i3).catch((n4) => this.logger.warn(n4)), this.subscribeTimeout) ? r3 : null;
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(w2.connection_stalled);
    }
    return null;
  }
  async rpcBatchSubscribe(e2) {
    if (!e2.length) return;
    const t = e2[0].relay, s2 = { method: qu(t.protocol).batchSubscribe, params: { topics: e2.map((i3) => i3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    try {
      return await await ds(this.relayer.request(s2).catch((i3) => this.logger.warn(i3)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(w2.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e2) {
    if (!e2.length) return;
    const t = e2[0].relay, s2 = { method: qu(t.protocol).batchFetchMessages, params: { topics: e2.map((r3) => r3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    let i3;
    try {
      i3 = await await ds(this.relayer.request(s2).catch((r3) => this.logger.warn(r3)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(w2.connection_stalled);
    }
    return i3;
  }
  rpcUnsubscribe(e2, t, s2) {
    const i3 = { method: qu(s2.protocol).unsubscribe, params: { topic: e2, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 }), this.relayer.request(i3);
  }
  onSubscribe(e2, t) {
    this.setSubscription(e2, Se(ee({}, t), { id: e2 })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e2) {
    e2.length && e2.forEach((t) => {
      this.setSubscription(t.id, ee({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e2, t, s2) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e2) && this.deleteSubscription(t, s2), await this.relayer.messages.del(e2);
  }
  async setRelayerSubscriptions(e2) {
    await this.relayer.core.storage.setItem(this.storageKey, e2);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e2, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e2, subscription: t }), this.addSubscription(e2, t);
  }
  addSubscription(e2, t) {
    this.subscriptions.set(e2, ee({}, t)), this.topicMap.set(t.topic, e2), this.events.emit(A2.created, t);
  }
  getSubscription(e2) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e2 });
    const t = this.subscriptions.get(e2);
    if (!t) {
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(s2);
    }
    return t;
  }
  deleteSubscription(e2, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e2, reason: t });
    const s2 = this.getSubscription(e2);
    this.subscriptions.delete(e2), this.topicMap.delete(s2.topic, e2), this.events.emit(A2.deleted, Se(ee({}, s2), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(A2.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e2 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e2; t++) {
        const s2 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchFetchMessages(s2), await this.batchSubscribe(s2);
      }
    }
    this.events.emit(A2.resubscribed);
  }
  async restore() {
    try {
      const e2 = await this.getRelayerSubscriptions();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.subscriptions.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e2);
    }
  }
  async batchSubscribe(e2) {
    if (!e2.length) return;
    const t = await this.rpcBatchSubscribe(e2);
    Ir(t) && this.onBatchSubscribe(t.map((s2, i3) => Se(ee({}, e2[i3]), { id: s2 })));
  }
  async batchFetchMessages(e2) {
    if (!e2.length) return;
    this.logger.trace(`Fetching batch messages for ${e2.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e2);
    t && t.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(t.messages));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected) return;
    const e2 = [];
    this.pending.forEach((t) => {
      e2.push(t);
    }), await this.batchSubscribe(e2), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = []);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, async () => {
      await this.checkPending();
    }), this.events.on(A2.created, async (e2) => {
      const t = A2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), await this.persist();
    }), this.events.on(A2.deleted, async (e2) => {
      const t = A2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen(), this.restartInProgress && await new Promise((e2) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e2());
      }, this.pollingInterval);
    });
  }
};
var nn = Object.defineProperty;
var Zt = Object.getOwnPropertySymbols;
var on = Object.prototype.hasOwnProperty;
var an = Object.prototype.propertyIsEnumerable;
var Qt = (o5, e2, t) => e2 in o5 ? nn(o5, e2, { enumerable: true, configurable: true, writable: true, value: t }) : o5[e2] = t;
var cn = (o5, e2) => {
  for (var t in e2 || (e2 = {})) on.call(e2, t) && Qt(o5, t, e2[t]);
  if (Zt) for (var t of Zt(e2)) an.call(e2, t) && Qt(o5, t, e2[t]);
  return o5;
};
var ei = class extends u {
  constructor(e2) {
    super(e2), this.protocol = "wc", this.version = 2, this.events = new import_events7.EventEmitter(), this.name = vt, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = false, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = (0, import_time2.toMiliseconds)(import_time2.THIRTY_SECONDS + import_time2.ONE_SECOND), this.request = async (t) => {
      var s2, i3;
      this.logger.debug("Publishing Request Payload");
      const r3 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        const n4 = this.provider.request(t);
        this.requestsInFlight.set(r3, { promise: n4, request: t }), this.logger.trace({ id: r3, method: t.method, topic: (s2 = t.params) == null ? void 0 : s2.topic }, "relayer.request - attempt to publish...");
        const a4 = await new Promise(async (c5, h4) => {
          const d3 = () => {
            h4(new Error(`relayer.request - publish interrupted, id: ${r3}`));
          };
          this.provider.on(T.disconnect, d3);
          const g3 = await n4;
          this.provider.off(T.disconnect, d3), c5(g3);
        });
        return this.logger.trace({ id: r3, method: t.method, topic: (i3 = t.params) == null ? void 0 : i3.topic }, "relayer.request - published"), a4;
      } catch (n4) {
        throw this.logger.debug(`Failed to Publish Request: ${r3}`), n4;
      } finally {
        this.requestsInFlight.delete(r3);
      }
    }, this.resetPingTimeout = () => {
      if (bi()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var t, s2, i3;
          (i3 = (s2 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s2.socket) == null || i3.terminate();
        }, this.heartBeatTimeout);
      } catch (t) {
        this.logger.warn(t);
      }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.trace("relayer connected"), this.startPingTimeout(), this.events.emit(w2.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.trace("relayer disconnected"), this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(w2.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(T.payload, this.onPayloadHandler), this.provider.on(T.connect, this.onConnectHandler), this.provider.on(T.disconnect, this.onDisconnectHandler), this.provider.on(T.error, this.onProviderErrorHandler);
    }, this.core = e2.core, this.logger = typeof e2.logger < "u" && typeof e2.logger != "string" ? E(e2.logger, this.name) : (0, import_pino.default)(k({ level: e2.logger || Et })), this.messages = new Yt2(this.logger, e2.core), this.subscriber = new Xt(this, this.logger), this.publisher = new Xr2(this, this.logger), this.relayUrl = (e2 == null ? void 0 : e2.relayUrl) || Ie, this.projectId = e2.projectId, this.bundleId = ts(), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.cached.length > 0) try {
      await this.transportOpen();
    } catch (e2) {
      this.logger.warn(e2);
    }
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e2, t, s2;
    return ((s2 = (t = (e2 = this.provider) == null ? void 0 : e2.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 1;
  }
  get connecting() {
    var e2, t, s2;
    return ((s2 = (t = (e2 = this.provider) == null ? void 0 : e2.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 0;
  }
  async publish(e2, t, s2) {
    this.isInitialized(), await this.publisher.publish(e2, t, s2), await this.recordMessageEvent({ topic: e2, message: t, publishedAt: Date.now(), transportType: F.relay });
  }
  async subscribe(e2, t) {
    var s2;
    this.isInitialized(), (t == null ? void 0 : t.transportType) === "relay" && await this.toEstablishConnection();
    let i3 = ((s2 = this.subscriber.topicMap.get(e2)) == null ? void 0 : s2[0]) || "", r3;
    const n4 = (a4) => {
      a4.topic === e2 && (this.subscriber.off(A2.created, n4), r3());
    };
    return await Promise.all([new Promise((a4) => {
      r3 = a4, this.subscriber.on(A2.created, n4);
    }), new Promise(async (a4) => {
      i3 = await this.subscriber.subscribe(e2, t) || i3, a4();
    })]), i3;
  }
  async unsubscribe(e2, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e2, t);
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
      await Promise.all(Array.from(this.requestsInFlight.values()).map((e2) => e2.promise));
    } catch (e2) {
      this.logger.warn(e2);
    }
    this.hasExperiencedNetworkDisruption || this.connected ? await ds(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e2) {
    await this.confirmOnlineStateOrThrow(), e2 && e2 !== this.relayUrl && (this.relayUrl = e2, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    try {
      await new Promise(async (t, s2) => {
        const i3 = () => {
          this.provider.off(T.disconnect, i3), s2(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(T.disconnect, i3), await ds(this.provider.connect(), (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((r3) => {
          s2(r3);
        }).finally(() => {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
        }), this.subscriber.start().catch((r3) => {
          this.logger.error(r3), this.onDisconnectHandler();
        }), this.hasExperiencedNetworkDisruption = false, t();
      });
    } catch (t) {
      this.logger.error(t);
      const s2 = t;
      if (this.hasExperiencedNetworkDisruption = true, !this.isConnectionStalled(s2.message)) throw t;
    } finally {
      this.connectionAttemptInProgress = false;
    }
  }
  async restartTransport(e2) {
    this.connectionAttemptInProgress || (this.relayUrl = e2 || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Eh()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e2) {
    if ((e2 == null ? void 0 : e2.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e2.sort((s2, i3) => s2.publishedAt - i3.publishedAt);
    this.logger.trace(`Batch of ${t.length} message events sorted`);
    for (const s2 of t) try {
      await this.onMessageEvent(s2);
    } catch (i3) {
      this.logger.warn(i3);
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e2, t) {
    const { topic: s2 } = e2;
    if (!t.sessionExists) {
      const i3 = ms(import_time2.FIVE_MINUTES), r3 = { topic: s2, expiry: i3, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(s2, r3);
    }
    this.events.emit(w2.message, e2), await this.recordMessageEvent(e2);
  }
  startPingTimeout() {
    var e2, t, s2, i3, r3;
    if (bi()) try {
      (t = (e2 = this.provider) == null ? void 0 : e2.connection) != null && t.socket && ((r3 = (i3 = (s2 = this.provider) == null ? void 0 : s2.connection) == null ? void 0 : i3.socket) == null || r3.once("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (n4) {
      this.logger.warn(n4);
    }
  }
  isConnectionStalled(e2) {
    return this.staleConnectionErrors.some((t) => e2.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e2 = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o3(new f(is({ sdkVersion: Te, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e2, useOnCloseEvent: true, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e2) {
    const { topic: t, message: s2 } = e2;
    await this.messages.set(t, s2);
  }
  async shouldIgnoreMessageEvent(e2) {
    const { topic: t, message: s2 } = e2;
    if (!s2 || s2.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${s2}`), true;
    if (!await this.subscriber.isSubscribed(t)) return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const i3 = this.messages.has(t, s2);
    return i3 && this.logger.debug(`Ignoring duplicate message: ${s2}`), i3;
  }
  async onProviderPayload(e2) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e2 }), isJsonRpcRequest(e2)) {
      if (!e2.method.endsWith(wt)) return;
      const t = e2.params, { topic: s2, message: i3, publishedAt: r3, attestation: n4 } = t.data, a4 = { topic: s2, message: i3, publishedAt: r3, transportType: F.relay, attestation: n4 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(cn({ type: "event", event: t.id }, a4)), this.events.emit(t.id, a4), await this.acknowledgePayload(e2), await this.onMessageEvent(a4);
    } else isJsonRpcResponse(e2) && this.events.emit(w2.message_ack, e2);
  }
  async onMessageEvent(e2) {
    await this.shouldIgnoreMessageEvent(e2) || (this.events.emit(w2.message, e2), await this.recordMessageEvent(e2));
  }
  async acknowledgePayload(e2) {
    const t = formatJsonRpcResult(e2.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(T.payload, this.onPayloadHandler), this.provider.off(T.connect, this.onConnectHandler), this.provider.off(T.disconnect, this.onDisconnectHandler), this.provider.off(T.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e2 = await Eh();
    Sh(async (t) => {
      e2 !== t && (e2 = t, t ? await this.restartTransport().catch((s2) => this.logger.error(s2)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(w2.disconnect), this.connectionAttemptInProgress = false, !this.transportExplicitlyClosed && (this.reconnectTimeout || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e2) => this.logger.error(e2));
    }, (0, import_time2.toMiliseconds)(It))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((e2) => {
      const t = setInterval(() => {
        this.connected && (clearInterval(t), e2());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
};
var hn = Object.defineProperty;
var ti = Object.getOwnPropertySymbols;
var ln = Object.prototype.hasOwnProperty;
var un = Object.prototype.propertyIsEnumerable;
var ii = (o5, e2, t) => e2 in o5 ? hn(o5, e2, { enumerable: true, configurable: true, writable: true, value: t }) : o5[e2] = t;
var si = (o5, e2) => {
  for (var t in e2 || (e2 = {})) ln.call(e2, t) && ii(o5, t, e2[t]);
  if (ti) for (var t of ti(e2)) un.call(e2, t) && ii(o5, t, e2[t]);
  return o5;
};
var ri = class extends p {
  constructor(e2, t, s2, i3 = O2, r3 = void 0) {
    super(e2, t, s2, i3), this.core = e2, this.logger = t, this.name = s2, this.map = /* @__PURE__ */ new Map(), this.version = Tt, this.cached = [], this.initialized = false, this.storagePrefix = O2, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n4) => {
        this.getKey && n4 !== null && !Pe(n4) ? this.map.set(this.getKey(n4), n4) : sh(n4) ? this.map.set(n4.id, n4) : ah(n4) && this.map.set(n4.topic, n4);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (n4, a4) => {
      this.isInitialized(), this.map.has(n4) ? await this.update(n4, a4) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: n4, value: a4 }), this.map.set(n4, a4), await this.persist());
    }, this.get = (n4) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: n4 }), this.getData(n4)), this.getAll = (n4) => (this.isInitialized(), n4 ? this.values.filter((a4) => Object.keys(n4).every((c5) => (0, import_lodash.default)(a4[c5], n4[c5]))) : this.values), this.update = async (n4, a4) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: n4, update: a4 });
      const c5 = si(si({}, this.getData(n4)), a4);
      this.map.set(n4, c5), await this.persist();
    }, this.delete = async (n4, a4) => {
      this.isInitialized(), this.map.has(n4) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: n4, reason: a4 }), this.map.delete(n4), this.addToRecentlyDeleted(n4), await this.persist());
    }, this.logger = E(t, this.name), this.storagePrefix = i3, this.getKey = r3;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e2) {
    this.recentlyDeleted.push(e2), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e2) {
    const t = this.map.get(e2);
    if (!t) {
      if (this.recentlyDeleted.includes(e2)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e2}`);
        throw this.logger.error(i3), new Error(i3);
      }
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.error(s2), new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e2 = await this.getDataStore();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.map.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var ni = class {
  constructor(e2, t) {
    this.core = e2, this.logger = t, this.name = xt, this.version = Ot, this.events = new import_events7.default(), this.initialized = false, this.storagePrefix = O2, this.ignoredPayloadTypes = [pr], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: s2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s2])];
    }, this.create = async (s2) => {
      this.isInitialized();
      const i3 = Eu(), r3 = await this.core.crypto.setSymKey(i3), n4 = ms(import_time2.FIVE_MINUTES), a4 = { protocol: _t }, c5 = { topic: r3, expiry: n4, relay: a4, active: false }, h4 = Gu({ protocol: this.core.protocol, version: this.core.version, topic: r3, symKey: i3, relay: a4, expiryTimestamp: n4, methods: s2 == null ? void 0 : s2.methods });
      return this.core.expirer.set(r3, n4), await this.pairings.set(r3, c5), await this.core.relayer.subscribe(r3, { transportType: s2 == null ? void 0 : s2.transportType }), { topic: r3, uri: h4 };
    }, this.pair = async (s2) => {
      this.isInitialized();
      const i3 = this.core.eventClient.createEvent({ properties: { topic: s2 == null ? void 0 : s2.uri, trace: [z2.pairing_started] } });
      this.isValidPair(s2, i3);
      const { topic: r3, symKey: n4, relay: a4, expiryTimestamp: c5, methods: h4 } = Ju(s2.uri);
      i3.props.properties.topic = r3, i3.addTrace(z2.pairing_uri_validation_success), i3.addTrace(z2.pairing_uri_not_expired);
      let d3;
      if (this.pairings.keys.includes(r3)) {
        if (d3 = this.pairings.get(r3), i3.addTrace(z2.existing_pairing), d3.active) throw i3.setError($.active_pairing_already_exists), new Error(`Pairing already exists: ${r3}. Please try again with a new connection URI.`);
        i3.addTrace(z2.pairing_not_expired);
      }
      const g3 = c5 || ms(import_time2.FIVE_MINUTES), m2 = { topic: r3, relay: a4, expiry: g3, active: false, methods: h4 };
      this.core.expirer.set(r3, g3), await this.pairings.set(r3, m2), i3.addTrace(z2.store_new_pairing), s2.activatePairing && await this.activate({ topic: r3 }), this.events.emit(Z.create, m2), i3.addTrace(z2.emit_inactive_pairing), this.core.crypto.keychain.has(r3) || await this.core.crypto.setSymKey(n4, r3), i3.addTrace(z2.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i3.setError($.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(r3, { relay: a4 });
      } catch (b3) {
        throw i3.setError($.subscribe_pairing_topic_failure), b3;
      }
      return i3.addTrace(z2.subscribe_pairing_topic_success), m2;
    }, this.activate = async ({ topic: s2 }) => {
      this.isInitialized();
      const i3 = ms(import_time2.THIRTY_DAYS);
      this.core.expirer.set(s2, i3), await this.pairings.update(s2, { active: true, expiry: i3 });
    }, this.ping = async (s2) => {
      this.isInitialized(), await this.isValidPing(s2);
      const { topic: i3 } = s2;
      if (this.pairings.keys.includes(i3)) {
        const r3 = await this.sendRequest(i3, "wc_pairingPing", {}), { done: n4, resolve: a4, reject: c5 } = ls();
        this.events.once(bs("pairing_ping", r3), ({ error: h4 }) => {
          h4 ? c5(h4) : a4();
        }), await n4();
      }
    }, this.updateExpiry = async ({ topic: s2, expiry: i3 }) => {
      this.isInitialized(), await this.pairings.update(s2, { expiry: i3 });
    }, this.updateMetadata = async ({ topic: s2, metadata: i3 }) => {
      this.isInitialized(), await this.pairings.update(s2, { peerMetadata: i3 });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (s2) => {
      this.isInitialized(), await this.isValidDisconnect(s2);
      const { topic: i3 } = s2;
      this.pairings.keys.includes(i3) && (await this.sendRequest(i3, "wc_pairingDelete", er("USER_DISCONNECTED")), await this.deletePairing(i3));
    }, this.sendRequest = async (s2, i3, r3) => {
      const n4 = formatJsonRpcRequest(i3, r3), a4 = await this.core.crypto.encode(s2, n4), c5 = j2[i3].req;
      return this.core.history.set(s2, n4), this.core.relayer.publish(s2, a4, c5), n4.id;
    }, this.sendResult = async (s2, i3, r3) => {
      const n4 = formatJsonRpcResult(s2, r3), a4 = await this.core.crypto.encode(i3, n4), c5 = await this.core.history.get(i3, s2), h4 = j2[c5.request.method].res;
      await this.core.relayer.publish(i3, a4, h4), await this.core.history.resolve(n4);
    }, this.sendError = async (s2, i3, r3) => {
      const n4 = formatJsonRpcError(s2, r3), a4 = await this.core.crypto.encode(i3, n4), c5 = await this.core.history.get(i3, s2), h4 = j2[c5.request.method] ? j2[c5.request.method].res : j2.unregistered_method.res;
      await this.core.relayer.publish(i3, a4, h4), await this.core.history.resolve(n4);
    }, this.deletePairing = async (s2, i3) => {
      await this.core.relayer.unsubscribe(s2), await Promise.all([this.pairings.delete(s2, er("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s2), i3 ? Promise.resolve() : this.core.expirer.del(s2)]);
    }, this.cleanup = async () => {
      const s2 = this.pairings.getAll().filter((i3) => As(i3.expiry));
      await Promise.all(s2.map((i3) => this.deletePairing(i3.topic)));
    }, this.onRelayEventRequest = (s2) => {
      const { topic: i3, payload: r3 } = s2;
      switch (r3.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i3, r3);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i3, r3);
        default:
          return this.onUnknownRpcMethodRequest(i3, r3);
      }
    }, this.onRelayEventResponse = async (s2) => {
      const { topic: i3, payload: r3 } = s2, n4 = (await this.core.history.get(i3, r3.id)).request.method;
      switch (n4) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i3, r3);
        default:
          return this.onUnknownRpcMethodResponse(n4);
      }
    }, this.onPairingPingRequest = async (s2, i3) => {
      const { id: r3 } = i3;
      try {
        this.isValidPing({ topic: s2 }), await this.sendResult(r3, s2, true), this.events.emit(Z.ping, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onPairingPingResponse = (s2, i3) => {
      const { id: r3 } = i3;
      setTimeout(() => {
        isJsonRpcResult(i3) ? this.events.emit(bs("pairing_ping", r3), {}) : isJsonRpcError(i3) && this.events.emit(bs("pairing_ping", r3), { error: i3.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (s2, i3) => {
      const { id: r3 } = i3;
      try {
        this.isValidDisconnect({ topic: s2 }), await this.deletePairing(s2), this.events.emit(Z.delete, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onUnknownRpcMethodRequest = async (s2, i3) => {
      const { id: r3, method: n4 } = i3;
      try {
        if (this.registeredMethods.includes(n4)) return;
        const a4 = er("WC_METHOD_UNSUPPORTED", n4);
        await this.sendError(r3, s2, a4), this.logger.error(a4);
      } catch (a4) {
        await this.sendError(r3, s2, a4), this.logger.error(a4);
      }
    }, this.onUnknownRpcMethodResponse = (s2) => {
      this.registeredMethods.includes(s2) || this.logger.error(er("WC_METHOD_UNSUPPORTED", s2));
    }, this.isValidPair = (s2, i3) => {
      var r3;
      if (!dh(s2)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `pair() params: ${s2}`);
        throw i3.setError($.malformed_pairing_uri), new Error(a4);
      }
      if (!oh(s2.uri)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `pair() uri: ${s2.uri}`);
        throw i3.setError($.malformed_pairing_uri), new Error(a4);
      }
      const n4 = Ju(s2 == null ? void 0 : s2.uri);
      if (!((r3 = n4 == null ? void 0 : n4.relay) != null && r3.protocol)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i3.setError($.malformed_pairing_uri), new Error(a4);
      }
      if (!(n4 != null && n4.symKey)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i3.setError($.malformed_pairing_uri), new Error(a4);
      }
      if (n4 != null && n4.expiryTimestamp && (0, import_time2.toMiliseconds)(n4 == null ? void 0 : n4.expiryTimestamp) < Date.now()) {
        i3.setError($.pairing_expired);
        const { message: a4 } = xe("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a4);
      }
    }, this.isValidPing = async (s2) => {
      if (!dh(s2)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `ping() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i3 } = s2;
      await this.isValidPairingTopic(i3);
    }, this.isValidDisconnect = async (s2) => {
      if (!dh(s2)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `disconnect() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i3 } = s2;
      await this.isValidPairingTopic(i3);
    }, this.isValidPairingTopic = async (s2) => {
      if (!Yt(s2, false)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `pairing topic should be a string: ${s2}`);
        throw new Error(i3);
      }
      if (!this.pairings.keys.includes(s2)) {
        const { message: i3 } = xe("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s2}`);
        throw new Error(i3);
      }
      if (As(this.pairings.get(s2).expiry)) {
        await this.deletePairing(s2);
        const { message: i3 } = xe("EXPIRED", `pairing topic: ${s2}`);
        throw new Error(i3);
      }
    }, this.core = e2, this.logger = E(t, this.name), this.pairings = new ri(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(w2.message, async (e2) => {
      const { topic: t, message: s2, transportType: i3 } = e2;
      if (!this.pairings.keys.includes(t) || i3 === F.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s2))) return;
      const r3 = await this.core.crypto.decode(t, s2);
      try {
        isJsonRpcRequest(r3) ? (this.core.history.set(t, r3), this.onRelayEventRequest({ topic: t, payload: r3 })) : isJsonRpcResponse(r3) && (await this.core.history.resolve(r3), await this.onRelayEventResponse({ topic: t, payload: r3 }), this.core.history.delete(t, r3.id));
      } catch (n4) {
        this.logger.error(n4);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(R.expired, async (e2) => {
      const { topic: t } = gs(e2.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(Z.expire, { topic: t }));
    });
  }
};
var oi = class extends h2 {
  constructor(e2, t) {
    super(e2, t), this.core = e2, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events7.EventEmitter(), this.name = At, this.version = Nt, this.cached = [], this.initialized = false, this.storagePrefix = O2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.records.set(s2.id, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (s2, i3, r3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s2, request: i3, chainId: r3 }), this.records.has(i3.id)) return;
      const n4 = { id: i3.id, topic: s2, request: { method: i3.method, params: i3.params || null }, chainId: r3, expiry: ms(import_time2.THIRTY_DAYS) };
      this.records.set(n4.id, n4), this.persist(), this.events.emit(P.created, n4);
    }, this.resolve = async (s2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s2 }), !this.records.has(s2.id)) return;
      const i3 = await this.getRecord(s2.id);
      typeof i3.response > "u" && (i3.response = isJsonRpcError(s2) ? { error: s2.error } : { result: s2.result }, this.records.set(i3.id, i3), this.persist(), this.events.emit(P.updated, i3));
    }, this.get = async (s2, i3) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s2, id: i3 }), await this.getRecord(i3)), this.delete = (s2, i3) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i3 }), this.values.forEach((r3) => {
        if (r3.topic === s2) {
          if (typeof i3 < "u" && r3.id !== i3) return;
          this.records.delete(r3.id), this.events.emit(P.deleted, r3);
        }
      }), this.persist();
    }, this.exists = async (s2, i3) => (this.isInitialized(), this.records.has(i3) ? (await this.getRecord(i3)).topic === s2 : false), this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e2 = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const s2 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e2.push(s2);
    }), e2;
  }
  async setJsonRpcRecords(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e2) {
    this.isInitialized();
    const t = this.records.get(e2);
    if (!t) {
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(P.sync);
  }
  async restore() {
    try {
      const e2 = await this.getJsonRpcRecords();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.records.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e2);
    }
  }
  registerEventListeners() {
    this.events.on(P.created, (e2) => {
      const t = P.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
    }), this.events.on(P.updated, (e2) => {
      const t = P.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
    }), this.events.on(P.deleted, (e2) => {
      const t = P.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
    }), this.core.heartbeat.on(r.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e2 = false;
      this.records.forEach((t) => {
        (0, import_time2.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(P.deleted, t, false), e2 = true);
      }), e2 && this.persist();
    } catch (e2) {
      this.logger.warn(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var ai = class extends x2 {
  constructor(e2, t) {
    super(e2, t), this.core = e2, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events7.EventEmitter(), this.name = Lt2, this.version = zt, this.cached = [], this.initialized = false, this.storagePrefix = O2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.expirations.set(s2.target, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (s2) => {
      try {
        const i3 = this.formatTarget(s2);
        return typeof this.getExpiration(i3) < "u";
      } catch {
        return false;
      }
    }, this.set = (s2, i3) => {
      this.isInitialized();
      const r3 = this.formatTarget(s2), n4 = { target: r3, expiry: i3 };
      this.expirations.set(r3, n4), this.checkExpiry(r3, n4), this.events.emit(R.created, { target: r3, expiration: n4 });
    }, this.get = (s2) => {
      this.isInitialized();
      const i3 = this.formatTarget(s2);
      return this.getExpiration(i3);
    }, this.del = (s2) => {
      if (this.isInitialized(), this.has(s2)) {
        const i3 = this.formatTarget(s2), r3 = this.getExpiration(i3);
        this.expirations.delete(i3), this.events.emit(R.deleted, { target: i3, expiration: r3 });
      }
    }, this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e2) {
    if (typeof e2 == "string") return ps(e2);
    if (typeof e2 == "number") return vs(e2);
    const { message: t } = xe("UNKNOWN_TYPE", `Target type: ${typeof e2}`);
    throw new Error(t);
  }
  async setExpirations(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(R.sync);
  }
  async restore() {
    try {
      const e2 = await this.getExpirations();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.expirations.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e2);
    }
  }
  getExpiration(e2) {
    const t = this.expirations.get(e2);
    if (!t) {
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.warn(s2), new Error(s2);
    }
    return t;
  }
  checkExpiry(e2, t) {
    const { expiry: s2 } = t;
    (0, import_time2.toMiliseconds)(s2) - Date.now() <= 0 && this.expire(e2, t);
  }
  expire(e2, t) {
    this.expirations.delete(e2), this.events.emit(R.expired, { target: e2, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e2, t) => this.checkExpiry(t, e2));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(R.created, (e2) => {
      const t = R.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    }), this.events.on(R.expired, (e2) => {
      const t = R.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    }), this.events.on(R.deleted, (e2) => {
      const t = R.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var y5 = {};
Object.defineProperty(y5, "__esModule", { value: true }), y5.getLocalStorage = y5.getLocalStorageOrThrow = y5.getCrypto = y5.getCryptoOrThrow = y5.getLocation = y5.getLocationOrThrow = y5.getNavigator = y5.getNavigatorOrThrow = ci = y5.getDocument = y5.getDocumentOrThrow = y5.getFromWindowOrThrow = y5.getFromWindow = void 0;
function U2(o5) {
  let e2;
  return typeof window < "u" && typeof window[o5] < "u" && (e2 = window[o5]), e2;
}
y5.getFromWindow = U2;
function q(o5) {
  const e2 = U2(o5);
  if (!e2) throw new Error(`${o5} is not defined in Window`);
  return e2;
}
y5.getFromWindowOrThrow = q;
function dn() {
  return q("document");
}
y5.getDocumentOrThrow = dn;
function gn() {
  return U2("document");
}
var ci = y5.getDocument = gn;
function pn() {
  return q("navigator");
}
y5.getNavigatorOrThrow = pn;
function yn() {
  return U2("navigator");
}
y5.getNavigator = yn;
function Dn() {
  return q("location");
}
y5.getLocationOrThrow = Dn;
function mn2() {
  return U2("location");
}
y5.getLocation = mn2;
function bn() {
  return q("crypto");
}
y5.getCryptoOrThrow = bn;
function fn2() {
  return U2("crypto");
}
y5.getCrypto = fn2;
function _n() {
  return q("localStorage");
}
y5.getLocalStorageOrThrow = _n;
function En() {
  return U2("localStorage");
}
y5.getLocalStorage = En;
var hi = class extends y3 {
  constructor(e2, t, s2) {
    super(e2, t, s2), this.core = e2, this.logger = t, this.store = s2, this.name = Mt, this.verifyUrlV3 = kt, this.storagePrefix = O2, this.version = ve, this.init = async () => {
      var i3;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time2.toMiliseconds)((i3 = this.publicKey) == null ? void 0 : i3.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (i3) => {
      if (!gr() || this.isDevEnv) return;
      const r3 = window.location.origin, { id: n4, decryptedId: a4 } = i3, c5 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r3}&id=${n4}&decryptedId=${a4}`;
      try {
        const h4 = ci(), d3 = this.startAbortTimer(import_time2.ONE_SECOND * 5), g3 = await new Promise((m2, b3) => {
          const l4 = () => {
            window.removeEventListener("message", _2), h4.body.removeChild(p3), b3("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", l4);
          const p3 = h4.createElement("iframe");
          p3.src = c5, p3.style.display = "none", p3.addEventListener("error", l4, { signal: this.abortController.signal });
          const _2 = (D2) => {
            if (!D2.data) return;
            const E4 = JSON.parse(D2.data);
            if (E4.type === "verify_attestation") {
              if (decodeJWT(E4.attestation).payload.id !== n4) return;
              clearInterval(d3), h4.body.removeChild(p3), this.abortController.signal.removeEventListener("abort", l4), window.removeEventListener("message", _2), m2(E4.attestation === null ? "" : E4.attestation);
            }
          };
          h4.body.appendChild(p3), window.addEventListener("message", _2, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", g3), g3;
      } catch (h4) {
        this.logger.warn(h4);
      }
      return "";
    }, this.resolve = async (i3) => {
      if (this.isDevEnv) return "";
      const { attestationId: r3, hash: n4, encryptedId: a4 } = i3;
      if (r3 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (r3) {
        if (decodeJWT(r3).payload.id !== a4) return;
        const h4 = await this.isValidJwtAttestation(r3);
        if (h4) {
          if (!h4.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h4;
        }
      }
      if (!n4) return;
      const c5 = this.getVerifyUrl(i3 == null ? void 0 : i3.verifyUrl);
      return this.fetchAttestation(n4, c5);
    }, this.fetchAttestation = async (i3, r3) => {
      this.logger.debug(`resolving attestation: ${i3} from url: ${r3}`);
      const n4 = this.startAbortTimer(import_time2.ONE_SECOND * 5), a4 = await fetch(`${r3}/attestation/${i3}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(n4), a4.status === 200 ? await a4.json() : void 0;
    }, this.getVerifyUrl = (i3) => {
      let r3 = i3 || Q;
      return Ft.includes(r3) || (this.logger.info(`verify url: ${r3}, not included in trusted list, assigning default: ${Q}`), r3 = Q), r3;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i3 = this.startAbortTimer(import_time2.FIVE_SECONDS), r3 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i3), await r3.json();
      } catch (i3) {
        this.logger.warn(i3);
      }
    }, this.persistPublicKey = async (i3) => {
      this.logger.debug("persisting public key to local storage", i3), await this.store.setItem(this.storeKey, i3), this.publicKey = i3;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (i3) => {
      const r3 = await this.getPublicKey();
      try {
        if (r3) return this.validateAttestation(i3, r3);
      } catch (a4) {
        this.logger.error(a4), this.logger.warn("error validating attestation");
      }
      const n4 = await this.fetchAndPersistPublicKey();
      try {
        if (n4) return this.validateAttestation(i3, n4);
      } catch (a4) {
        this.logger.error(a4), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (r3) => {
        const n4 = await this.fetchPublicKey();
        n4 && (await this.persistPublicKey(n4), r3(n4));
      });
      const i3 = await this.fetchPromise;
      return this.fetchPromise = void 0, i3;
    }, this.validateAttestation = (i3, r3) => {
      const n4 = Uu(i3, r3.publicKey), a4 = { hasExpired: (0, import_time2.toMiliseconds)(n4.exp) < Date.now(), payload: n4 };
      if (a4.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a4.payload.origin, isScam: a4.payload.isScam, isVerified: a4.payload.isVerified };
    }, this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = bi() && process.env.IS_VITEST, this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e2) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e2));
  }
};
var li = class extends v {
  constructor(e2, t) {
    super(e2, t), this.projectId = e2, this.logger = t, this.context = Ut, this.registerDeviceToken = async (s2) => {
      const { clientId: i3, token: r3, notificationType: n4, enableEncrypted: a4 = false } = s2, c5 = `${Kt}/${this.projectId}/clients`;
      await fetch(c5, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i3, type: n4, token: r3, always_raw: a4 }) });
    }, this.logger = E(t, this.context);
  }
};
var vn = Object.defineProperty;
var ui = Object.getOwnPropertySymbols;
var wn = Object.prototype.hasOwnProperty;
var In = Object.prototype.propertyIsEnumerable;
var di = (o5, e2, t) => e2 in o5 ? vn(o5, e2, { enumerable: true, configurable: true, writable: true, value: t }) : o5[e2] = t;
var te = (o5, e2) => {
  for (var t in e2 || (e2 = {})) wn.call(e2, t) && di(o5, t, e2[t]);
  if (ui) for (var t of ui(e2)) In.call(e2, t) && di(o5, t, e2[t]);
  return o5;
};
var gi = class extends C {
  constructor(e2, t, s2 = true) {
    super(e2, t, s2), this.core = e2, this.logger = t, this.context = Vt, this.storagePrefix = O2, this.storageVersion = Bt, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = false, this.createEvent = (i3) => {
      const { event: r3 = "ERROR", type: n4 = "", properties: { topic: a4, trace: c5 } } = i3, h4 = Ms(), d3 = this.core.projectId || "", g3 = Date.now(), m2 = te({ eventId: h4, bundleId: d3, timestamp: g3, props: { event: r3, type: n4, properties: { topic: a4, trace: c5 } } }, this.setMethods(h4));
      return this.telemetryEnabled && (this.events.set(h4, m2), this.shouldPersist = true), m2;
    }, this.getEvent = (i3) => {
      const { eventId: r3, topic: n4 } = i3;
      if (r3) return this.events.get(r3);
      const a4 = Array.from(this.events.values()).find((c5) => c5.props.properties.topic === n4);
      if (a4) return te(te({}, a4), this.setMethods(a4.eventId));
    }, this.deleteEvent = (i3) => {
      const { eventId: r3 } = i3;
      this.events.delete(r3), this.shouldPersist = true;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(r.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i3) => {
          (0, import_time2.fromMiliseconds)(Date.now()) - (0, import_time2.fromMiliseconds)(i3.timestamp) > jt && (this.events.delete(i3.eventId), this.shouldPersist = true);
        });
      });
    }, this.setMethods = (i3) => ({ addTrace: (r3) => this.addTrace(i3, r3), setError: (r3) => this.setError(i3, r3) }), this.addTrace = (i3, r3) => {
      const n4 = this.events.get(i3);
      n4 && (n4.props.properties.trace.push(r3), this.events.set(i3, n4), this.shouldPersist = true);
    }, this.setError = (i3, r3) => {
      const n4 = this.events.get(i3);
      n4 && (n4.props.type = r3, n4.timestamp = Date.now(), this.events.set(i3, n4), this.shouldPersist = true);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }, this.restore = async () => {
      try {
        const i3 = await this.core.storage.getItem(this.storageKey) || [];
        if (!i3.length) return;
        i3.forEach((r3) => {
          this.events.set(r3.eventId, te(te({}, r3), this.setMethods(r3.eventId)));
        });
      } catch (i3) {
        this.logger.warn(i3);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i3 = [];
      for (const [r3, n4] of this.events) n4.props.type && i3.push(n4);
      if (i3.length !== 0) try {
        if ((await fetch(`${qt}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${Te}`, { method: "POST", body: JSON.stringify(i3) })).ok) for (const r3 of i3) this.events.delete(r3.eventId), this.shouldPersist = true;
      } catch (r3) {
        this.logger.warn(r3);
      }
    }, this.logger = E(t, this.context), s2 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Tn = Object.defineProperty;
var pi = Object.getOwnPropertySymbols;
var Cn = Object.prototype.hasOwnProperty;
var Sn = Object.prototype.propertyIsEnumerable;
var yi = (o5, e2, t) => e2 in o5 ? Tn(o5, e2, { enumerable: true, configurable: true, writable: true, value: t }) : o5[e2] = t;
var Di = (o5, e2) => {
  for (var t in e2 || (e2 = {})) Cn.call(e2, t) && yi(o5, t, e2[t]);
  if (pi) for (var t of pi(e2)) Sn.call(e2, t) && yi(o5, t, e2[t]);
  return o5;
};
var ae = class _ae extends n2 {
  constructor(e2) {
    var t;
    super(e2), this.protocol = Ee, this.version = ve, this.name = oe, this.events = new import_events7.EventEmitter(), this.initialized = false, this.on = (n4, a4) => this.events.on(n4, a4), this.once = (n4, a4) => this.events.once(n4, a4), this.off = (n4, a4) => this.events.off(n4, a4), this.removeListener = (n4, a4) => this.events.removeListener(n4, a4), this.dispatchEnvelope = ({ topic: n4, message: a4, sessionExists: c5 }) => {
      if (!n4 || !a4) return;
      const h4 = { topic: n4, message: a4, publishedAt: Date.now(), transportType: F.link_mode };
      this.relayer.onLinkMessageEvent(h4, { sessionExists: c5 });
    }, this.projectId = e2 == null ? void 0 : e2.projectId, this.relayUrl = (e2 == null ? void 0 : e2.relayUrl) || Ie, this.customStoragePrefix = e2 != null && e2.customStoragePrefix ? `:${e2.customStoragePrefix}` : "";
    const s2 = k({ level: typeof (e2 == null ? void 0 : e2.logger) == "string" && e2.logger ? e2.logger : lt.logger }), { logger: i3, chunkLoggerController: r3 } = A({ opts: s2, maxSizeInBytes: e2 == null ? void 0 : e2.maxLogBlobSizeInBytes, loggerOverride: e2 == null ? void 0 : e2.logger });
    this.logChunkController = r3, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var n4, a4;
      (n4 = this.logChunkController) != null && n4.downloadLogsBlobInBrowser && ((a4 = this.logChunkController) == null || a4.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(i3, this.name), this.heartbeat = new i(), this.crypto = new Ht(this, this.logger, e2 == null ? void 0 : e2.keychain), this.history = new oi(this, this.logger), this.expirer = new ai(this, this.logger), this.storage = e2 != null && e2.storage ? e2.storage : new h(Di(Di({}, ut), e2 == null ? void 0 : e2.storageOptions)), this.relayer = new ei({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new ni(this, this.logger), this.verify = new hi(this, this.logger, this.storage), this.echoClient = new li(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new gi(this, this.logger, e2 == null ? void 0 : e2.telemetryEnabled);
  }
  static async init(e2) {
    const t = new _ae(e2);
    await t.initialize();
    const s2 = await t.crypto.getClientId();
    return await t.storage.setItem(Ct, s2), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e2;
    return (e2 = this.logChunkController) == null ? void 0 : e2.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e2) {
    this.linkModeSupportedApps.includes(e2) || (this.linkModeSupportedApps.push(e2), await this.storage.setItem(Ce, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Ce) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e2) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e2), this.logger.error(e2.message), e2;
    }
  }
};
var Pn = ae;

// node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events8 = __toESM(require_events());
var import_time3 = __toESM(require_cjs());
var be2 = "wc";
var Ce2 = 2;
var De2 = "client";
var ye2 = `${be2}@${Ce2}:${De2}:`;
var we2 = { name: De2, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.com" };
var Le = "WALLETCONNECT_DEEPLINK_CHOICE";
var st2 = "proposal";
var it2 = "Proposal expired";
var rt2 = "session";
var z3 = import_time3.SEVEN_DAYS;
var nt2 = "engine";
var v2 = { wc_sessionPropose: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time3.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time3.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var me3 = { min: import_time3.FIVE_MINUTES, max: import_time3.SEVEN_DAYS };
var L = { idle: "IDLE", active: "ACTIVE" };
var ot2 = "request";
var at2 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var ct2 = "wc";
var lt2 = "auth";
var pt2 = "authKeys";
var ht2 = "pairingTopics";
var dt2 = "requests";
var oe2 = `${ct2}@${1.5}:${lt2}:`;
var ae2 = `${oe2}:PUB_KEY`;
var gs2 = Object.defineProperty;
var ys3 = Object.defineProperties;
var ws3 = Object.getOwnPropertyDescriptors;
var ut2 = Object.getOwnPropertySymbols;
var ms3 = Object.prototype.hasOwnProperty;
var _s2 = Object.prototype.propertyIsEnumerable;
var gt2 = (q2, o5, e2) => o5 in q2 ? gs2(q2, o5, { enumerable: true, configurable: true, writable: true, value: e2 }) : q2[o5] = e2;
var I2 = (q2, o5) => {
  for (var e2 in o5 || (o5 = {})) ms3.call(o5, e2) && gt2(q2, e2, o5[e2]);
  if (ut2) for (var e2 of ut2(o5)) _s2.call(o5, e2) && gt2(q2, e2, o5[e2]);
  return q2;
};
var V2 = (q2, o5) => ys3(q2, ws3(o5));
var Es2 = class extends M {
  constructor(o5) {
    super(o5), this.name = nt2, this.events = new import_events8.default(), this.initialized = false, this.requestQueue = { state: L.idle, queue: [] }, this.sessionRequestQueue = { state: L.idle, queue: [] }, this.requestQueueDelay = import_time3.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(v2) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t = V2(I2({}, e2), { requiredNamespaces: e2.requiredNamespaces || {}, optionalNamespaces: e2.optionalNamespaces || {} });
      await this.isValidConnect(t);
      const { pairingTopic: s2, requiredNamespaces: i3, optionalNamespaces: r3, sessionProperties: n4, relays: a4 } = t;
      let c5 = s2, h4, p3 = false;
      try {
        c5 && (p3 = this.client.core.pairing.pairings.get(c5).active);
      } catch (E4) {
        throw this.client.logger.error(`connect() -> pairing.get(${c5}) failed`), E4;
      }
      if (!c5 || !p3) {
        const { topic: E4, uri: S3 } = await this.client.core.pairing.create();
        c5 = E4, h4 = S3;
      }
      if (!c5) {
        const { message: E4 } = xe("NO_MATCHING_KEY", `connect() pairing topic: ${c5}`);
        throw new Error(E4);
      }
      const d3 = await this.client.core.crypto.generateKeyPair(), l4 = v2.wc_sessionPropose.req.ttl || import_time3.FIVE_MINUTES, w4 = ms(l4), m2 = I2({ requiredNamespaces: i3, optionalNamespaces: r3, relays: a4 ?? [{ protocol: _t }], proposer: { publicKey: d3, metadata: this.client.metadata }, expiryTimestamp: w4, pairingTopic: c5 }, n4 && { sessionProperties: n4 }), { reject: y6, resolve: _2, done: R2 } = ls(l4, it2);
      this.events.once(bs("session_connect"), async ({ error: E4, session: S3 }) => {
        if (E4) y6(E4);
        else if (S3) {
          S3.self.publicKey = d3;
          const M2 = V2(I2({}, S3), { pairingTopic: m2.pairingTopic, requiredNamespaces: m2.requiredNamespaces, optionalNamespaces: m2.optionalNamespaces, transportType: F.relay });
          await this.client.session.set(S3.topic, M2), await this.setExpiry(S3.topic, S3.expiry), c5 && await this.client.core.pairing.updateMetadata({ topic: c5, metadata: S3.peer.metadata }), this.cleanupDuplicatePairings(M2), _2(M2);
        }
      });
      const x3 = await this.sendRequest({ topic: c5, method: "wc_sessionPropose", params: m2, throwOnFailedPublish: true });
      return await this.setProposal(x3, I2({ id: x3 }, m2)), { uri: h4, approval: R2 };
    }, this.pair = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e2);
      } catch (t) {
        throw this.client.logger.error("pair() failed"), t;
      }
    }, this.approve = async (e2) => {
      var t, s2, i3;
      const r3 = this.client.core.eventClient.createEvent({ properties: { topic: (t = e2 == null ? void 0 : e2.id) == null ? void 0 : t.toString(), trace: [Hr.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (N2) {
        throw r3.setError(Yr.no_internet_connection), N2;
      }
      try {
        await this.isValidProposalId(e2 == null ? void 0 : e2.id);
      } catch (N2) {
        throw this.client.logger.error(`approve() -> proposal.get(${e2 == null ? void 0 : e2.id}) failed`), r3.setError(Yr.proposal_not_found), N2;
      }
      try {
        await this.isValidApprove(e2);
      } catch (N2) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r3.setError(Yr.session_approve_namespace_validation_failure), N2;
      }
      const { id: n4, relayProtocol: a4, namespaces: c5, sessionProperties: h4, sessionConfig: p3 } = e2, d3 = this.client.proposal.get(n4);
      this.client.core.eventClient.deleteEvent({ eventId: r3.eventId });
      const { pairingTopic: l4, proposer: w4, requiredNamespaces: m2, optionalNamespaces: y6 } = d3;
      let _2 = (s2 = this.client.core.eventClient) == null ? void 0 : s2.getEvent({ topic: l4 });
      _2 || (_2 = (i3 = this.client.core.eventClient) == null ? void 0 : i3.createEvent({ type: Hr.session_approve_started, properties: { topic: l4, trace: [Hr.session_approve_started, Hr.session_namespaces_validation_success] } }));
      const R2 = await this.client.core.crypto.generateKeyPair(), x3 = w4.publicKey, E4 = await this.client.core.crypto.generateSharedKey(R2, x3), S3 = I2(I2({ relay: { protocol: a4 ?? "irn" }, namespaces: c5, controller: { publicKey: R2, metadata: this.client.metadata }, expiry: ms(z3) }, h4 && { sessionProperties: h4 }), p3 && { sessionConfig: p3 }), M2 = F.relay;
      _2.addTrace(Hr.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(E4, { transportType: M2 });
      } catch (N2) {
        throw _2.setError(Yr.subscribe_session_topic_failure), N2;
      }
      _2.addTrace(Hr.subscribe_session_topic_success);
      const W2 = V2(I2({}, S3), { topic: E4, requiredNamespaces: m2, optionalNamespaces: y6, pairingTopic: l4, acknowledged: false, self: S3.controller, peer: { publicKey: w4.publicKey, metadata: w4.metadata }, controller: R2, transportType: F.relay });
      await this.client.session.set(E4, W2), _2.addTrace(Hr.store_session);
      try {
        _2.addTrace(Hr.publishing_session_settle), await this.sendRequest({ topic: E4, method: "wc_sessionSettle", params: S3, throwOnFailedPublish: true }).catch((N2) => {
          throw _2 == null ? void 0 : _2.setError(Yr.session_settle_publish_failure), N2;
        }), _2.addTrace(Hr.session_settle_publish_success), _2.addTrace(Hr.publishing_session_approve), await this.sendResult({ id: n4, topic: l4, result: { relay: { protocol: a4 ?? "irn" }, responderPublicKey: R2 }, throwOnFailedPublish: true }).catch((N2) => {
          throw _2 == null ? void 0 : _2.setError(Yr.session_approve_publish_failure), N2;
        }), _2.addTrace(Hr.session_approve_publish_success);
      } catch (N2) {
        throw this.client.logger.error(N2), this.client.session.delete(E4, er("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(E4), N2;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: _2.eventId }), await this.client.core.pairing.updateMetadata({ topic: l4, metadata: w4.metadata }), await this.client.proposal.delete(n4, er("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: l4 }), await this.setExpiry(E4, ms(z3)), { topic: E4, acknowledged: () => Promise.resolve(this.client.session.get(E4)) };
    }, this.reject = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e2);
      } catch (r3) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r3;
      }
      const { id: t, reason: s2 } = e2;
      let i3;
      try {
        i3 = this.client.proposal.get(t).pairingTopic;
      } catch (r3) {
        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r3;
      }
      i3 && (await this.sendError({ id: t, topic: i3, error: s2, rpcOpts: v2.wc_sessionPropose.reject }), await this.client.proposal.delete(t, er("USER_DISCONNECTED")));
    }, this.update = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e2);
      } catch (p3) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), p3;
      }
      const { topic: t, namespaces: s2 } = e2, { done: i3, resolve: r3, reject: n4 } = ls(), a4 = payloadId(), c5 = getBigIntRpcId().toString(), h4 = this.client.session.get(t).namespaces;
      return this.events.once(bs("session_update", a4), ({ error: p3 }) => {
        p3 ? n4(p3) : r3();
      }), await this.client.session.update(t, { namespaces: s2 }), await this.sendRequest({ topic: t, method: "wc_sessionUpdate", params: { namespaces: s2 }, throwOnFailedPublish: true, clientRpcId: a4, relayRpcId: c5 }).catch((p3) => {
        this.client.logger.error(p3), this.client.session.update(t, { namespaces: h4 }), n4(p3);
      }), { acknowledged: i3 };
    }, this.extend = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e2);
      } catch (a4) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a4;
      }
      const { topic: t } = e2, s2 = payloadId(), { done: i3, resolve: r3, reject: n4 } = ls();
      return this.events.once(bs("session_extend", s2), ({ error: a4 }) => {
        a4 ? n4(a4) : r3();
      }), await this.setExpiry(t, ms(z3)), this.sendRequest({ topic: t, method: "wc_sessionExtend", params: {}, clientRpcId: s2, throwOnFailedPublish: true }).catch((a4) => {
        n4(a4);
      }), { acknowledged: i3 };
    }, this.request = async (e2) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e2);
      } catch (w4) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), w4;
      }
      const { chainId: t, request: s2, topic: i3, expiry: r3 = v2.wc_sessionRequest.req.ttl } = e2, n4 = this.client.session.get(i3);
      (n4 == null ? void 0 : n4.transportType) === F.relay && await this.confirmOnlineStateOrThrow();
      const a4 = payloadId(), c5 = getBigIntRpcId().toString(), { done: h4, resolve: p3, reject: d3 } = ls(r3, "Request expired. Please try again.");
      this.events.once(bs("session_request", a4), ({ error: w4, result: m2 }) => {
        w4 ? d3(w4) : p3(m2);
      });
      const l4 = this.getAppLinkIfEnabled(n4.peer.metadata, n4.transportType);
      return l4 ? (await this.sendRequest({ clientRpcId: a4, relayRpcId: c5, topic: i3, method: "wc_sessionRequest", params: { request: V2(I2({}, s2), { expiryTimestamp: ms(r3) }), chainId: t }, expiry: r3, throwOnFailedPublish: true, appLink: l4 }).catch((w4) => d3(w4)), this.client.events.emit("session_request_sent", { topic: i3, request: s2, chainId: t, id: a4 }), await h4()) : await Promise.all([new Promise(async (w4) => {
        await this.sendRequest({ clientRpcId: a4, relayRpcId: c5, topic: i3, method: "wc_sessionRequest", params: { request: V2(I2({}, s2), { expiryTimestamp: ms(r3) }), chainId: t }, expiry: r3, throwOnFailedPublish: true }).catch((m2) => d3(m2)), this.client.events.emit("session_request_sent", { topic: i3, request: s2, chainId: t, id: a4 }), w4();
      }), new Promise(async (w4) => {
        var m2;
        if (!((m2 = n4.sessionConfig) != null && m2.disableDeepLink)) {
          const y6 = await ws(this.client.core.storage, Le);
          ys({ id: a4, topic: i3, wcDeepLink: y6 });
        }
        w4();
      }), h4()]).then((w4) => w4[2]);
    }, this.respond = async (e2) => {
      this.isInitialized(), await this.isValidRespond(e2);
      const { topic: t, response: s2 } = e2, { id: i3 } = s2, r3 = this.client.session.get(t);
      r3.transportType === F.relay && await this.confirmOnlineStateOrThrow();
      const n4 = this.getAppLinkIfEnabled(r3.peer.metadata, r3.transportType);
      isJsonRpcResult(s2) ? await this.sendResult({ id: i3, topic: t, result: s2.result, throwOnFailedPublish: true, appLink: n4 }) : isJsonRpcError(s2) && await this.sendError({ id: i3, topic: t, error: s2.error, appLink: n4 }), this.cleanupAfterResponse(e2);
    }, this.ping = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e2);
      } catch (s2) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s2;
      }
      const { topic: t } = e2;
      if (this.client.session.keys.includes(t)) {
        const s2 = payloadId(), i3 = getBigIntRpcId().toString(), { done: r3, resolve: n4, reject: a4 } = ls();
        this.events.once(bs("session_ping", s2), ({ error: c5 }) => {
          c5 ? a4(c5) : n4();
        }), await Promise.all([this.sendRequest({ topic: t, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s2, relayRpcId: i3 }), r3()]);
      } else this.client.core.pairing.pairings.keys.includes(t) && await this.client.core.pairing.ping({ topic: t });
    }, this.emit = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e2);
      const { topic: t, event: s2, chainId: i3 } = e2, r3 = getBigIntRpcId().toString();
      await this.sendRequest({ topic: t, method: "wc_sessionEvent", params: { event: s2, chainId: i3 }, throwOnFailedPublish: true, relayRpcId: r3 });
    }, this.disconnect = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e2);
      const { topic: t } = e2;
      if (this.client.session.keys.includes(t)) await this.sendRequest({ topic: t, method: "wc_sessionDelete", params: er("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({ topic: t });
      else {
        const { message: s2 } = xe("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t}`);
        throw new Error(s2);
      }
    }, this.find = (e2) => (this.isInitialized(), this.client.session.getAll().filter((t) => fh(t, e2))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (e2, t) => {
      var s2;
      this.isInitialized(), this.isValidAuthenticate(e2);
      const i3 = t && this.client.core.linkModeSupportedApps.includes(t) && ((s2 = this.client.metadata.redirect) == null ? void 0 : s2.linkMode), r3 = i3 ? F.link_mode : F.relay;
      r3 === F.relay && await this.confirmOnlineStateOrThrow();
      const { chains: n4, statement: a4 = "", uri: c5, domain: h4, nonce: p3, type: d3, exp: l4, nbf: w4, methods: m2 = [], expiry: y6 } = e2, _2 = [...e2.resources || []], { topic: R2, uri: x3 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r3 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: R2, uri: x3 } });
      const E4 = await this.client.core.crypto.generateKeyPair(), S3 = Nu(E4);
      if (await Promise.all([this.client.auth.authKeys.set(ae2, { responseTopic: S3, publicKey: E4 }), this.client.auth.pairingTopics.set(S3, { topic: S3, pairingTopic: R2 })]), await this.client.core.relayer.subscribe(S3, { transportType: r3 }), this.client.logger.info(`sending request to new pairing topic: ${R2}`), m2.length > 0) {
        const { namespace: O4 } = mn(n4[0]);
        let T3 = mu(O4, "request", m2);
        Vr(_2) && (T3 = Au(T3, _2.pop())), _2.push(T3);
      }
      const M2 = y6 && y6 > v2.wc_sessionAuthenticate.req.ttl ? y6 : v2.wc_sessionAuthenticate.req.ttl, W2 = { authPayload: { type: d3 ?? "caip122", chains: n4, statement: a4, aud: c5, domain: h4, version: "1", nonce: p3, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: l4, nbf: w4, resources: _2 }, requester: { publicKey: E4, metadata: this.client.metadata }, expiryTimestamp: ms(M2) }, N2 = { eip155: { chains: n4, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m2])], events: ["chainChanged", "accountsChanged"] } }, Ve = { requiredNamespaces: {}, optionalNamespaces: N2, relays: [{ protocol: "irn" }], pairingTopic: R2, proposer: { publicKey: E4, metadata: this.client.metadata }, expiryTimestamp: ms(v2.wc_sessionPropose.req.ttl) }, { done: wt2, resolve: xe2, reject: Ee2 } = ls(M2, "Request expired"), ce = async ({ error: O4, session: T3 }) => {
        if (this.events.off(bs("session_request", G), Re), O4) Ee2(O4);
        else if (T3) {
          T3.self.publicKey = E4, await this.client.session.set(T3.topic, T3), await this.setExpiry(T3.topic, T3.expiry), R2 && await this.client.core.pairing.updateMetadata({ topic: R2, metadata: T3.peer.metadata });
          const le = this.client.session.get(T3.topic);
          await this.deleteProposal(Z2), xe2({ session: le });
        }
      }, Re = async (O4) => {
        var T3, le, Me;
        if (await this.deletePendingAuthRequest(G, { message: "fulfilled", code: 0 }), O4.error) {
          const te2 = er("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return O4.error.code === te2.code ? void 0 : (this.events.off(bs("session_connect"), ce), Ee2(O4.error.message));
        }
        await this.deleteProposal(Z2), this.events.off(bs("session_connect"), ce);
        const { cacaos: ke, responder: j4 } = O4.result, Ie2 = [], $e2 = [];
        for (const te2 of ke) {
          await lu({ cacao: te2, projectId: this.client.core.projectId }) || (this.client.logger.error(te2, "Signature verification failed"), Ee2(er("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: fe2 } = te2, ve2 = Vr(fe2.resources), Ke2 = [cu(fe2.iss)], mt2 = Yi(fe2.iss);
          if (ve2) {
            const qe = bu(ve2), _t2 = yu(ve2);
            Ie2.push(...qe), Ke2.push(..._t2);
          }
          for (const qe of Ke2) $e2.push(`${qe}:${mt2}`);
        }
        const ee2 = await this.client.core.crypto.generateSharedKey(E4, j4.publicKey);
        let pe;
        Ie2.length > 0 && (pe = { topic: ee2, acknowledged: true, self: { publicKey: E4, metadata: this.client.metadata }, peer: j4, controller: j4.publicKey, expiry: ms(z3), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: R2, namespaces: nh([...new Set(Ie2)], [...new Set($e2)]), transportType: r3 }, await this.client.core.relayer.subscribe(ee2, { transportType: r3 }), await this.client.session.set(ee2, pe), R2 && await this.client.core.pairing.updateMetadata({ topic: R2, metadata: j4.metadata }), pe = this.client.session.get(ee2)), (T3 = this.client.metadata.redirect) != null && T3.linkMode && (le = j4.metadata.redirect) != null && le.linkMode && (Me = j4.metadata.redirect) != null && Me.universal && t && (this.client.core.addLinkModeSupportedApp(j4.metadata.redirect.universal), this.client.session.update(ee2, { transportType: F.link_mode })), xe2({ auths: ke, session: pe });
      }, G = payloadId(), Z2 = payloadId();
      this.events.once(bs("session_connect"), ce), this.events.once(bs("session_request", G), Re);
      let Se2;
      try {
        if (i3) {
          const O4 = formatJsonRpcRequest("wc_sessionAuthenticate", W2, G);
          this.client.core.history.set(R2, O4);
          const T3 = await this.client.core.crypto.encode("", O4, { type: Sr, encoding: wu });
          Se2 = Yu(t, R2, T3);
        } else await Promise.all([this.sendRequest({ topic: R2, method: "wc_sessionAuthenticate", params: W2, expiry: e2.expiry, throwOnFailedPublish: true, clientRpcId: G }), this.sendRequest({ topic: R2, method: "wc_sessionPropose", params: Ve, expiry: v2.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: Z2 })]);
      } catch (O4) {
        throw this.events.off(bs("session_connect"), ce), this.events.off(bs("session_request", G), Re), O4;
      }
      return await this.setProposal(Z2, I2({ id: Z2 }, Ve)), await this.setAuthRequest(G, { request: V2(I2({}, W2), { verifyContext: {} }), pairingTopic: R2, transportType: r3 }), { uri: Se2 ?? x3, response: wt2 };
    }, this.approveSessionAuthenticate = async (e2) => {
      const { id: t, auths: s2 } = e2, i3 = this.client.core.eventClient.createEvent({ properties: { topic: t.toString(), trace: [Jr.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (y6) {
        throw i3.setError(Wr2.no_internet_connection), y6;
      }
      const r3 = this.getPendingAuthRequest(t);
      if (!r3) throw i3.setError(Wr2.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);
      const n4 = r3.transportType || F.relay;
      n4 === F.relay && await this.confirmOnlineStateOrThrow();
      const a4 = r3.requester.publicKey, c5 = await this.client.core.crypto.generateKeyPair(), h4 = Nu(a4), p3 = { type: pr, receiverPublicKey: a4, senderPublicKey: c5 }, d3 = [], l4 = [];
      for (const y6 of s2) {
        if (!await lu({ cacao: y6, projectId: this.client.core.projectId })) {
          i3.setError(Wr2.invalid_cacao);
          const S3 = er("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t, topic: h4, error: S3, encodeOpts: p3 }), new Error(S3.message);
        }
        i3.addTrace(Jr.cacaos_verified);
        const { p: _2 } = y6, R2 = Vr(_2.resources), x3 = [cu(_2.iss)], E4 = Yi(_2.iss);
        if (R2) {
          const S3 = bu(R2), M2 = yu(R2);
          d3.push(...S3), x3.push(...M2);
        }
        for (const S3 of x3) l4.push(`${S3}:${E4}`);
      }
      const w4 = await this.client.core.crypto.generateSharedKey(c5, a4);
      i3.addTrace(Jr.create_authenticated_session_topic);
      let m2;
      if ((d3 == null ? void 0 : d3.length) > 0) {
        m2 = { topic: w4, acknowledged: true, self: { publicKey: c5, metadata: this.client.metadata }, peer: { publicKey: a4, metadata: r3.requester.metadata }, controller: a4, expiry: ms(z3), authentication: s2, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r3.pairingTopic, namespaces: nh([...new Set(d3)], [...new Set(l4)]), transportType: n4 }, i3.addTrace(Jr.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w4, { transportType: n4 });
        } catch (y6) {
          throw i3.setError(Wr2.subscribe_authenticated_session_topic_failure), y6;
        }
        i3.addTrace(Jr.subscribe_authenticated_session_topic_success), await this.client.session.set(w4, m2), i3.addTrace(Jr.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r3.pairingTopic, metadata: r3.requester.metadata });
      }
      i3.addTrace(Jr.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: h4, id: t, result: { cacaos: s2, responder: { publicKey: c5, metadata: this.client.metadata } }, encodeOpts: p3, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r3.requester.metadata, n4) });
      } catch (y6) {
        throw i3.setError(Wr2.authenticated_session_approve_publish_failure), y6;
      }
      return await this.client.auth.requests.delete(t, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r3.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i3.eventId }), { session: m2 };
    }, this.rejectSessionAuthenticate = async (e2) => {
      this.isInitialized();
      const { id: t, reason: s2 } = e2, i3 = this.getPendingAuthRequest(t);
      if (!i3) throw new Error(`Could not find pending auth request with id ${t}`);
      i3.transportType === F.relay && await this.confirmOnlineStateOrThrow();
      const r3 = i3.requester.publicKey, n4 = await this.client.core.crypto.generateKeyPair(), a4 = Nu(r3), c5 = { type: pr, receiverPublicKey: r3, senderPublicKey: n4 };
      await this.sendError({ id: t, topic: a4, error: s2, encodeOpts: c5, rpcOpts: v2.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i3.requester.metadata, i3.transportType) }), await this.client.auth.requests.delete(t, { message: "rejected", code: 0 }), await this.client.proposal.delete(t, er("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (e2) => {
      this.isInitialized();
      const { request: t, iss: s2 } = e2;
      return Jf(t, s2);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const e2 = this.relayMessageCache.shift();
          e2 && await this.onRelayMessage(e2);
        } catch (e2) {
          this.client.logger.error(e2);
        }
      }, 50);
    }, this.cleanupDuplicatePairings = async (e2) => {
      if (e2.pairingTopic) try {
        const t = this.client.core.pairing.pairings.get(e2.pairingTopic), s2 = this.client.core.pairing.pairings.getAll().filter((i3) => {
          var r3, n4;
          return ((r3 = i3.peerMetadata) == null ? void 0 : r3.url) && ((n4 = i3.peerMetadata) == null ? void 0 : n4.url) === e2.peer.metadata.url && i3.topic && i3.topic !== t.topic;
        });
        if (s2.length === 0) return;
        this.client.logger.info(`Cleaning up ${s2.length} duplicate pairing(s)`), await Promise.all(s2.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (t) {
        this.client.logger.error(t);
      }
    }, this.deleteSession = async (e2) => {
      var t;
      const { topic: s2, expirerHasDeleted: i3 = false, emitEvent: r3 = true, id: n4 = 0 } = e2, { self: a4 } = this.client.session.get(s2);
      await this.client.core.relayer.unsubscribe(s2), await this.client.session.delete(s2, er("USER_DISCONNECTED")), this.addToRecentlyDeleted(s2, "session"), this.client.core.crypto.keychain.has(a4.publicKey) && await this.client.core.crypto.deleteKeyPair(a4.publicKey), this.client.core.crypto.keychain.has(s2) && await this.client.core.crypto.deleteSymKey(s2), i3 || this.client.core.expirer.del(s2), this.client.core.storage.removeItem(Le).catch((c5) => this.client.logger.warn(c5)), this.getPendingSessionRequests().forEach((c5) => {
        c5.topic === s2 && this.deletePendingSessionRequest(c5.id, er("USER_DISCONNECTED"));
      }), s2 === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = L.idle), r3 && this.client.events.emit("session_delete", { id: n4, topic: s2 });
    }, this.deleteProposal = async (e2, t) => {
      if (t) try {
        const s2 = this.client.proposal.get(e2), i3 = this.client.core.eventClient.getEvent({ topic: s2.pairingTopic });
        i3 == null ? void 0 : i3.setError(Yr.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(e2, er("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e2)]), this.addToRecentlyDeleted(e2, "proposal");
    }, this.deletePendingSessionRequest = async (e2, t, s2 = false) => {
      await Promise.all([this.client.pendingRequest.delete(e2, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e2)]), this.addToRecentlyDeleted(e2, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i3) => i3.id !== e2), s2 && (this.sessionRequestQueue.state = L.idle, this.client.events.emit("session_request_expire", { id: e2 }));
    }, this.deletePendingAuthRequest = async (e2, t, s2 = false) => {
      await Promise.all([this.client.auth.requests.delete(e2, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e2)]);
    }, this.setExpiry = async (e2, t) => {
      this.client.session.keys.includes(e2) && (this.client.core.expirer.set(e2, t), await this.client.session.update(e2, { expiry: t }));
    }, this.setProposal = async (e2, t) => {
      this.client.core.expirer.set(e2, ms(v2.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e2, t);
    }, this.setAuthRequest = async (e2, t) => {
      const { request: s2, pairingTopic: i3, transportType: r3 = F.relay } = t;
      this.client.core.expirer.set(e2, s2.expiryTimestamp), await this.client.auth.requests.set(e2, { authPayload: s2.authPayload, requester: s2.requester, expiryTimestamp: s2.expiryTimestamp, id: e2, pairingTopic: i3, verifyContext: s2.verifyContext, transportType: r3 });
    }, this.setPendingSessionRequest = async (e2) => {
      const { id: t, topic: s2, params: i3, verifyContext: r3 } = e2, n4 = i3.request.expiryTimestamp || ms(v2.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t, n4), await this.client.pendingRequest.set(t, { id: t, topic: s2, params: i3, verifyContext: r3 });
    }, this.sendRequest = async (e2) => {
      const { topic: t, method: s2, params: i3, expiry: r3, relayRpcId: n4, clientRpcId: a4, throwOnFailedPublish: c5, appLink: h4 } = e2, p3 = formatJsonRpcRequest(s2, i3, a4);
      let d3;
      const l4 = !!h4;
      try {
        const y6 = l4 ? wu : $i;
        d3 = await this.client.core.crypto.encode(t, p3, { encoding: y6 });
      } catch (y6) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), y6;
      }
      let w4;
      if (at2.includes(s2)) {
        const y6 = Iu(JSON.stringify(p3)), _2 = Iu(d3);
        w4 = await this.client.core.verify.register({ id: _2, decryptedId: y6 });
      }
      const m2 = v2[s2].req;
      if (m2.attestation = w4, r3 && (m2.ttl = r3), n4 && (m2.id = n4), this.client.core.history.set(t, p3), l4) {
        const y6 = Yu(h4, t, d3);
        await global.Linking.openURL(y6, this.client.name);
      } else {
        const y6 = v2[s2].req;
        r3 && (y6.ttl = r3), n4 && (y6.id = n4), c5 ? (y6.internal = V2(I2({}, y6.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, d3, y6)) : this.client.core.relayer.publish(t, d3, y6).catch((_2) => this.client.logger.error(_2));
      }
      return p3.id;
    }, this.sendResult = async (e2) => {
      const { id: t, topic: s2, result: i3, throwOnFailedPublish: r3, encodeOpts: n4, appLink: a4 } = e2, c5 = formatJsonRpcResult(t, i3);
      let h4;
      const p3 = a4 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const l4 = p3 ? wu : $i;
        h4 = await this.client.core.crypto.encode(s2, c5, V2(I2({}, n4 || {}), { encoding: l4 }));
      } catch (l4) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s2} failed`), l4;
      }
      let d3;
      try {
        d3 = await this.client.core.history.get(s2, t);
      } catch (l4) {
        throw this.client.logger.error(`sendResult() -> history.get(${s2}, ${t}) failed`), l4;
      }
      if (p3) {
        const l4 = Yu(a4, s2, h4);
        await global.Linking.openURL(l4, this.client.name);
      } else {
        const l4 = v2[d3.request.method].res;
        r3 ? (l4.internal = V2(I2({}, l4.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s2, h4, l4)) : this.client.core.relayer.publish(s2, h4, l4).catch((w4) => this.client.logger.error(w4));
      }
      await this.client.core.history.resolve(c5);
    }, this.sendError = async (e2) => {
      const { id: t, topic: s2, error: i3, encodeOpts: r3, rpcOpts: n4, appLink: a4 } = e2, c5 = formatJsonRpcError(t, i3);
      let h4;
      const p3 = a4 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const l4 = p3 ? wu : $i;
        h4 = await this.client.core.crypto.encode(s2, c5, V2(I2({}, r3 || {}), { encoding: l4 }));
      } catch (l4) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s2} failed`), l4;
      }
      let d3;
      try {
        d3 = await this.client.core.history.get(s2, t);
      } catch (l4) {
        throw this.client.logger.error(`sendError() -> history.get(${s2}, ${t}) failed`), l4;
      }
      if (p3) {
        const l4 = Yu(a4, s2, h4);
        await global.Linking.openURL(l4, this.client.name);
      } else {
        const l4 = n4 || v2[d3.request.method].res;
        this.client.core.relayer.publish(s2, h4, l4);
      }
      await this.client.core.history.resolve(c5);
    }, this.cleanup = async () => {
      const e2 = [], t = [];
      this.client.session.getAll().forEach((s2) => {
        let i3 = false;
        As(s2.expiry) && (i3 = true), this.client.core.crypto.keychain.has(s2.topic) || (i3 = true), i3 && e2.push(s2.topic);
      }), this.client.proposal.getAll().forEach((s2) => {
        As(s2.expiryTimestamp) && t.push(s2.id);
      }), await Promise.all([...e2.map((s2) => this.deleteSession({ topic: s2 })), ...t.map((s2) => this.deleteProposal(s2))]);
    }, this.onRelayEventRequest = async (e2) => {
      this.requestQueue.queue.push(e2), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === L.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = L.active;
        const e2 = this.requestQueue.queue.shift();
        if (e2) try {
          await this.processRequest(e2);
        } catch (t) {
          this.client.logger.warn(t);
        }
      }
      this.requestQueue.state = L.idle;
    }, this.processRequest = async (e2) => {
      const { topic: t, payload: s2, attestation: i3, transportType: r3, encryptedId: n4 } = e2, a4 = s2.method;
      if (!this.shouldIgnorePairingRequest({ topic: t, requestMethod: a4 })) switch (a4) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: t, payload: s2, attestation: i3, encryptedId: n4 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(t, s2);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(t, s2);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(t, s2);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(t, s2);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(t, s2);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: t, payload: s2, attestation: i3, encryptedId: n4, transportType: r3 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(t, s2);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: t, payload: s2, attestation: i3, encryptedId: n4, transportType: r3 });
        default:
          return this.client.logger.info(`Unsupported request method ${a4}`);
      }
    }, this.onRelayEventResponse = async (e2) => {
      const { topic: t, payload: s2, transportType: i3 } = e2, r3 = (await this.client.core.history.get(t, s2.id)).request.method;
      switch (r3) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t, s2, i3);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t, s2);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t, s2);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t, s2);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t, s2);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t, s2);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t, s2);
        default:
          return this.client.logger.info(`Unsupported response method ${r3}`);
      }
    }, this.onRelayEventUnknownPayload = (e2) => {
      const { topic: t } = e2, { message: s2 } = xe("MISSING_OR_INVALID", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s2);
    }, this.shouldIgnorePairingRequest = (e2) => {
      const { topic: t, requestMethod: s2 } = e2, i3 = this.expectedPairingMethodMap.get(t);
      return !i3 || i3.includes(s2) ? false : !!(i3.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (e2) => {
      const { topic: t, payload: s2, attestation: i3, encryptedId: r3 } = e2, { params: n4, id: a4 } = s2;
      try {
        const c5 = this.client.core.eventClient.getEvent({ topic: t });
        this.isValidConnect(I2({}, s2.params));
        const h4 = n4.expiryTimestamp || ms(v2.wc_sessionPropose.req.ttl), p3 = I2({ id: a4, pairingTopic: t, expiryTimestamp: h4 }, n4);
        await this.setProposal(a4, p3);
        const d3 = await this.getVerifyContext({ attestationId: i3, hash: Iu(JSON.stringify(s2)), encryptedId: r3, metadata: p3.proposer.metadata });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), c5 == null ? void 0 : c5.setError($.proposal_listener_not_found)), c5 == null ? void 0 : c5.addTrace(z2.emit_session_proposal), this.client.events.emit("session_proposal", { id: a4, params: p3, verifyContext: d3 });
      } catch (c5) {
        await this.sendError({ id: a4, topic: t, error: c5, rpcOpts: v2.wc_sessionPropose.autoReject }), this.client.logger.error(c5);
      }
    }, this.onSessionProposeResponse = async (e2, t, s2) => {
      const { id: i3 } = t;
      if (isJsonRpcResult(t)) {
        const { result: r3 } = t;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r3 });
        const n4 = this.client.proposal.get(i3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n4 });
        const a4 = n4.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a4 });
        const c5 = r3.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: c5 });
        const h4 = await this.client.core.crypto.generateSharedKey(a4, c5);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: h4 });
        const p3 = await this.client.core.relayer.subscribe(h4, { transportType: s2 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p3 }), await this.client.core.pairing.activate({ topic: e2 });
      } else if (isJsonRpcError(t)) {
        await this.client.proposal.delete(i3, er("USER_DISCONNECTED"));
        const r3 = bs("session_connect");
        if (this.events.listenerCount(r3) === 0) throw new Error(`emitting ${r3} without any listeners, 954`);
        this.events.emit(bs("session_connect"), { error: t.error });
      }
    }, this.onSessionSettleRequest = async (e2, t) => {
      const { id: s2, params: i3 } = t;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: r3, controller: n4, expiry: a4, namespaces: c5, sessionProperties: h4, sessionConfig: p3 } = t.params, d3 = V2(I2(I2({ topic: e2, relay: r3, expiry: a4, namespaces: c5, acknowledged: true, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: n4.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: n4.publicKey, metadata: n4.metadata } }, h4 && { sessionProperties: h4 }), p3 && { sessionConfig: p3 }), { transportType: F.relay }), l4 = bs("session_connect");
        if (this.events.listenerCount(l4) === 0) throw new Error(`emitting ${l4} without any listeners 997`);
        this.events.emit(bs("session_connect"), { session: d3 }), await this.sendResult({ id: t.id, topic: e2, result: true, throwOnFailedPublish: true });
      } catch (r3) {
        await this.sendError({ id: s2, topic: e2, error: r3 }), this.client.logger.error(r3);
      }
    }, this.onSessionSettleResponse = async (e2, t) => {
      const { id: s2 } = t;
      isJsonRpcResult(t) ? (await this.client.session.update(e2, { acknowledged: true }), this.events.emit(bs("session_approve", s2), {})) : isJsonRpcError(t) && (await this.client.session.delete(e2, er("USER_DISCONNECTED")), this.events.emit(bs("session_approve", s2), { error: t.error }));
    }, this.onSessionUpdateRequest = async (e2, t) => {
      const { params: s2, id: i3 } = t;
      try {
        const r3 = `${e2}_session_update`, n4 = Nh.get(r3);
        if (n4 && this.isRequestOutOfSync(n4, i3)) {
          this.client.logger.info(`Discarding out of sync request - ${i3}`), this.sendError({ id: i3, topic: e2, error: er("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I2({ topic: e2 }, s2));
        try {
          Nh.set(r3, i3), await this.client.session.update(e2, { namespaces: s2.namespaces }), await this.sendResult({ id: i3, topic: e2, result: true, throwOnFailedPublish: true });
        } catch (a4) {
          throw Nh.delete(r3), a4;
        }
        this.client.events.emit("session_update", { id: i3, topic: e2, params: s2 });
      } catch (r3) {
        await this.sendError({ id: i3, topic: e2, error: r3 }), this.client.logger.error(r3);
      }
    }, this.isRequestOutOfSync = (e2, t) => parseInt(t.toString().slice(0, -3)) <= parseInt(e2.toString().slice(0, -3)), this.onSessionUpdateResponse = (e2, t) => {
      const { id: s2 } = t, i3 = bs("session_update", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(bs("session_update", s2), {}) : isJsonRpcError(t) && this.events.emit(bs("session_update", s2), { error: t.error });
    }, this.onSessionExtendRequest = async (e2, t) => {
      const { id: s2 } = t;
      try {
        this.isValidExtend({ topic: e2 }), await this.setExpiry(e2, ms(z3)), await this.sendResult({ id: s2, topic: e2, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s2, topic: e2 });
      } catch (i3) {
        await this.sendError({ id: s2, topic: e2, error: i3 }), this.client.logger.error(i3);
      }
    }, this.onSessionExtendResponse = (e2, t) => {
      const { id: s2 } = t, i3 = bs("session_extend", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(bs("session_extend", s2), {}) : isJsonRpcError(t) && this.events.emit(bs("session_extend", s2), { error: t.error });
    }, this.onSessionPingRequest = async (e2, t) => {
      const { id: s2 } = t;
      try {
        this.isValidPing({ topic: e2 }), await this.sendResult({ id: s2, topic: e2, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s2, topic: e2 });
      } catch (i3) {
        await this.sendError({ id: s2, topic: e2, error: i3 }), this.client.logger.error(i3);
      }
    }, this.onSessionPingResponse = (e2, t) => {
      const { id: s2 } = t, i3 = bs("session_ping", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(t) ? this.events.emit(bs("session_ping", s2), {}) : isJsonRpcError(t) && this.events.emit(bs("session_ping", s2), { error: t.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e2, t) => {
      const { id: s2 } = t;
      try {
        this.isValidDisconnect({ topic: e2, reason: t.params }), Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(w2.publish, async () => {
            i3(await this.deleteSession({ topic: e2, id: s2 }));
          });
        }), this.sendResult({ id: s2, topic: e2, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e2, error: er("USER_DISCONNECTED") })]).catch((i3) => this.client.logger.error(i3));
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }, this.onSessionRequest = async (e2) => {
      var t, s2, i3;
      const { topic: r3, payload: n4, attestation: a4, encryptedId: c5, transportType: h4 } = e2, { id: p3, params: d3 } = n4;
      try {
        await this.isValidRequest(I2({ topic: r3 }, d3));
        const l4 = this.client.session.get(r3), w4 = await this.getVerifyContext({ attestationId: a4, hash: Iu(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", d3, p3))), encryptedId: c5, metadata: l4.peer.metadata, transportType: h4 }), m2 = { id: p3, topic: r3, params: d3, verifyContext: w4 };
        await this.setPendingSessionRequest(m2), h4 === F.link_mode && (t = l4.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s2 = l4.peer.metadata.redirect) == null ? void 0 : s2.universal), (i3 = this.client.signConfig) != null && i3.disableRequestQueue ? this.emitSessionRequest(m2) : (this.addSessionRequestToSessionRequestQueue(m2), this.processSessionRequestQueue());
      } catch (l4) {
        await this.sendError({ id: p3, topic: r3, error: l4 }), this.client.logger.error(l4);
      }
    }, this.onSessionRequestResponse = (e2, t) => {
      const { id: s2 } = t, i3 = bs("session_request", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(bs("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(bs("session_request", s2), { error: t.error });
    }, this.onSessionEventRequest = async (e2, t) => {
      const { id: s2, params: i3 } = t;
      try {
        const r3 = `${e2}_session_event_${i3.event.name}`, n4 = Nh.get(r3);
        if (n4 && this.isRequestOutOfSync(n4, s2)) {
          this.client.logger.info(`Discarding out of sync request - ${s2}`);
          return;
        }
        this.isValidEmit(I2({ topic: e2 }, i3)), this.client.events.emit("session_event", { id: s2, topic: e2, params: i3 }), Nh.set(r3, s2);
      } catch (r3) {
        await this.sendError({ id: s2, topic: e2, error: r3 }), this.client.logger.error(r3);
      }
    }, this.onSessionAuthenticateResponse = (e2, t) => {
      const { id: s2 } = t;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e2, payload: t }), isJsonRpcResult(t) ? this.events.emit(bs("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(bs("session_request", s2), { error: t.error });
    }, this.onSessionAuthenticateRequest = async (e2) => {
      var t;
      const { topic: s2, payload: i3, attestation: r3, encryptedId: n4, transportType: a4 } = e2;
      try {
        const { requester: c5, authPayload: h4, expiryTimestamp: p3 } = i3.params, d3 = await this.getVerifyContext({ attestationId: r3, hash: Iu(JSON.stringify(i3)), encryptedId: n4, metadata: c5.metadata, transportType: a4 }), l4 = { requester: c5, pairingTopic: s2, id: i3.id, authPayload: h4, verifyContext: d3, expiryTimestamp: p3 };
        await this.setAuthRequest(i3.id, { request: l4, pairingTopic: s2, transportType: a4 }), a4 === F.link_mode && (t = c5.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(c5.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s2, params: i3.params, id: i3.id, verifyContext: d3 });
      } catch (c5) {
        this.client.logger.error(c5);
        const h4 = i3.params.requester.publicKey, p3 = await this.client.core.crypto.generateKeyPair(), d3 = this.getAppLinkIfEnabled(i3.params.requester.metadata, a4), l4 = { type: pr, receiverPublicKey: h4, senderPublicKey: p3 };
        await this.sendError({ id: i3.id, topic: s2, error: c5, encodeOpts: l4, rpcOpts: v2.wc_sessionAuthenticate.autoReject, appLink: d3 });
      }
    }, this.addSessionRequestToSessionRequestQueue = (e2) => {
      this.sessionRequestQueue.queue.push(e2);
    }, this.cleanupAfterResponse = (e2) => {
      this.deletePendingSessionRequest(e2.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = L.idle, this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: e2, error: t }) => {
      const s2 = this.client.core.history.pending;
      s2.length > 0 && s2.filter((i3) => i3.topic === e2 && i3.request.method === "wc_sessionRequest").forEach((i3) => {
        const r3 = i3.request.id, n4 = bs("session_request", r3);
        if (this.events.listenerCount(n4) === 0) throw new Error(`emitting ${n4} without any listeners`);
        this.events.emit(bs("session_request", i3.request.id), { error: t });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === L.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e2 = this.sessionRequestQueue.queue[0];
      if (!e2) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = L.active, this.emitSessionRequest(e2);
      } catch (t) {
        this.client.logger.error(t);
      }
    }, this.emitSessionRequest = (e2) => {
      this.client.events.emit("session_request", e2);
    }, this.onPairingCreated = (e2) => {
      if (e2.methods && this.expectedPairingMethodMap.set(e2.topic, e2.methods), e2.active) return;
      const t = this.client.proposal.getAll().find((s2) => s2.pairingTopic === e2.topic);
      t && this.onSessionProposeRequest({ topic: e2.topic, payload: formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: t.requiredNamespaces, optionalNamespaces: t.optionalNamespaces, relays: t.relays, proposer: t.proposer, sessionProperties: t.sessionProperties }, t.id) });
    }, this.isValidConnect = async (e2) => {
      if (!dh(e2)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e2)}`);
        throw new Error(a4);
      }
      const { pairingTopic: t, requiredNamespaces: s2, optionalNamespaces: i3, sessionProperties: r3, relays: n4 } = e2;
      if (Pe(t) || await this.isValidPairingTopic(t), !ch(n4, true)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `connect() relays: ${n4}`);
        throw new Error(a4);
      }
      !Pe(s2) && Xr(s2) !== 0 && this.validateNamespaces(s2, "requiredNamespaces"), !Pe(i3) && Xr(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), Pe(r3) || this.validateSessionProps(r3, "sessionProperties");
    }, this.validateNamespaces = (e2, t) => {
      const s2 = hh(e2, "connect()", t);
      if (s2) throw new Error(s2.message);
    }, this.isValidApprove = async (e2) => {
      if (!dh(e2)) throw new Error(xe("MISSING_OR_INVALID", `approve() params: ${e2}`).message);
      const { id: t, namespaces: s2, relayProtocol: i3, sessionProperties: r3 } = e2;
      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
      const n4 = this.client.proposal.get(t), a4 = _o(s2, "approve()");
      if (a4) throw new Error(a4.message);
      const c5 = Co(n4.requiredNamespaces, s2, "approve()");
      if (c5) throw new Error(c5.message);
      if (!Yt(i3, true)) {
        const { message: h4 } = xe("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(h4);
      }
      Pe(r3) || this.validateSessionProps(r3, "sessionProperties");
    }, this.isValidReject = async (e2) => {
      if (!dh(e2)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `reject() params: ${e2}`);
        throw new Error(i3);
      }
      const { id: t, reason: s2 } = e2;
      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !ph(s2)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s2)}`);
        throw new Error(i3);
      }
    }, this.isValidSessionSettleRequest = (e2) => {
      if (!dh(e2)) {
        const { message: c5 } = xe("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e2}`);
        throw new Error(c5);
      }
      const { relay: t, controller: s2, namespaces: i3, expiry: r3 } = e2;
      if (!Bo(t)) {
        const { message: c5 } = xe("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c5);
      }
      const n4 = uh(s2, "onSessionSettleRequest()");
      if (n4) throw new Error(n4.message);
      const a4 = _o(i3, "onSessionSettleRequest()");
      if (a4) throw new Error(a4.message);
      if (As(r3)) {
        const { message: c5 } = xe("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c5);
      }
    }, this.isValidUpdate = async (e2) => {
      if (!dh(e2)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `update() params: ${e2}`);
        throw new Error(a4);
      }
      const { topic: t, namespaces: s2 } = e2;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const i3 = this.client.session.get(t), r3 = _o(s2, "update()");
      if (r3) throw new Error(r3.message);
      const n4 = Co(i3.requiredNamespaces, s2, "update()");
      if (n4) throw new Error(n4.message);
    }, this.isValidExtend = async (e2) => {
      if (!dh(e2)) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `extend() params: ${e2}`);
        throw new Error(s2);
      }
      const { topic: t } = e2;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
    }, this.isValidRequest = async (e2) => {
      if (!dh(e2)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `request() params: ${e2}`);
        throw new Error(a4);
      }
      const { topic: t, request: s2, chainId: i3, expiry: r3 } = e2;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const { namespaces: n4 } = this.client.session.get(t);
      if (!Ah(n4, i3)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a4);
      }
      if (!vh(s2)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `request() ${JSON.stringify(s2)}`);
        throw new Error(a4);
      }
      if (!bh(n4, i3, s2.method)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `request() method: ${s2.method}`);
        throw new Error(a4);
      }
      if (r3 && !Mh(r3, me3)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `request() expiry: ${r3}. Expiry must be a number (in seconds) between ${me3.min} and ${me3.max}`);
        throw new Error(a4);
      }
    }, this.isValidRespond = async (e2) => {
      var t;
      if (!dh(e2)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `respond() params: ${e2}`);
        throw new Error(r3);
      }
      const { topic: s2, response: i3 } = e2;
      try {
        await this.isValidSessionTopic(s2);
      } catch (r3) {
        throw (t = e2 == null ? void 0 : e2.response) != null && t.id && this.cleanupAfterResponse(e2), r3;
      }
      if (!gh(i3)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i3)}`);
        throw new Error(r3);
      }
    }, this.isValidPing = async (e2) => {
      if (!dh(e2)) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `ping() params: ${e2}`);
        throw new Error(s2);
      }
      const { topic: t } = e2;
      await this.isValidSessionOrPairingTopic(t);
    }, this.isValidEmit = async (e2) => {
      if (!dh(e2)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() params: ${e2}`);
        throw new Error(n4);
      }
      const { topic: t, event: s2, chainId: i3 } = e2;
      await this.isValidSessionTopic(t);
      const { namespaces: r3 } = this.client.session.get(t);
      if (!Ah(r3, i3)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(n4);
      }
      if (!mh(s2)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n4);
      }
      if (!yh(r3, i3, s2.name)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n4);
      }
    }, this.isValidDisconnect = async (e2) => {
      if (!dh(e2)) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `disconnect() params: ${e2}`);
        throw new Error(s2);
      }
      const { topic: t } = e2;
      await this.isValidSessionOrPairingTopic(t);
    }, this.isValidAuthenticate = (e2) => {
      const { chains: t, uri: s2, domain: i3, nonce: r3 } = e2;
      if (!Array.isArray(t) || t.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!Yt(s2, false)) throw new Error("uri is required parameter");
      if (!Yt(i3, false)) throw new Error("domain is required parameter");
      if (!Yt(r3, false)) throw new Error("nonce is required parameter");
      if ([...new Set(t.map((a4) => mn(a4).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: n4 } = mn(t[0]);
      if (n4 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (e2) => {
      const { attestationId: t, hash: s2, encryptedId: i3, metadata: r3, transportType: n4 } = e2, a4 = { verified: { verifyUrl: r3.verifyUrl || Q, validation: "UNKNOWN", origin: r3.url || "" } };
      try {
        if (n4 === F.link_mode) {
          const h4 = this.getAppLinkIfEnabled(r3, n4);
          return a4.verified.validation = h4 && new URL(h4).origin === new URL(r3.url).origin ? "VALID" : "INVALID", a4;
        }
        const c5 = await this.client.core.verify.resolve({ attestationId: t, hash: s2, encryptedId: i3, verifyUrl: r3.verifyUrl });
        c5 && (a4.verified.origin = c5.origin, a4.verified.isScam = c5.isScam, a4.verified.validation = c5.origin === new URL(r3.url).origin ? "VALID" : "INVALID");
      } catch (c5) {
        this.client.logger.warn(c5);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a4)}`), a4;
    }, this.validateSessionProps = (e2, t) => {
      Object.values(e2).forEach((s2) => {
        if (!Yt(s2, false)) {
          const { message: i3 } = xe("MISSING_OR_INVALID", `${t} must be in Record<string, string> format. Received: ${JSON.stringify(s2)}`);
          throw new Error(i3);
        }
      });
    }, this.getPendingAuthRequest = (e2) => {
      const t = this.client.auth.requests.get(e2);
      return typeof t == "object" ? t : void 0;
    }, this.addToRecentlyDeleted = (e2, t) => {
      if (this.recentlyDeletedMap.set(e2, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s2 = 0;
        const i3 = this.recentlyDeletedLimit / 2;
        for (const r3 of this.recentlyDeletedMap.keys()) {
          if (s2++ >= i3) break;
          this.recentlyDeletedMap.delete(r3);
        }
      }
    }, this.checkRecentlyDeleted = (e2) => {
      const t = this.recentlyDeletedMap.get(e2);
      if (t) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `Record was recently deleted - ${t}: ${e2}`);
        throw new Error(s2);
      }
    }, this.isLinkModeEnabled = (e2, t) => {
      var s2, i3, r3, n4, a4, c5, h4, p3, d3;
      return !e2 || t !== F.link_mode ? false : ((i3 = (s2 = this.client.metadata) == null ? void 0 : s2.redirect) == null ? void 0 : i3.linkMode) === true && ((n4 = (r3 = this.client.metadata) == null ? void 0 : r3.redirect) == null ? void 0 : n4.universal) !== void 0 && ((c5 = (a4 = this.client.metadata) == null ? void 0 : a4.redirect) == null ? void 0 : c5.universal) !== "" && ((h4 = e2 == null ? void 0 : e2.redirect) == null ? void 0 : h4.universal) !== void 0 && ((p3 = e2 == null ? void 0 : e2.redirect) == null ? void 0 : p3.universal) !== "" && ((d3 = e2 == null ? void 0 : e2.redirect) == null ? void 0 : d3.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e2.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }, this.getAppLinkIfEnabled = (e2, t) => {
      var s2;
      return this.isLinkModeEnabled(e2, t) ? (s2 = e2 == null ? void 0 : e2.redirect) == null ? void 0 : s2.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: e2 }) => {
      if (!e2 || !e2.includes("wc_ev") || !e2.includes("topic")) return;
      const t = xs(e2, "topic") || "", s2 = decodeURIComponent(xs(e2, "wc_ev") || ""), i3 = this.client.session.keys.includes(t);
      i3 && this.client.session.update(t, { transportType: F.link_mode }), this.client.core.dispatchEnvelope({ topic: t, message: s2, sessionExists: i3 });
    }, this.registerLinkModeListeners = async () => {
      var e2;
      if (typeof process < "u" && process.env.IS_VITEST || rr() && (e2 = this.client.metadata.redirect) != null && e2.linkMode) {
        const t = global == null ? void 0 : global.Linking;
        if (typeof t < "u") {
          t.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s2 = await t.getInitialURL();
          s2 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s2 });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: o5 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(o5);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(w2.message, (o5) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(o5) : this.onRelayMessage(o5);
    });
  }
  async onRelayMessage(o5) {
    const { topic: e2, message: t, attestation: s2, transportType: i3 } = o5, { publicKey: r3 } = this.client.auth.authKeys.keys.includes(ae2) ? this.client.auth.authKeys.get(ae2) : { responseTopic: void 0, publicKey: void 0 }, n4 = await this.client.core.crypto.decode(e2, t, { receiverPublicKey: r3, encoding: i3 === F.link_mode ? wu : $i });
    try {
      isJsonRpcRequest(n4) ? (this.client.core.history.set(e2, n4), this.onRelayEventRequest({ topic: e2, payload: n4, attestation: s2, transportType: i3, encryptedId: Iu(t) })) : isJsonRpcResponse(n4) ? (await this.client.core.history.resolve(n4), await this.onRelayEventResponse({ topic: e2, payload: n4, transportType: i3 }), this.client.core.history.delete(e2, n4.id)) : this.onRelayEventUnknownPayload({ topic: e2, payload: n4, transportType: i3 });
    } catch (a4) {
      this.client.logger.error(a4);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(R.expired, async (o5) => {
      const { topic: e2, id: t } = gs(o5.target);
      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, xe("EXPIRED"), true);
      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, xe("EXPIRED"), true);
      e2 ? this.client.session.keys.includes(e2) && (await this.deleteSession({ topic: e2, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e2 })) : t && (await this.deleteProposal(t, true), this.client.events.emit("proposal_expire", { id: t }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(Z.create, (o5) => this.onPairingCreated(o5)), this.client.core.pairing.events.on(Z.delete, (o5) => {
      this.addToRecentlyDeleted(o5.topic, "pairing");
    });
  }
  isValidPairingTopic(o5) {
    if (!Yt(o5, false)) {
      const { message: e2 } = xe("MISSING_OR_INVALID", `pairing topic should be a string: ${o5}`);
      throw new Error(e2);
    }
    if (!this.client.core.pairing.pairings.keys.includes(o5)) {
      const { message: e2 } = xe("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o5}`);
      throw new Error(e2);
    }
    if (As(this.client.core.pairing.pairings.get(o5).expiry)) {
      const { message: e2 } = xe("EXPIRED", `pairing topic: ${o5}`);
      throw new Error(e2);
    }
  }
  async isValidSessionTopic(o5) {
    if (!Yt(o5, false)) {
      const { message: e2 } = xe("MISSING_OR_INVALID", `session topic should be a string: ${o5}`);
      throw new Error(e2);
    }
    if (this.checkRecentlyDeleted(o5), !this.client.session.keys.includes(o5)) {
      const { message: e2 } = xe("NO_MATCHING_KEY", `session topic doesn't exist: ${o5}`);
      throw new Error(e2);
    }
    if (As(this.client.session.get(o5).expiry)) {
      await this.deleteSession({ topic: o5 });
      const { message: e2 } = xe("EXPIRED", `session topic: ${o5}`);
      throw new Error(e2);
    }
    if (!this.client.core.crypto.keychain.has(o5)) {
      const { message: e2 } = xe("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o5}`);
      throw await this.deleteSession({ topic: o5 }), new Error(e2);
    }
  }
  async isValidSessionOrPairingTopic(o5) {
    if (this.checkRecentlyDeleted(o5), this.client.session.keys.includes(o5)) await this.isValidSessionTopic(o5);
    else if (this.client.core.pairing.pairings.keys.includes(o5)) this.isValidPairingTopic(o5);
    else if (Yt(o5, false)) {
      const { message: e2 } = xe("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o5}`);
      throw new Error(e2);
    } else {
      const { message: e2 } = xe("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o5}`);
      throw new Error(e2);
    }
  }
  async isValidProposalId(o5) {
    if (!lh(o5)) {
      const { message: e2 } = xe("MISSING_OR_INVALID", `proposal id should be a number: ${o5}`);
      throw new Error(e2);
    }
    if (!this.client.proposal.keys.includes(o5)) {
      const { message: e2 } = xe("NO_MATCHING_KEY", `proposal id doesn't exist: ${o5}`);
      throw new Error(e2);
    }
    if (As(this.client.proposal.get(o5).expiryTimestamp)) {
      await this.deleteProposal(o5);
      const { message: e2 } = xe("EXPIRED", `proposal id: ${o5}`);
      throw new Error(e2);
    }
  }
};
var Rs2 = class extends ri {
  constructor(o5, e2) {
    super(o5, e2, st2, ye2), this.core = o5, this.logger = e2;
  }
};
var yt2 = class extends ri {
  constructor(o5, e2) {
    super(o5, e2, rt2, ye2), this.core = o5, this.logger = e2;
  }
};
var Ss2 = class extends ri {
  constructor(o5, e2) {
    super(o5, e2, ot2, ye2, (t) => t.id), this.core = o5, this.logger = e2;
  }
};
var Is2 = class extends ri {
  constructor(o5, e2) {
    super(o5, e2, pt2, oe2, () => ae2), this.core = o5, this.logger = e2;
  }
};
var fs2 = class extends ri {
  constructor(o5, e2) {
    super(o5, e2, ht2, oe2), this.core = o5, this.logger = e2;
  }
};
var vs3 = class extends ri {
  constructor(o5, e2) {
    super(o5, e2, dt2, oe2, (t) => t.id), this.core = o5, this.logger = e2;
  }
};
var qs2 = class {
  constructor(o5, e2) {
    this.core = o5, this.logger = e2, this.authKeys = new Is2(this.core, this.logger), this.pairingTopics = new fs2(this.core, this.logger), this.requests = new vs3(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var _e2 = class __e extends S {
  constructor(o5) {
    super(o5), this.protocol = be2, this.version = Ce2, this.name = we2.name, this.events = new import_events8.EventEmitter(), this.on = (t, s2) => this.events.on(t, s2), this.once = (t, s2) => this.events.once(t, s2), this.off = (t, s2) => this.events.off(t, s2), this.removeListener = (t, s2) => this.events.removeListener(t, s2), this.removeAllListeners = (t) => this.events.removeAllListeners(t), this.connect = async (t) => {
      try {
        return await this.engine.connect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.approve = async (t) => {
      try {
        return await this.engine.approve(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.reject = async (t) => {
      try {
        return await this.engine.reject(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.update = async (t) => {
      try {
        return await this.engine.update(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.extend = async (t) => {
      try {
        return await this.engine.extend(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.request = async (t) => {
      try {
        return await this.engine.request(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.respond = async (t) => {
      try {
        return await this.engine.respond(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.ping = async (t) => {
      try {
        return await this.engine.ping(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.emit = async (t) => {
      try {
        return await this.engine.emit(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.disconnect = async (t) => {
      try {
        return await this.engine.disconnect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.find = (t) => {
      try {
        return this.engine.find(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.authenticate = async (t, s2) => {
      try {
        return await this.engine.authenticate(t, s2);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.formatAuthMessage = (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.approveSessionAuthenticate = async (t) => {
      try {
        return await this.engine.approveSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.rejectSessionAuthenticate = async (t) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.name = (o5 == null ? void 0 : o5.name) || we2.name, this.metadata = (o5 == null ? void 0 : o5.metadata) || es(), this.signConfig = o5 == null ? void 0 : o5.signConfig;
    const e2 = typeof (o5 == null ? void 0 : o5.logger) < "u" && typeof (o5 == null ? void 0 : o5.logger) != "string" ? o5.logger : (0, import_pino.default)(k({ level: (o5 == null ? void 0 : o5.logger) || we2.logger }));
    this.core = (o5 == null ? void 0 : o5.core) || new Pn(o5), this.logger = E(e2, this.name), this.session = new yt2(this.core, this.logger), this.proposal = new Rs2(this.core, this.logger), this.pendingRequest = new Ss2(this.core, this.logger), this.engine = new Es2(this), this.auth = new qs2(this.core, this.logger);
  }
  static async init(o5) {
    const e2 = new __e(o5);
    return await e2.initialize(), e2;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), this.engine.processRelayMessageCache();
    } catch (o5) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o5.message), o5;
    }
  }
};

// node_modules/@walletconnect/jsonrpc-http-connection/dist/index.es.js
var import_events9 = __toESM(require_events());
var import_cross_fetch = __toESM(require_browser_ponyfill());
var P2 = Object.defineProperty;
var w3 = Object.defineProperties;
var E3 = Object.getOwnPropertyDescriptors;
var c4 = Object.getOwnPropertySymbols;
var L2 = Object.prototype.hasOwnProperty;
var O3 = Object.prototype.propertyIsEnumerable;
var l3 = (r3, t, e2) => t in r3 ? P2(r3, t, { enumerable: true, configurable: true, writable: true, value: e2 }) : r3[t] = e2;
var p2 = (r3, t) => {
  for (var e2 in t || (t = {})) L2.call(t, e2) && l3(r3, e2, t[e2]);
  if (c4) for (var e2 of c4(t)) O3.call(t, e2) && l3(r3, e2, t[e2]);
  return r3;
};
var v3 = (r3, t) => w3(r3, E3(t));
var j3 = { Accept: "application/json", "Content-Type": "application/json" };
var T2 = "POST";
var d2 = { headers: j3, method: T2 };
var g2 = 10;
var f3 = class {
  constructor(t, e2 = false) {
    if (this.url = t, this.disableProviderPing = e2, this.events = new import_events9.EventEmitter(), this.isAvailable = false, this.registering = false, !isHttpUrl(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
    this.url = t, this.disableProviderPing = e2;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(t, e2) {
    this.events.on(t, e2);
  }
  once(t, e2) {
    this.events.once(t, e2);
  }
  off(t, e2) {
    this.events.off(t, e2);
  }
  removeListener(t, e2) {
    this.events.removeListener(t, e2);
  }
  async open(t = this.url) {
    await this.register(t);
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose();
  }
  async send(t) {
    this.isAvailable || await this.register();
    try {
      const e2 = safeJsonStringify(t), s2 = await (await (0, import_cross_fetch.default)(this.url, v3(p2({}, d2), { body: e2 }))).json();
      this.onPayload({ data: s2 });
    } catch (e2) {
      this.onError(t.id, e2);
    }
  }
  async register(t = this.url) {
    if (!isHttpUrl(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
    if (this.registering) {
      const e2 = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= e2 || this.events.listenerCount("open") >= e2) && this.events.setMaxListeners(e2 + 1), new Promise((s2, i3) => {
        this.events.once("register_error", (n4) => {
          this.resetMaxListeners(), i3(n4);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i3(new Error("HTTP connection is missing or invalid"));
          s2();
        });
      });
    }
    this.url = t, this.registering = true;
    try {
      if (!this.disableProviderPing) {
        const e2 = safeJsonStringify({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await (0, import_cross_fetch.default)(t, v3(p2({}, d2), { body: e2 }));
      }
      this.onOpen();
    } catch (e2) {
      const s2 = this.parseError(e2);
      throw this.events.emit("register_error", s2), this.onClose(), s2;
    }
  }
  onOpen() {
    this.isAvailable = true, this.registering = false, this.events.emit("open");
  }
  onClose() {
    this.isAvailable = false, this.registering = false, this.events.emit("close");
  }
  onPayload(t) {
    if (typeof t.data > "u") return;
    const e2 = typeof t.data == "string" ? safeJsonParse(t.data) : t.data;
    this.events.emit("payload", e2);
  }
  onError(t, e2) {
    const s2 = this.parseError(e2), i3 = s2.message || s2.toString(), n4 = formatJsonRpcError(t, i3);
    this.events.emit("payload", n4);
  }
  parseError(t, e2 = this.url) {
    return parseConnectionError(t, e2, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > g2 && this.events.setMaxListeners(g2);
  }
};

// node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events10 = __toESM(require_events());
var ya = "error";
var Kg = "wss://relay.walletconnect.com";
var Jg = "wc";
var Yg = "universal_provider";
var Sa = `${Jg}@2:${Yg}:`;
var Zg = "https://rpc.walletconnect.com/v1/";
var Kn = "generic";
var Tt2 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var _e3 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var Ui = { exports: {} };
(function(P3, s2) {
  (function() {
    var i3, p3 = "4.17.21", w4 = 200, x3 = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", O4 = "Expected a function", k3 = "Invalid `variable` option passed into `_.template`", tn2 = "__lodash_hash_undefined__", Jn = 500, xn = "__lodash_placeholder__", Ht2 = 1, Mt2 = 2, En2 = 4, yn2 = 1, me4 = 2, vt2 = 1, ln2 = 2, Gi = 4, Dt2 = 8, Sn2 = 16, Nt2 = 32, On = 64, Bt2 = 128, Yn = 256, gr3 = 512, Wa = 30, Ma = "...", Ba = 800, Ga = 16, zi = 1, za = 2, Ka = 3, pn2 = 1 / 0, nn2 = 9007199254740991, Ja = 17976931348623157e292, we3 = 0 / 0, $t2 = 4294967295, Ya = $t2 - 1, Za = $t2 >>> 1, Xa = [["ary", Bt2], ["bind", vt2], ["bindKey", ln2], ["curry", Dt2], ["curryRight", Sn2], ["flip", gr3], ["partial", Nt2], ["partialRight", On], ["rearg", Yn]], Rn = "[object Arguments]", Pe2 = "[object Array]", Qa = "[object AsyncFunction]", Zn = "[object Boolean]", Xn = "[object Date]", Va = "[object DOMException]", Ce3 = "[object Error]", Ae = "[object Function]", Ki = "[object GeneratorFunction]", Et2 = "[object Map]", Qn = "[object Number]", ka = "[object Null]", Gt2 = "[object Object]", Ji = "[object Promise]", ja = "[object Proxy]", Vn = "[object RegExp]", yt3 = "[object Set]", kn = "[object String]", Ie2 = "[object Symbol]", to = "[object Undefined]", jn = "[object WeakMap]", no = "[object WeakSet]", te2 = "[object ArrayBuffer]", bn2 = "[object DataView]", vr2 = "[object Float32Array]", _r2 = "[object Float64Array]", mr2 = "[object Int8Array]", wr2 = "[object Int16Array]", Pr2 = "[object Int32Array]", Cr2 = "[object Uint8Array]", Ar2 = "[object Uint8ClampedArray]", Ir3 = "[object Uint16Array]", xr2 = "[object Uint32Array]", eo = /\b__p \+= '';/g, ro = /\b(__p \+=) '' \+/g, io2 = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Yi2 = /&(?:amp|lt|gt|quot|#39);/g, Zi = /[&<>"']/g, so = RegExp(Yi2.source), uo = RegExp(Zi.source), ao = /<%-([\s\S]+?)%>/g, oo = /<%([\s\S]+?)%>/g, Xi = /<%=([\s\S]+?)%>/g, fo = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, co = /^\w*$/, ho = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Er2 = /[\\^$.*+?()[\]{}|]/g, lo = RegExp(Er2.source), yr2 = /^\s+/, po = /\s/, go = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, vo = /\{\n\/\* \[wrapped with (.+)\] \*/, _o2 = /,? & /, mo = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, wo = /[()=,{}\[\]\/\s]/, Po = /\\(\\)?/g, Co2 = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Qi = /\w*$/, Ao2 = /^[-+]0x[0-9a-f]+$/i, Io = /^0b[01]+$/i, xo = /^\[object .+?Constructor\]$/, Eo = /^0o[0-7]+$/i, yo = /^(?:0|[1-9]\d*)$/, So = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, xe2 = /($^)/, Oo = /['\n\r\u2028\u2029\\]/g, Ee2 = "\\ud800-\\udfff", Ro = "\\u0300-\\u036f", bo = "\\ufe20-\\ufe2f", To = "\\u20d0-\\u20ff", Vi = Ro + bo + To, ki = "\\u2700-\\u27bf", ji = "a-z\\xdf-\\xf6\\xf8-\\xff", Lo = "\\xac\\xb1\\xd7\\xf7", Ho = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Do = "\\u2000-\\u206f", No = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ts3 = "A-Z\\xc0-\\xd6\\xd8-\\xde", ns = "\\ufe0e\\ufe0f", es3 = Lo + Ho + Do + No, Sr3 = "[']", $o = "[" + Ee2 + "]", rs = "[" + es3 + "]", ye3 = "[" + Vi + "]", is2 = "\\d+", qo = "[" + ki + "]", ss3 = "[" + ji + "]", us = "[^" + Ee2 + es3 + is2 + ki + ji + ts3 + "]", Or2 = "\\ud83c[\\udffb-\\udfff]", Uo = "(?:" + ye3 + "|" + Or2 + ")", as2 = "[^" + Ee2 + "]", Rr2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", br2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", Tn2 = "[" + ts3 + "]", os = "\\u200d", fs3 = "(?:" + ss3 + "|" + us + ")", Fo = "(?:" + Tn2 + "|" + us + ")", cs = "(?:" + Sr3 + "(?:d|ll|m|re|s|t|ve))?", hs2 = "(?:" + Sr3 + "(?:D|LL|M|RE|S|T|VE))?", ls3 = Uo + "?", ps2 = "[" + ns + "]?", Wo = "(?:" + os + "(?:" + [as2, Rr2, br2].join("|") + ")" + ps2 + ls3 + ")*", Mo = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Bo2 = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", ds2 = ps2 + ls3 + Wo, Go = "(?:" + [qo, Rr2, br2].join("|") + ")" + ds2, zo = "(?:" + [as2 + ye3 + "?", ye3, Rr2, br2, $o].join("|") + ")", Ko = RegExp(Sr3, "g"), Jo = RegExp(ye3, "g"), Tr2 = RegExp(Or2 + "(?=" + Or2 + ")|" + zo + ds2, "g"), Yo = RegExp([Tn2 + "?" + ss3 + "+" + cs + "(?=" + [rs, Tn2, "$"].join("|") + ")", Fo + "+" + hs2 + "(?=" + [rs, Tn2 + fs3, "$"].join("|") + ")", Tn2 + "?" + fs3 + "+" + cs, Tn2 + "+" + hs2, Bo2, Mo, is2, Go].join("|"), "g"), Zo = RegExp("[" + os + Ee2 + Vi + ns + "]"), Xo = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Qo = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], Vo = -1, G = {};
    G[vr2] = G[_r2] = G[mr2] = G[wr2] = G[Pr2] = G[Cr2] = G[Ar2] = G[Ir3] = G[xr2] = true, G[Rn] = G[Pe2] = G[te2] = G[Zn] = G[bn2] = G[Xn] = G[Ce3] = G[Ae] = G[Et2] = G[Qn] = G[Gt2] = G[Vn] = G[yt3] = G[kn] = G[jn] = false;
    var B = {};
    B[Rn] = B[Pe2] = B[te2] = B[bn2] = B[Zn] = B[Xn] = B[vr2] = B[_r2] = B[mr2] = B[wr2] = B[Pr2] = B[Et2] = B[Qn] = B[Gt2] = B[Vn] = B[yt3] = B[kn] = B[Ie2] = B[Cr2] = B[Ar2] = B[Ir3] = B[xr2] = true, B[Ce3] = B[Ae] = B[jn] = false;
    var ko = { : "A", : "A", : "A", : "A", : "A", : "A", : "a", : "a", : "a", : "a", : "a", : "a", : "C", : "c", : "D", : "d", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "N", : "n", : "O", : "O", : "O", : "O", : "O", : "O", : "o", : "o", : "o", : "o", : "o", : "o", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "Y", : "y", : "y", : "Ae", : "ae", : "Th", : "th", : "ss", : "A", : "A", : "A", : "a", : "a", : "a", : "C", : "C", : "C", : "C", : "c", : "c", : "c", : "c", : "D", : "D", : "d", : "d", : "E", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "e", : "G", : "G", : "G", : "G", : "g", : "g", : "g", : "g", : "H", : "H", : "h", : "h", : "I", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "i", : "J", : "j", : "K", : "k", : "k", : "L", : "L", : "L", : "L", : "L", : "l", : "l", : "l", : "l", : "l", : "N", : "N", : "N", : "N", : "n", : "n", : "n", : "n", : "O", : "O", : "O", : "o", : "o", : "o", : "R", : "R", : "R", : "r", : "r", : "r", : "S", : "S", : "S", : "S", : "s", : "s", : "s", : "s", : "T", : "T", : "T", : "t", : "t", : "t", : "U", : "U", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "u", : "u", : "W", : "w", : "Y", : "y", : "Y", : "Z", : "Z", : "Z", : "z", : "z", : "z", : "IJ", : "ij", : "Oe", : "oe", : "'n", : "s" }, jo = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, tf = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, nf = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, ef = parseFloat, rf = parseInt, gs3 = typeof _e3 == "object" && _e3 && _e3.Object === Object && _e3, sf = typeof self == "object" && self && self.Object === Object && self, j4 = gs3 || sf || Function("return this")(), Lr2 = s2 && !s2.nodeType && s2, dn2 = Lr2 && true && P3 && !P3.nodeType && P3, vs4 = dn2 && dn2.exports === Lr2, Hr2 = vs4 && gs3.process, _t2 = function() {
      try {
        var h4 = dn2 && dn2.require && dn2.require("util").types;
        return h4 || Hr2 && Hr2.binding && Hr2.binding("util");
      } catch {
      }
    }(), _s3 = _t2 && _t2.isArrayBuffer, ms4 = _t2 && _t2.isDate, ws4 = _t2 && _t2.isMap, Ps2 = _t2 && _t2.isRegExp, Cs2 = _t2 && _t2.isSet, As3 = _t2 && _t2.isTypedArray;
    function ct3(h4, g3, d3) {
      switch (d3.length) {
        case 0:
          return h4.call(g3);
        case 1:
          return h4.call(g3, d3[0]);
        case 2:
          return h4.call(g3, d3[0], d3[1]);
        case 3:
          return h4.call(g3, d3[0], d3[1], d3[2]);
      }
      return h4.apply(g3, d3);
    }
    function uf(h4, g3, d3, A3) {
      for (var R2 = -1, q2 = h4 == null ? 0 : h4.length; ++R2 < q2; ) {
        var X2 = h4[R2];
        g3(A3, X2, d3(X2), h4);
      }
      return A3;
    }
    function mt2(h4, g3) {
      for (var d3 = -1, A3 = h4 == null ? 0 : h4.length; ++d3 < A3 && g3(h4[d3], d3, h4) !== false; ) ;
      return h4;
    }
    function af(h4, g3) {
      for (var d3 = h4 == null ? 0 : h4.length; d3-- && g3(h4[d3], d3, h4) !== false; ) ;
      return h4;
    }
    function Is3(h4, g3) {
      for (var d3 = -1, A3 = h4 == null ? 0 : h4.length; ++d3 < A3; ) if (!g3(h4[d3], d3, h4)) return false;
      return true;
    }
    function en2(h4, g3) {
      for (var d3 = -1, A3 = h4 == null ? 0 : h4.length, R2 = 0, q2 = []; ++d3 < A3; ) {
        var X2 = h4[d3];
        g3(X2, d3, h4) && (q2[R2++] = X2);
      }
      return q2;
    }
    function Se2(h4, g3) {
      var d3 = h4 == null ? 0 : h4.length;
      return !!d3 && Ln(h4, g3, 0) > -1;
    }
    function Dr2(h4, g3, d3) {
      for (var A3 = -1, R2 = h4 == null ? 0 : h4.length; ++A3 < R2; ) if (d3(g3, h4[A3])) return true;
      return false;
    }
    function z4(h4, g3) {
      for (var d3 = -1, A3 = h4 == null ? 0 : h4.length, R2 = Array(A3); ++d3 < A3; ) R2[d3] = g3(h4[d3], d3, h4);
      return R2;
    }
    function rn2(h4, g3) {
      for (var d3 = -1, A3 = g3.length, R2 = h4.length; ++d3 < A3; ) h4[R2 + d3] = g3[d3];
      return h4;
    }
    function Nr2(h4, g3, d3, A3) {
      var R2 = -1, q2 = h4 == null ? 0 : h4.length;
      for (A3 && q2 && (d3 = h4[++R2]); ++R2 < q2; ) d3 = g3(d3, h4[R2], R2, h4);
      return d3;
    }
    function of(h4, g3, d3, A3) {
      var R2 = h4 == null ? 0 : h4.length;
      for (A3 && R2 && (d3 = h4[--R2]); R2--; ) d3 = g3(d3, h4[R2], R2, h4);
      return d3;
    }
    function $r2(h4, g3) {
      for (var d3 = -1, A3 = h4 == null ? 0 : h4.length; ++d3 < A3; ) if (g3(h4[d3], d3, h4)) return true;
      return false;
    }
    var ff = qr2("length");
    function cf(h4) {
      return h4.split("");
    }
    function hf(h4) {
      return h4.match(mo) || [];
    }
    function xs3(h4, g3, d3) {
      var A3;
      return d3(h4, function(R2, q2, X2) {
        if (g3(R2, q2, X2)) return A3 = q2, false;
      }), A3;
    }
    function Oe(h4, g3, d3, A3) {
      for (var R2 = h4.length, q2 = d3 + (A3 ? 1 : -1); A3 ? q2-- : ++q2 < R2; ) if (g3(h4[q2], q2, h4)) return q2;
      return -1;
    }
    function Ln(h4, g3, d3) {
      return g3 === g3 ? If(h4, g3, d3) : Oe(h4, Es3, d3);
    }
    function lf(h4, g3, d3, A3) {
      for (var R2 = d3 - 1, q2 = h4.length; ++R2 < q2; ) if (A3(h4[R2], g3)) return R2;
      return -1;
    }
    function Es3(h4) {
      return h4 !== h4;
    }
    function ys4(h4, g3) {
      var d3 = h4 == null ? 0 : h4.length;
      return d3 ? Fr2(h4, g3) / d3 : we3;
    }
    function qr2(h4) {
      return function(g3) {
        return g3 == null ? i3 : g3[h4];
      };
    }
    function Ur(h4) {
      return function(g3) {
        return h4 == null ? i3 : h4[g3];
      };
    }
    function Ss3(h4, g3, d3, A3, R2) {
      return R2(h4, function(q2, X2, M2) {
        d3 = A3 ? (A3 = false, q2) : g3(d3, q2, X2, M2);
      }), d3;
    }
    function pf(h4, g3) {
      var d3 = h4.length;
      for (h4.sort(g3); d3--; ) h4[d3] = h4[d3].value;
      return h4;
    }
    function Fr2(h4, g3) {
      for (var d3, A3 = -1, R2 = h4.length; ++A3 < R2; ) {
        var q2 = g3(h4[A3]);
        q2 !== i3 && (d3 = d3 === i3 ? q2 : d3 + q2);
      }
      return d3;
    }
    function Wr3(h4, g3) {
      for (var d3 = -1, A3 = Array(h4); ++d3 < h4; ) A3[d3] = g3(d3);
      return A3;
    }
    function df(h4, g3) {
      return z4(g3, function(d3) {
        return [d3, h4[d3]];
      });
    }
    function Os2(h4) {
      return h4 && h4.slice(0, Ls2(h4) + 1).replace(yr2, "");
    }
    function ht3(h4) {
      return function(g3) {
        return h4(g3);
      };
    }
    function Mr2(h4, g3) {
      return z4(g3, function(d3) {
        return h4[d3];
      });
    }
    function ne2(h4, g3) {
      return h4.has(g3);
    }
    function Rs3(h4, g3) {
      for (var d3 = -1, A3 = h4.length; ++d3 < A3 && Ln(g3, h4[d3], 0) > -1; ) ;
      return d3;
    }
    function bs3(h4, g3) {
      for (var d3 = h4.length; d3-- && Ln(g3, h4[d3], 0) > -1; ) ;
      return d3;
    }
    function gf(h4, g3) {
      for (var d3 = h4.length, A3 = 0; d3--; ) h4[d3] === g3 && ++A3;
      return A3;
    }
    var vf = Ur(ko), _f = Ur(jo);
    function mf(h4) {
      return "\\" + nf[h4];
    }
    function wf(h4, g3) {
      return h4 == null ? i3 : h4[g3];
    }
    function Hn(h4) {
      return Zo.test(h4);
    }
    function Pf(h4) {
      return Xo.test(h4);
    }
    function Cf(h4) {
      for (var g3, d3 = []; !(g3 = h4.next()).done; ) d3.push(g3.value);
      return d3;
    }
    function Br(h4) {
      var g3 = -1, d3 = Array(h4.size);
      return h4.forEach(function(A3, R2) {
        d3[++g3] = [R2, A3];
      }), d3;
    }
    function Ts2(h4, g3) {
      return function(d3) {
        return h4(g3(d3));
      };
    }
    function sn2(h4, g3) {
      for (var d3 = -1, A3 = h4.length, R2 = 0, q2 = []; ++d3 < A3; ) {
        var X2 = h4[d3];
        (X2 === g3 || X2 === xn) && (h4[d3] = xn, q2[R2++] = d3);
      }
      return q2;
    }
    function Re(h4) {
      var g3 = -1, d3 = Array(h4.size);
      return h4.forEach(function(A3) {
        d3[++g3] = A3;
      }), d3;
    }
    function Af(h4) {
      var g3 = -1, d3 = Array(h4.size);
      return h4.forEach(function(A3) {
        d3[++g3] = [A3, A3];
      }), d3;
    }
    function If(h4, g3, d3) {
      for (var A3 = d3 - 1, R2 = h4.length; ++A3 < R2; ) if (h4[A3] === g3) return A3;
      return -1;
    }
    function xf(h4, g3, d3) {
      for (var A3 = d3 + 1; A3--; ) if (h4[A3] === g3) return A3;
      return A3;
    }
    function Dn2(h4) {
      return Hn(h4) ? yf(h4) : ff(h4);
    }
    function St2(h4) {
      return Hn(h4) ? Sf(h4) : cf(h4);
    }
    function Ls2(h4) {
      for (var g3 = h4.length; g3-- && po.test(h4.charAt(g3)); ) ;
      return g3;
    }
    var Ef = Ur(tf);
    function yf(h4) {
      for (var g3 = Tr2.lastIndex = 0; Tr2.test(h4); ) ++g3;
      return g3;
    }
    function Sf(h4) {
      return h4.match(Tr2) || [];
    }
    function Of(h4) {
      return h4.match(Yo) || [];
    }
    var Rf = function h4(g3) {
      g3 = g3 == null ? j4 : Nn.defaults(j4.Object(), g3, Nn.pick(j4, Qo));
      var d3 = g3.Array, A3 = g3.Date, R2 = g3.Error, q2 = g3.Function, X2 = g3.Math, M2 = g3.Object, Gr = g3.RegExp, bf = g3.String, wt2 = g3.TypeError, be3 = d3.prototype, Tf = q2.prototype, $n = M2.prototype, Te2 = g3["__core-js_shared__"], Le2 = Tf.toString, W2 = $n.hasOwnProperty, Lf = 0, Hs2 = function() {
        var t = /[^.]+$/.exec(Te2 && Te2.keys && Te2.keys.IE_PROTO || "");
        return t ? "Symbol(src)_1." + t : "";
      }(), He = $n.toString, Hf = Le2.call(M2), Df = j4._, Nf = Gr("^" + Le2.call(W2).replace(Er2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), De3 = vs4 ? g3.Buffer : i3, un2 = g3.Symbol, Ne = g3.Uint8Array, Ds2 = De3 ? De3.allocUnsafe : i3, $e2 = Ts2(M2.getPrototypeOf, M2), Ns2 = M2.create, $s2 = $n.propertyIsEnumerable, qe = be3.splice, qs3 = un2 ? un2.isConcatSpreadable : i3, ee2 = un2 ? un2.iterator : i3, gn2 = un2 ? un2.toStringTag : i3, Ue2 = function() {
        try {
          var t = Pn2(M2, "defineProperty");
          return t({}, "", {}), t;
        } catch {
        }
      }(), $f = g3.clearTimeout !== j4.clearTimeout && g3.clearTimeout, qf = A3 && A3.now !== j4.Date.now && A3.now, Uf = g3.setTimeout !== j4.setTimeout && g3.setTimeout, Fe = X2.ceil, We2 = X2.floor, zr2 = M2.getOwnPropertySymbols, Ff = De3 ? De3.isBuffer : i3, Us2 = g3.isFinite, Wf = be3.join, Mf = Ts2(M2.keys, M2), Q2 = X2.max, nt3 = X2.min, Bf = A3.now, Gf = g3.parseInt, Fs2 = X2.random, zf = be3.reverse, Kr = Pn2(g3, "DataView"), re2 = Pn2(g3, "Map"), Jr2 = Pn2(g3, "Promise"), qn = Pn2(g3, "Set"), ie = Pn2(g3, "WeakMap"), se = Pn2(M2, "create"), Me = ie && new ie(), Un = {}, Kf = Cn2(Kr), Jf2 = Cn2(re2), Yf = Cn2(Jr2), Zf = Cn2(qn), Xf = Cn2(ie), Be = un2 ? un2.prototype : i3, ue = Be ? Be.valueOf : i3, Ws2 = Be ? Be.toString : i3;
      function a4(t) {
        if (J(t) && !b3(t) && !(t instanceof N2)) {
          if (t instanceof Pt2) return t;
          if (W2.call(t, "__wrapped__")) return Mu2(t);
        }
        return new Pt2(t);
      }
      var Fn = /* @__PURE__ */ function() {
        function t() {
        }
        return function(n4) {
          if (!K3(n4)) return {};
          if (Ns2) return Ns2(n4);
          t.prototype = n4;
          var e2 = new t();
          return t.prototype = i3, e2;
        };
      }();
      function Ge() {
      }
      function Pt2(t, n4) {
        this.__wrapped__ = t, this.__actions__ = [], this.__chain__ = !!n4, this.__index__ = 0, this.__values__ = i3;
      }
      a4.templateSettings = { escape: ao, evaluate: oo, interpolate: Xi, variable: "", imports: { _: a4 } }, a4.prototype = Ge.prototype, a4.prototype.constructor = a4, Pt2.prototype = Fn(Ge.prototype), Pt2.prototype.constructor = Pt2;
      function N2(t) {
        this.__wrapped__ = t, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = $t2, this.__views__ = [];
      }
      function Qf() {
        var t = new N2(this.__wrapped__);
        return t.__actions__ = ut3(this.__actions__), t.__dir__ = this.__dir__, t.__filtered__ = this.__filtered__, t.__iteratees__ = ut3(this.__iteratees__), t.__takeCount__ = this.__takeCount__, t.__views__ = ut3(this.__views__), t;
      }
      function Vf() {
        if (this.__filtered__) {
          var t = new N2(this);
          t.__dir__ = -1, t.__filtered__ = true;
        } else t = this.clone(), t.__dir__ *= -1;
        return t;
      }
      function kf() {
        var t = this.__wrapped__.value(), n4 = this.__dir__, e2 = b3(t), r3 = n4 < 0, u3 = e2 ? t.length : 0, o5 = ch2(0, u3, this.__views__), f4 = o5.start, c5 = o5.end, l4 = c5 - f4, v4 = r3 ? c5 : f4 - 1, _2 = this.__iteratees__, m2 = _2.length, C2 = 0, I3 = nt3(l4, this.__takeCount__);
        if (!e2 || !r3 && u3 == l4 && I3 == l4) return cu2(t, this.__actions__);
        var y6 = [];
        t: for (; l4-- && C2 < I3; ) {
          v4 += n4;
          for (var L3 = -1, S3 = t[v4]; ++L3 < m2; ) {
            var D2 = _2[L3], $3 = D2.iteratee, dt3 = D2.type, st3 = $3(S3);
            if (dt3 == za) S3 = st3;
            else if (!st3) {
              if (dt3 == zi) continue t;
              break t;
            }
          }
          y6[C2++] = S3;
        }
        return y6;
      }
      N2.prototype = Fn(Ge.prototype), N2.prototype.constructor = N2;
      function vn2(t) {
        var n4 = -1, e2 = t == null ? 0 : t.length;
        for (this.clear(); ++n4 < e2; ) {
          var r3 = t[n4];
          this.set(r3[0], r3[1]);
        }
      }
      function jf() {
        this.__data__ = se ? se(null) : {}, this.size = 0;
      }
      function tc(t) {
        var n4 = this.has(t) && delete this.__data__[t];
        return this.size -= n4 ? 1 : 0, n4;
      }
      function nc(t) {
        var n4 = this.__data__;
        if (se) {
          var e2 = n4[t];
          return e2 === tn2 ? i3 : e2;
        }
        return W2.call(n4, t) ? n4[t] : i3;
      }
      function ec(t) {
        var n4 = this.__data__;
        return se ? n4[t] !== i3 : W2.call(n4, t);
      }
      function rc(t, n4) {
        var e2 = this.__data__;
        return this.size += this.has(t) ? 0 : 1, e2[t] = se && n4 === i3 ? tn2 : n4, this;
      }
      vn2.prototype.clear = jf, vn2.prototype.delete = tc, vn2.prototype.get = nc, vn2.prototype.has = ec, vn2.prototype.set = rc;
      function zt2(t) {
        var n4 = -1, e2 = t == null ? 0 : t.length;
        for (this.clear(); ++n4 < e2; ) {
          var r3 = t[n4];
          this.set(r3[0], r3[1]);
        }
      }
      function ic() {
        this.__data__ = [], this.size = 0;
      }
      function sc(t) {
        var n4 = this.__data__, e2 = ze(n4, t);
        if (e2 < 0) return false;
        var r3 = n4.length - 1;
        return e2 == r3 ? n4.pop() : qe.call(n4, e2, 1), --this.size, true;
      }
      function uc(t) {
        var n4 = this.__data__, e2 = ze(n4, t);
        return e2 < 0 ? i3 : n4[e2][1];
      }
      function ac(t) {
        return ze(this.__data__, t) > -1;
      }
      function oc(t, n4) {
        var e2 = this.__data__, r3 = ze(e2, t);
        return r3 < 0 ? (++this.size, e2.push([t, n4])) : e2[r3][1] = n4, this;
      }
      zt2.prototype.clear = ic, zt2.prototype.delete = sc, zt2.prototype.get = uc, zt2.prototype.has = ac, zt2.prototype.set = oc;
      function Kt2(t) {
        var n4 = -1, e2 = t == null ? 0 : t.length;
        for (this.clear(); ++n4 < e2; ) {
          var r3 = t[n4];
          this.set(r3[0], r3[1]);
        }
      }
      function fc() {
        this.size = 0, this.__data__ = { hash: new vn2(), map: new (re2 || zt2)(), string: new vn2() };
      }
      function cc(t) {
        var n4 = er3(this, t).delete(t);
        return this.size -= n4 ? 1 : 0, n4;
      }
      function hc(t) {
        return er3(this, t).get(t);
      }
      function lc(t) {
        return er3(this, t).has(t);
      }
      function pc(t, n4) {
        var e2 = er3(this, t), r3 = e2.size;
        return e2.set(t, n4), this.size += e2.size == r3 ? 0 : 1, this;
      }
      Kt2.prototype.clear = fc, Kt2.prototype.delete = cc, Kt2.prototype.get = hc, Kt2.prototype.has = lc, Kt2.prototype.set = pc;
      function _n2(t) {
        var n4 = -1, e2 = t == null ? 0 : t.length;
        for (this.__data__ = new Kt2(); ++n4 < e2; ) this.add(t[n4]);
      }
      function dc(t) {
        return this.__data__.set(t, tn2), this;
      }
      function gc(t) {
        return this.__data__.has(t);
      }
      _n2.prototype.add = _n2.prototype.push = dc, _n2.prototype.has = gc;
      function Ot2(t) {
        var n4 = this.__data__ = new zt2(t);
        this.size = n4.size;
      }
      function vc() {
        this.__data__ = new zt2(), this.size = 0;
      }
      function _c(t) {
        var n4 = this.__data__, e2 = n4.delete(t);
        return this.size = n4.size, e2;
      }
      function mc(t) {
        return this.__data__.get(t);
      }
      function wc(t) {
        return this.__data__.has(t);
      }
      function Pc(t, n4) {
        var e2 = this.__data__;
        if (e2 instanceof zt2) {
          var r3 = e2.__data__;
          if (!re2 || r3.length < w4 - 1) return r3.push([t, n4]), this.size = ++e2.size, this;
          e2 = this.__data__ = new Kt2(r3);
        }
        return e2.set(t, n4), this.size = e2.size, this;
      }
      Ot2.prototype.clear = vc, Ot2.prototype.delete = _c, Ot2.prototype.get = mc, Ot2.prototype.has = wc, Ot2.prototype.set = Pc;
      function Ms3(t, n4) {
        var e2 = b3(t), r3 = !e2 && An(t), u3 = !e2 && !r3 && hn2(t), o5 = !e2 && !r3 && !u3 && Gn(t), f4 = e2 || r3 || u3 || o5, c5 = f4 ? Wr3(t.length, bf) : [], l4 = c5.length;
        for (var v4 in t) (n4 || W2.call(t, v4)) && !(f4 && (v4 == "length" || u3 && (v4 == "offset" || v4 == "parent") || o5 && (v4 == "buffer" || v4 == "byteLength" || v4 == "byteOffset") || Xt2(v4, l4))) && c5.push(v4);
        return c5;
      }
      function Bs2(t) {
        var n4 = t.length;
        return n4 ? t[ri2(0, n4 - 1)] : i3;
      }
      function Cc(t, n4) {
        return rr3(ut3(t), mn3(n4, 0, t.length));
      }
      function Ac(t) {
        return rr3(ut3(t));
      }
      function Yr2(t, n4, e2) {
        (e2 !== i3 && !Rt2(t[n4], e2) || e2 === i3 && !(n4 in t)) && Jt2(t, n4, e2);
      }
      function ae3(t, n4, e2) {
        var r3 = t[n4];
        (!(W2.call(t, n4) && Rt2(r3, e2)) || e2 === i3 && !(n4 in t)) && Jt2(t, n4, e2);
      }
      function ze(t, n4) {
        for (var e2 = t.length; e2--; ) if (Rt2(t[e2][0], n4)) return e2;
        return -1;
      }
      function Ic(t, n4, e2, r3) {
        return an2(t, function(u3, o5, f4) {
          n4(r3, u3, e2(u3), f4);
        }), r3;
      }
      function Gs2(t, n4) {
        return t && Ut2(n4, V3(n4), t);
      }
      function xc(t, n4) {
        return t && Ut2(n4, ot3(n4), t);
      }
      function Jt2(t, n4, e2) {
        n4 == "__proto__" && Ue2 ? Ue2(t, n4, { configurable: true, enumerable: true, value: e2, writable: true }) : t[n4] = e2;
      }
      function Zr2(t, n4) {
        for (var e2 = -1, r3 = n4.length, u3 = d3(r3), o5 = t == null; ++e2 < r3; ) u3[e2] = o5 ? i3 : Oi(t, n4[e2]);
        return u3;
      }
      function mn3(t, n4, e2) {
        return t === t && (e2 !== i3 && (t = t <= e2 ? t : e2), n4 !== i3 && (t = t >= n4 ? t : n4)), t;
      }
      function Ct2(t, n4, e2, r3, u3, o5) {
        var f4, c5 = n4 & Ht2, l4 = n4 & Mt2, v4 = n4 & En2;
        if (e2 && (f4 = u3 ? e2(t, r3, u3, o5) : e2(t)), f4 !== i3) return f4;
        if (!K3(t)) return t;
        var _2 = b3(t);
        if (_2) {
          if (f4 = lh2(t), !c5) return ut3(t, f4);
        } else {
          var m2 = et3(t), C2 = m2 == Ae || m2 == Ki;
          if (hn2(t)) return pu(t, c5);
          if (m2 == Gt2 || m2 == Rn || C2 && !u3) {
            if (f4 = l4 || C2 ? {} : Lu(t), !c5) return l4 ? nh2(t, xc(f4, t)) : th(t, Gs2(f4, t));
          } else {
            if (!B[m2]) return u3 ? t : {};
            f4 = ph2(t, m2, c5);
          }
        }
        o5 || (o5 = new Ot2());
        var I3 = o5.get(t);
        if (I3) return I3;
        o5.set(t, f4), aa(t) ? t.forEach(function(S3) {
          f4.add(Ct2(S3, n4, e2, S3, t, o5));
        }) : sa(t) && t.forEach(function(S3, D2) {
          f4.set(D2, Ct2(S3, n4, e2, D2, t, o5));
        });
        var y6 = v4 ? l4 ? di2 : pi2 : l4 ? ot3 : V3, L3 = _2 ? i3 : y6(t);
        return mt2(L3 || t, function(S3, D2) {
          L3 && (D2 = S3, S3 = t[D2]), ae3(f4, D2, Ct2(S3, n4, e2, D2, t, o5));
        }), f4;
      }
      function Ec(t) {
        var n4 = V3(t);
        return function(e2) {
          return zs2(e2, t, n4);
        };
      }
      function zs2(t, n4, e2) {
        var r3 = e2.length;
        if (t == null) return !r3;
        for (t = M2(t); r3--; ) {
          var u3 = e2[r3], o5 = n4[u3], f4 = t[u3];
          if (f4 === i3 && !(u3 in t) || !o5(f4)) return false;
        }
        return true;
      }
      function Ks2(t, n4, e2) {
        if (typeof t != "function") throw new wt2(O4);
        return de(function() {
          t.apply(i3, e2);
        }, n4);
      }
      function oe3(t, n4, e2, r3) {
        var u3 = -1, o5 = Se2, f4 = true, c5 = t.length, l4 = [], v4 = n4.length;
        if (!c5) return l4;
        e2 && (n4 = z4(n4, ht3(e2))), r3 ? (o5 = Dr2, f4 = false) : n4.length >= w4 && (o5 = ne2, f4 = false, n4 = new _n2(n4));
        t: for (; ++u3 < c5; ) {
          var _2 = t[u3], m2 = e2 == null ? _2 : e2(_2);
          if (_2 = r3 || _2 !== 0 ? _2 : 0, f4 && m2 === m2) {
            for (var C2 = v4; C2--; ) if (n4[C2] === m2) continue t;
            l4.push(_2);
          } else o5(n4, m2, r3) || l4.push(_2);
        }
        return l4;
      }
      var an2 = mu2(qt2), Js2 = mu2(Qr2, true);
      function yc(t, n4) {
        var e2 = true;
        return an2(t, function(r3, u3, o5) {
          return e2 = !!n4(r3, u3, o5), e2;
        }), e2;
      }
      function Ke2(t, n4, e2) {
        for (var r3 = -1, u3 = t.length; ++r3 < u3; ) {
          var o5 = t[r3], f4 = n4(o5);
          if (f4 != null && (c5 === i3 ? f4 === f4 && !pt3(f4) : e2(f4, c5))) var c5 = f4, l4 = o5;
        }
        return l4;
      }
      function Sc(t, n4, e2, r3) {
        var u3 = t.length;
        for (e2 = T3(e2), e2 < 0 && (e2 = -e2 > u3 ? 0 : u3 + e2), r3 = r3 === i3 || r3 > u3 ? u3 : T3(r3), r3 < 0 && (r3 += u3), r3 = e2 > r3 ? 0 : fa(r3); e2 < r3; ) t[e2++] = n4;
        return t;
      }
      function Ys2(t, n4) {
        var e2 = [];
        return an2(t, function(r3, u3, o5) {
          n4(r3, u3, o5) && e2.push(r3);
        }), e2;
      }
      function tt3(t, n4, e2, r3, u3) {
        var o5 = -1, f4 = t.length;
        for (e2 || (e2 = gh2), u3 || (u3 = []); ++o5 < f4; ) {
          var c5 = t[o5];
          n4 > 0 && e2(c5) ? n4 > 1 ? tt3(c5, n4 - 1, e2, r3, u3) : rn2(u3, c5) : r3 || (u3[u3.length] = c5);
        }
        return u3;
      }
      var Xr3 = wu2(), Zs2 = wu2(true);
      function qt2(t, n4) {
        return t && Xr3(t, n4, V3);
      }
      function Qr2(t, n4) {
        return t && Zs2(t, n4, V3);
      }
      function Je2(t, n4) {
        return en2(n4, function(e2) {
          return Qt2(t[e2]);
        });
      }
      function wn2(t, n4) {
        n4 = fn3(n4, t);
        for (var e2 = 0, r3 = n4.length; t != null && e2 < r3; ) t = t[Ft2(n4[e2++])];
        return e2 && e2 == r3 ? t : i3;
      }
      function Xs2(t, n4, e2) {
        var r3 = n4(t);
        return b3(t) ? r3 : rn2(r3, e2(t));
      }
      function rt3(t) {
        return t == null ? t === i3 ? to : ka : gn2 && gn2 in M2(t) ? fh2(t) : Ah2(t);
      }
      function Vr2(t, n4) {
        return t > n4;
      }
      function Oc(t, n4) {
        return t != null && W2.call(t, n4);
      }
      function Rc(t, n4) {
        return t != null && n4 in M2(t);
      }
      function bc(t, n4, e2) {
        return t >= nt3(n4, e2) && t < Q2(n4, e2);
      }
      function kr2(t, n4, e2) {
        for (var r3 = e2 ? Dr2 : Se2, u3 = t[0].length, o5 = t.length, f4 = o5, c5 = d3(o5), l4 = 1 / 0, v4 = []; f4--; ) {
          var _2 = t[f4];
          f4 && n4 && (_2 = z4(_2, ht3(n4))), l4 = nt3(_2.length, l4), c5[f4] = !e2 && (n4 || u3 >= 120 && _2.length >= 120) ? new _n2(f4 && _2) : i3;
        }
        _2 = t[0];
        var m2 = -1, C2 = c5[0];
        t: for (; ++m2 < u3 && v4.length < l4; ) {
          var I3 = _2[m2], y6 = n4 ? n4(I3) : I3;
          if (I3 = e2 || I3 !== 0 ? I3 : 0, !(C2 ? ne2(C2, y6) : r3(v4, y6, e2))) {
            for (f4 = o5; --f4; ) {
              var L3 = c5[f4];
              if (!(L3 ? ne2(L3, y6) : r3(t[f4], y6, e2))) continue t;
            }
            C2 && C2.push(y6), v4.push(I3);
          }
        }
        return v4;
      }
      function Tc(t, n4, e2, r3) {
        return qt2(t, function(u3, o5, f4) {
          n4(r3, e2(u3), o5, f4);
        }), r3;
      }
      function fe2(t, n4, e2) {
        n4 = fn3(n4, t), t = $u(t, n4);
        var r3 = t == null ? t : t[Ft2(It2(n4))];
        return r3 == null ? i3 : ct3(r3, t, e2);
      }
      function Qs2(t) {
        return J(t) && rt3(t) == Rn;
      }
      function Lc(t) {
        return J(t) && rt3(t) == te2;
      }
      function Hc(t) {
        return J(t) && rt3(t) == Xn;
      }
      function ce(t, n4, e2, r3, u3) {
        return t === n4 ? true : t == null || n4 == null || !J(t) && !J(n4) ? t !== t && n4 !== n4 : Dc(t, n4, e2, r3, ce, u3);
      }
      function Dc(t, n4, e2, r3, u3, o5) {
        var f4 = b3(t), c5 = b3(n4), l4 = f4 ? Pe2 : et3(t), v4 = c5 ? Pe2 : et3(n4);
        l4 = l4 == Rn ? Gt2 : l4, v4 = v4 == Rn ? Gt2 : v4;
        var _2 = l4 == Gt2, m2 = v4 == Gt2, C2 = l4 == v4;
        if (C2 && hn2(t)) {
          if (!hn2(n4)) return false;
          f4 = true, _2 = false;
        }
        if (C2 && !_2) return o5 || (o5 = new Ot2()), f4 || Gn(t) ? Ru2(t, n4, e2, r3, u3, o5) : ah2(t, n4, l4, e2, r3, u3, o5);
        if (!(e2 & yn2)) {
          var I3 = _2 && W2.call(t, "__wrapped__"), y6 = m2 && W2.call(n4, "__wrapped__");
          if (I3 || y6) {
            var L3 = I3 ? t.value() : t, S3 = y6 ? n4.value() : n4;
            return o5 || (o5 = new Ot2()), u3(L3, S3, e2, r3, o5);
          }
        }
        return C2 ? (o5 || (o5 = new Ot2()), oh2(t, n4, e2, r3, u3, o5)) : false;
      }
      function Nc(t) {
        return J(t) && et3(t) == Et2;
      }
      function jr(t, n4, e2, r3) {
        var u3 = e2.length, o5 = u3, f4 = !r3;
        if (t == null) return !o5;
        for (t = M2(t); u3--; ) {
          var c5 = e2[u3];
          if (f4 && c5[2] ? c5[1] !== t[c5[0]] : !(c5[0] in t)) return false;
        }
        for (; ++u3 < o5; ) {
          c5 = e2[u3];
          var l4 = c5[0], v4 = t[l4], _2 = c5[1];
          if (f4 && c5[2]) {
            if (v4 === i3 && !(l4 in t)) return false;
          } else {
            var m2 = new Ot2();
            if (r3) var C2 = r3(v4, _2, l4, t, n4, m2);
            if (!(C2 === i3 ? ce(_2, v4, yn2 | me4, r3, m2) : C2)) return false;
          }
        }
        return true;
      }
      function Vs2(t) {
        if (!K3(t) || _h(t)) return false;
        var n4 = Qt2(t) ? Nf : xo;
        return n4.test(Cn2(t));
      }
      function $c(t) {
        return J(t) && rt3(t) == Vn;
      }
      function qc(t) {
        return J(t) && et3(t) == yt3;
      }
      function Uc(t) {
        return J(t) && fr2(t.length) && !!G[rt3(t)];
      }
      function ks2(t) {
        return typeof t == "function" ? t : t == null ? ft2 : typeof t == "object" ? b3(t) ? nu(t[0], t[1]) : tu(t) : Pa(t);
      }
      function ti2(t) {
        if (!pe(t)) return Mf(t);
        var n4 = [];
        for (var e2 in M2(t)) W2.call(t, e2) && e2 != "constructor" && n4.push(e2);
        return n4;
      }
      function Fc(t) {
        if (!K3(t)) return Ch(t);
        var n4 = pe(t), e2 = [];
        for (var r3 in t) r3 == "constructor" && (n4 || !W2.call(t, r3)) || e2.push(r3);
        return e2;
      }
      function ni2(t, n4) {
        return t < n4;
      }
      function js2(t, n4) {
        var e2 = -1, r3 = at3(t) ? d3(t.length) : [];
        return an2(t, function(u3, o5, f4) {
          r3[++e2] = n4(u3, o5, f4);
        }), r3;
      }
      function tu(t) {
        var n4 = vi(t);
        return n4.length == 1 && n4[0][2] ? Du2(n4[0][0], n4[0][1]) : function(e2) {
          return e2 === t || jr(e2, t, n4);
        };
      }
      function nu(t, n4) {
        return mi2(t) && Hu(n4) ? Du2(Ft2(t), n4) : function(e2) {
          var r3 = Oi(e2, t);
          return r3 === i3 && r3 === n4 ? Ri(e2, t) : ce(n4, r3, yn2 | me4);
        };
      }
      function Ye2(t, n4, e2, r3, u3) {
        t !== n4 && Xr3(n4, function(o5, f4) {
          if (u3 || (u3 = new Ot2()), K3(o5)) Wc(t, n4, f4, e2, Ye2, r3, u3);
          else {
            var c5 = r3 ? r3(Pi(t, f4), o5, f4 + "", t, n4, u3) : i3;
            c5 === i3 && (c5 = o5), Yr2(t, f4, c5);
          }
        }, ot3);
      }
      function Wc(t, n4, e2, r3, u3, o5, f4) {
        var c5 = Pi(t, e2), l4 = Pi(n4, e2), v4 = f4.get(l4);
        if (v4) {
          Yr2(t, e2, v4);
          return;
        }
        var _2 = o5 ? o5(c5, l4, e2 + "", t, n4, f4) : i3, m2 = _2 === i3;
        if (m2) {
          var C2 = b3(l4), I3 = !C2 && hn2(l4), y6 = !C2 && !I3 && Gn(l4);
          _2 = l4, C2 || I3 || y6 ? b3(c5) ? _2 = c5 : Y(c5) ? _2 = ut3(c5) : I3 ? (m2 = false, _2 = pu(l4, true)) : y6 ? (m2 = false, _2 = du(l4, true)) : _2 = [] : ge(l4) || An(l4) ? (_2 = c5, An(c5) ? _2 = ca(c5) : (!K3(c5) || Qt2(c5)) && (_2 = Lu(l4))) : m2 = false;
        }
        m2 && (f4.set(l4, _2), u3(_2, l4, r3, o5, f4), f4.delete(l4)), Yr2(t, e2, _2);
      }
      function eu(t, n4) {
        var e2 = t.length;
        if (e2) return n4 += n4 < 0 ? e2 : 0, Xt2(n4, e2) ? t[n4] : i3;
      }
      function ru(t, n4, e2) {
        n4.length ? n4 = z4(n4, function(o5) {
          return b3(o5) ? function(f4) {
            return wn2(f4, o5.length === 1 ? o5[0] : o5);
          } : o5;
        }) : n4 = [ft2];
        var r3 = -1;
        n4 = z4(n4, ht3(E4()));
        var u3 = js2(t, function(o5, f4, c5) {
          var l4 = z4(n4, function(v4) {
            return v4(o5);
          });
          return { criteria: l4, index: ++r3, value: o5 };
        });
        return pf(u3, function(o5, f4) {
          return jc(o5, f4, e2);
        });
      }
      function Mc(t, n4) {
        return iu(t, n4, function(e2, r3) {
          return Ri(t, r3);
        });
      }
      function iu(t, n4, e2) {
        for (var r3 = -1, u3 = n4.length, o5 = {}; ++r3 < u3; ) {
          var f4 = n4[r3], c5 = wn2(t, f4);
          e2(c5, f4) && he(o5, fn3(f4, t), c5);
        }
        return o5;
      }
      function Bc(t) {
        return function(n4) {
          return wn2(n4, t);
        };
      }
      function ei2(t, n4, e2, r3) {
        var u3 = r3 ? lf : Ln, o5 = -1, f4 = n4.length, c5 = t;
        for (t === n4 && (n4 = ut3(n4)), e2 && (c5 = z4(t, ht3(e2))); ++o5 < f4; ) for (var l4 = 0, v4 = n4[o5], _2 = e2 ? e2(v4) : v4; (l4 = u3(c5, _2, l4, r3)) > -1; ) c5 !== t && qe.call(c5, l4, 1), qe.call(t, l4, 1);
        return t;
      }
      function su(t, n4) {
        for (var e2 = t ? n4.length : 0, r3 = e2 - 1; e2--; ) {
          var u3 = n4[e2];
          if (e2 == r3 || u3 !== o5) {
            var o5 = u3;
            Xt2(u3) ? qe.call(t, u3, 1) : ui2(t, u3);
          }
        }
        return t;
      }
      function ri2(t, n4) {
        return t + We2(Fs2() * (n4 - t + 1));
      }
      function Gc(t, n4, e2, r3) {
        for (var u3 = -1, o5 = Q2(Fe((n4 - t) / (e2 || 1)), 0), f4 = d3(o5); o5--; ) f4[r3 ? o5 : ++u3] = t, t += e2;
        return f4;
      }
      function ii2(t, n4) {
        var e2 = "";
        if (!t || n4 < 1 || n4 > nn2) return e2;
        do
          n4 % 2 && (e2 += t), n4 = We2(n4 / 2), n4 && (t += t);
        while (n4);
        return e2;
      }
      function H(t, n4) {
        return Ci(Nu2(t, n4, ft2), t + "");
      }
      function zc(t) {
        return Bs2(zn(t));
      }
      function Kc(t, n4) {
        var e2 = zn(t);
        return rr3(e2, mn3(n4, 0, e2.length));
      }
      function he(t, n4, e2, r3) {
        if (!K3(t)) return t;
        n4 = fn3(n4, t);
        for (var u3 = -1, o5 = n4.length, f4 = o5 - 1, c5 = t; c5 != null && ++u3 < o5; ) {
          var l4 = Ft2(n4[u3]), v4 = e2;
          if (l4 === "__proto__" || l4 === "constructor" || l4 === "prototype") return t;
          if (u3 != f4) {
            var _2 = c5[l4];
            v4 = r3 ? r3(_2, l4, c5) : i3, v4 === i3 && (v4 = K3(_2) ? _2 : Xt2(n4[u3 + 1]) ? [] : {});
          }
          ae3(c5, l4, v4), c5 = c5[l4];
        }
        return t;
      }
      var uu = Me ? function(t, n4) {
        return Me.set(t, n4), t;
      } : ft2, Jc = Ue2 ? function(t, n4) {
        return Ue2(t, "toString", { configurable: true, enumerable: false, value: Ti(n4), writable: true });
      } : ft2;
      function Yc(t) {
        return rr3(zn(t));
      }
      function At2(t, n4, e2) {
        var r3 = -1, u3 = t.length;
        n4 < 0 && (n4 = -n4 > u3 ? 0 : u3 + n4), e2 = e2 > u3 ? u3 : e2, e2 < 0 && (e2 += u3), u3 = n4 > e2 ? 0 : e2 - n4 >>> 0, n4 >>>= 0;
        for (var o5 = d3(u3); ++r3 < u3; ) o5[r3] = t[r3 + n4];
        return o5;
      }
      function Zc(t, n4) {
        var e2;
        return an2(t, function(r3, u3, o5) {
          return e2 = n4(r3, u3, o5), !e2;
        }), !!e2;
      }
      function Ze3(t, n4, e2) {
        var r3 = 0, u3 = t == null ? r3 : t.length;
        if (typeof n4 == "number" && n4 === n4 && u3 <= Za) {
          for (; r3 < u3; ) {
            var o5 = r3 + u3 >>> 1, f4 = t[o5];
            f4 !== null && !pt3(f4) && (e2 ? f4 <= n4 : f4 < n4) ? r3 = o5 + 1 : u3 = o5;
          }
          return u3;
        }
        return si2(t, n4, ft2, e2);
      }
      function si2(t, n4, e2, r3) {
        var u3 = 0, o5 = t == null ? 0 : t.length;
        if (o5 === 0) return 0;
        n4 = e2(n4);
        for (var f4 = n4 !== n4, c5 = n4 === null, l4 = pt3(n4), v4 = n4 === i3; u3 < o5; ) {
          var _2 = We2((u3 + o5) / 2), m2 = e2(t[_2]), C2 = m2 !== i3, I3 = m2 === null, y6 = m2 === m2, L3 = pt3(m2);
          if (f4) var S3 = r3 || y6;
          else v4 ? S3 = y6 && (r3 || C2) : c5 ? S3 = y6 && C2 && (r3 || !I3) : l4 ? S3 = y6 && C2 && !I3 && (r3 || !L3) : I3 || L3 ? S3 = false : S3 = r3 ? m2 <= n4 : m2 < n4;
          S3 ? u3 = _2 + 1 : o5 = _2;
        }
        return nt3(o5, Ya);
      }
      function au(t, n4) {
        for (var e2 = -1, r3 = t.length, u3 = 0, o5 = []; ++e2 < r3; ) {
          var f4 = t[e2], c5 = n4 ? n4(f4) : f4;
          if (!e2 || !Rt2(c5, l4)) {
            var l4 = c5;
            o5[u3++] = f4 === 0 ? 0 : f4;
          }
        }
        return o5;
      }
      function ou(t) {
        return typeof t == "number" ? t : pt3(t) ? we3 : +t;
      }
      function lt3(t) {
        if (typeof t == "string") return t;
        if (b3(t)) return z4(t, lt3) + "";
        if (pt3(t)) return Ws2 ? Ws2.call(t) : "";
        var n4 = t + "";
        return n4 == "0" && 1 / t == -pn2 ? "-0" : n4;
      }
      function on2(t, n4, e2) {
        var r3 = -1, u3 = Se2, o5 = t.length, f4 = true, c5 = [], l4 = c5;
        if (e2) f4 = false, u3 = Dr2;
        else if (o5 >= w4) {
          var v4 = n4 ? null : sh2(t);
          if (v4) return Re(v4);
          f4 = false, u3 = ne2, l4 = new _n2();
        } else l4 = n4 ? [] : c5;
        t: for (; ++r3 < o5; ) {
          var _2 = t[r3], m2 = n4 ? n4(_2) : _2;
          if (_2 = e2 || _2 !== 0 ? _2 : 0, f4 && m2 === m2) {
            for (var C2 = l4.length; C2--; ) if (l4[C2] === m2) continue t;
            n4 && l4.push(m2), c5.push(_2);
          } else u3(l4, m2, e2) || (l4 !== c5 && l4.push(m2), c5.push(_2));
        }
        return c5;
      }
      function ui2(t, n4) {
        return n4 = fn3(n4, t), t = $u(t, n4), t == null || delete t[Ft2(It2(n4))];
      }
      function fu(t, n4, e2, r3) {
        return he(t, n4, e2(wn2(t, n4)), r3);
      }
      function Xe2(t, n4, e2, r3) {
        for (var u3 = t.length, o5 = r3 ? u3 : -1; (r3 ? o5-- : ++o5 < u3) && n4(t[o5], o5, t); ) ;
        return e2 ? At2(t, r3 ? 0 : o5, r3 ? o5 + 1 : u3) : At2(t, r3 ? o5 + 1 : 0, r3 ? u3 : o5);
      }
      function cu2(t, n4) {
        var e2 = t;
        return e2 instanceof N2 && (e2 = e2.value()), Nr2(n4, function(r3, u3) {
          return u3.func.apply(u3.thisArg, rn2([r3], u3.args));
        }, e2);
      }
      function ai2(t, n4, e2) {
        var r3 = t.length;
        if (r3 < 2) return r3 ? on2(t[0]) : [];
        for (var u3 = -1, o5 = d3(r3); ++u3 < r3; ) for (var f4 = t[u3], c5 = -1; ++c5 < r3; ) c5 != u3 && (o5[u3] = oe3(o5[u3] || f4, t[c5], n4, e2));
        return on2(tt3(o5, 1), n4, e2);
      }
      function hu(t, n4, e2) {
        for (var r3 = -1, u3 = t.length, o5 = n4.length, f4 = {}; ++r3 < u3; ) {
          var c5 = r3 < o5 ? n4[r3] : i3;
          e2(f4, t[r3], c5);
        }
        return f4;
      }
      function oi2(t) {
        return Y(t) ? t : [];
      }
      function fi(t) {
        return typeof t == "function" ? t : ft2;
      }
      function fn3(t, n4) {
        return b3(t) ? t : mi2(t, n4) ? [t] : Wu(U3(t));
      }
      var Xc = H;
      function cn2(t, n4, e2) {
        var r3 = t.length;
        return e2 = e2 === i3 ? r3 : e2, !n4 && e2 >= r3 ? t : At2(t, n4, e2);
      }
      var lu2 = $f || function(t) {
        return j4.clearTimeout(t);
      };
      function pu(t, n4) {
        if (n4) return t.slice();
        var e2 = t.length, r3 = Ds2 ? Ds2(e2) : new t.constructor(e2);
        return t.copy(r3), r3;
      }
      function ci2(t) {
        var n4 = new t.constructor(t.byteLength);
        return new Ne(n4).set(new Ne(t)), n4;
      }
      function Qc(t, n4) {
        var e2 = n4 ? ci2(t.buffer) : t.buffer;
        return new t.constructor(e2, t.byteOffset, t.byteLength);
      }
      function Vc(t) {
        var n4 = new t.constructor(t.source, Qi.exec(t));
        return n4.lastIndex = t.lastIndex, n4;
      }
      function kc(t) {
        return ue ? M2(ue.call(t)) : {};
      }
      function du(t, n4) {
        var e2 = n4 ? ci2(t.buffer) : t.buffer;
        return new t.constructor(e2, t.byteOffset, t.length);
      }
      function gu(t, n4) {
        if (t !== n4) {
          var e2 = t !== i3, r3 = t === null, u3 = t === t, o5 = pt3(t), f4 = n4 !== i3, c5 = n4 === null, l4 = n4 === n4, v4 = pt3(n4);
          if (!c5 && !v4 && !o5 && t > n4 || o5 && f4 && l4 && !c5 && !v4 || r3 && f4 && l4 || !e2 && l4 || !u3) return 1;
          if (!r3 && !o5 && !v4 && t < n4 || v4 && e2 && u3 && !r3 && !o5 || c5 && e2 && u3 || !f4 && u3 || !l4) return -1;
        }
        return 0;
      }
      function jc(t, n4, e2) {
        for (var r3 = -1, u3 = t.criteria, o5 = n4.criteria, f4 = u3.length, c5 = e2.length; ++r3 < f4; ) {
          var l4 = gu(u3[r3], o5[r3]);
          if (l4) {
            if (r3 >= c5) return l4;
            var v4 = e2[r3];
            return l4 * (v4 == "desc" ? -1 : 1);
          }
        }
        return t.index - n4.index;
      }
      function vu(t, n4, e2, r3) {
        for (var u3 = -1, o5 = t.length, f4 = e2.length, c5 = -1, l4 = n4.length, v4 = Q2(o5 - f4, 0), _2 = d3(l4 + v4), m2 = !r3; ++c5 < l4; ) _2[c5] = n4[c5];
        for (; ++u3 < f4; ) (m2 || u3 < o5) && (_2[e2[u3]] = t[u3]);
        for (; v4--; ) _2[c5++] = t[u3++];
        return _2;
      }
      function _u2(t, n4, e2, r3) {
        for (var u3 = -1, o5 = t.length, f4 = -1, c5 = e2.length, l4 = -1, v4 = n4.length, _2 = Q2(o5 - c5, 0), m2 = d3(_2 + v4), C2 = !r3; ++u3 < _2; ) m2[u3] = t[u3];
        for (var I3 = u3; ++l4 < v4; ) m2[I3 + l4] = n4[l4];
        for (; ++f4 < c5; ) (C2 || u3 < o5) && (m2[I3 + e2[f4]] = t[u3++]);
        return m2;
      }
      function ut3(t, n4) {
        var e2 = -1, r3 = t.length;
        for (n4 || (n4 = d3(r3)); ++e2 < r3; ) n4[e2] = t[e2];
        return n4;
      }
      function Ut2(t, n4, e2, r3) {
        var u3 = !e2;
        e2 || (e2 = {});
        for (var o5 = -1, f4 = n4.length; ++o5 < f4; ) {
          var c5 = n4[o5], l4 = r3 ? r3(e2[c5], t[c5], c5, e2, t) : i3;
          l4 === i3 && (l4 = t[c5]), u3 ? Jt2(e2, c5, l4) : ae3(e2, c5, l4);
        }
        return e2;
      }
      function th(t, n4) {
        return Ut2(t, _i(t), n4);
      }
      function nh2(t, n4) {
        return Ut2(t, bu2(t), n4);
      }
      function Qe2(t, n4) {
        return function(e2, r3) {
          var u3 = b3(e2) ? uf : Ic, o5 = n4 ? n4() : {};
          return u3(e2, t, E4(r3, 2), o5);
        };
      }
      function Wn(t) {
        return H(function(n4, e2) {
          var r3 = -1, u3 = e2.length, o5 = u3 > 1 ? e2[u3 - 1] : i3, f4 = u3 > 2 ? e2[2] : i3;
          for (o5 = t.length > 3 && typeof o5 == "function" ? (u3--, o5) : i3, f4 && it3(e2[0], e2[1], f4) && (o5 = u3 < 3 ? i3 : o5, u3 = 1), n4 = M2(n4); ++r3 < u3; ) {
            var c5 = e2[r3];
            c5 && t(n4, c5, r3, o5);
          }
          return n4;
        });
      }
      function mu2(t, n4) {
        return function(e2, r3) {
          if (e2 == null) return e2;
          if (!at3(e2)) return t(e2, r3);
          for (var u3 = e2.length, o5 = n4 ? u3 : -1, f4 = M2(e2); (n4 ? o5-- : ++o5 < u3) && r3(f4[o5], o5, f4) !== false; ) ;
          return e2;
        };
      }
      function wu2(t) {
        return function(n4, e2, r3) {
          for (var u3 = -1, o5 = M2(n4), f4 = r3(n4), c5 = f4.length; c5--; ) {
            var l4 = f4[t ? c5 : ++u3];
            if (e2(o5[l4], l4, o5) === false) break;
          }
          return n4;
        };
      }
      function eh(t, n4, e2) {
        var r3 = n4 & vt2, u3 = le(t);
        function o5() {
          var f4 = this && this !== j4 && this instanceof o5 ? u3 : t;
          return f4.apply(r3 ? e2 : this, arguments);
        }
        return o5;
      }
      function Pu2(t) {
        return function(n4) {
          n4 = U3(n4);
          var e2 = Hn(n4) ? St2(n4) : i3, r3 = e2 ? e2[0] : n4.charAt(0), u3 = e2 ? cn2(e2, 1).join("") : n4.slice(1);
          return r3[t]() + u3;
        };
      }
      function Mn(t) {
        return function(n4) {
          return Nr2(ma(_a(n4).replace(Ko, "")), t, "");
        };
      }
      function le(t) {
        return function() {
          var n4 = arguments;
          switch (n4.length) {
            case 0:
              return new t();
            case 1:
              return new t(n4[0]);
            case 2:
              return new t(n4[0], n4[1]);
            case 3:
              return new t(n4[0], n4[1], n4[2]);
            case 4:
              return new t(n4[0], n4[1], n4[2], n4[3]);
            case 5:
              return new t(n4[0], n4[1], n4[2], n4[3], n4[4]);
            case 6:
              return new t(n4[0], n4[1], n4[2], n4[3], n4[4], n4[5]);
            case 7:
              return new t(n4[0], n4[1], n4[2], n4[3], n4[4], n4[5], n4[6]);
          }
          var e2 = Fn(t.prototype), r3 = t.apply(e2, n4);
          return K3(r3) ? r3 : e2;
        };
      }
      function rh(t, n4, e2) {
        var r3 = le(t);
        function u3() {
          for (var o5 = arguments.length, f4 = d3(o5), c5 = o5, l4 = Bn(u3); c5--; ) f4[c5] = arguments[c5];
          var v4 = o5 < 3 && f4[0] !== l4 && f4[o5 - 1] !== l4 ? [] : sn2(f4, l4);
          if (o5 -= v4.length, o5 < e2) return Eu2(t, n4, Ve, u3.placeholder, i3, f4, v4, i3, i3, e2 - o5);
          var _2 = this && this !== j4 && this instanceof u3 ? r3 : t;
          return ct3(_2, this, f4);
        }
        return u3;
      }
      function Cu2(t) {
        return function(n4, e2, r3) {
          var u3 = M2(n4);
          if (!at3(n4)) {
            var o5 = E4(e2, 3);
            n4 = V3(n4), e2 = function(c5) {
              return o5(u3[c5], c5, u3);
            };
          }
          var f4 = t(n4, e2, r3);
          return f4 > -1 ? u3[o5 ? n4[f4] : f4] : i3;
        };
      }
      function Au2(t) {
        return Zt3(function(n4) {
          var e2 = n4.length, r3 = e2, u3 = Pt2.prototype.thru;
          for (t && n4.reverse(); r3--; ) {
            var o5 = n4[r3];
            if (typeof o5 != "function") throw new wt2(O4);
            if (u3 && !f4 && nr2(o5) == "wrapper") var f4 = new Pt2([], true);
          }
          for (r3 = f4 ? r3 : e2; ++r3 < e2; ) {
            o5 = n4[r3];
            var c5 = nr2(o5), l4 = c5 == "wrapper" ? gi2(o5) : i3;
            l4 && wi(l4[0]) && l4[1] == (Bt2 | Dt2 | Nt2 | Yn) && !l4[4].length && l4[9] == 1 ? f4 = f4[nr2(l4[0])].apply(f4, l4[3]) : f4 = o5.length == 1 && wi(o5) ? f4[c5]() : f4.thru(o5);
          }
          return function() {
            var v4 = arguments, _2 = v4[0];
            if (f4 && v4.length == 1 && b3(_2)) return f4.plant(_2).value();
            for (var m2 = 0, C2 = e2 ? n4[m2].apply(this, v4) : _2; ++m2 < e2; ) C2 = n4[m2].call(this, C2);
            return C2;
          };
        });
      }
      function Ve(t, n4, e2, r3, u3, o5, f4, c5, l4, v4) {
        var _2 = n4 & Bt2, m2 = n4 & vt2, C2 = n4 & ln2, I3 = n4 & (Dt2 | Sn2), y6 = n4 & gr3, L3 = C2 ? i3 : le(t);
        function S3() {
          for (var D2 = arguments.length, $3 = d3(D2), dt3 = D2; dt3--; ) $3[dt3] = arguments[dt3];
          if (I3) var st3 = Bn(S3), gt3 = gf($3, st3);
          if (r3 && ($3 = vu($3, r3, u3, I3)), o5 && ($3 = _u2($3, o5, f4, I3)), D2 -= gt3, I3 && D2 < v4) {
            var Z2 = sn2($3, st3);
            return Eu2(t, n4, Ve, S3.placeholder, e2, $3, Z2, c5, l4, v4 - D2);
          }
          var bt2 = m2 ? e2 : this, kt2 = C2 ? bt2[t] : t;
          return D2 = $3.length, c5 ? $3 = Ih($3, c5) : y6 && D2 > 1 && $3.reverse(), _2 && l4 < D2 && ($3.length = l4), this && this !== j4 && this instanceof S3 && (kt2 = L3 || le(kt2)), kt2.apply(bt2, $3);
        }
        return S3;
      }
      function Iu2(t, n4) {
        return function(e2, r3) {
          return Tc(e2, t, n4(r3), {});
        };
      }
      function ke(t, n4) {
        return function(e2, r3) {
          var u3;
          if (e2 === i3 && r3 === i3) return n4;
          if (e2 !== i3 && (u3 = e2), r3 !== i3) {
            if (u3 === i3) return r3;
            typeof e2 == "string" || typeof r3 == "string" ? (e2 = lt3(e2), r3 = lt3(r3)) : (e2 = ou(e2), r3 = ou(r3)), u3 = t(e2, r3);
          }
          return u3;
        };
      }
      function hi2(t) {
        return Zt3(function(n4) {
          return n4 = z4(n4, ht3(E4())), H(function(e2) {
            var r3 = this;
            return t(n4, function(u3) {
              return ct3(u3, r3, e2);
            });
          });
        });
      }
      function je(t, n4) {
        n4 = n4 === i3 ? " " : lt3(n4);
        var e2 = n4.length;
        if (e2 < 2) return e2 ? ii2(n4, t) : n4;
        var r3 = ii2(n4, Fe(t / Dn2(n4)));
        return Hn(n4) ? cn2(St2(r3), 0, t).join("") : r3.slice(0, t);
      }
      function ih(t, n4, e2, r3) {
        var u3 = n4 & vt2, o5 = le(t);
        function f4() {
          for (var c5 = -1, l4 = arguments.length, v4 = -1, _2 = r3.length, m2 = d3(_2 + l4), C2 = this && this !== j4 && this instanceof f4 ? o5 : t; ++v4 < _2; ) m2[v4] = r3[v4];
          for (; l4--; ) m2[v4++] = arguments[++c5];
          return ct3(C2, u3 ? e2 : this, m2);
        }
        return f4;
      }
      function xu(t) {
        return function(n4, e2, r3) {
          return r3 && typeof r3 != "number" && it3(n4, e2, r3) && (e2 = r3 = i3), n4 = Vt2(n4), e2 === i3 ? (e2 = n4, n4 = 0) : e2 = Vt2(e2), r3 = r3 === i3 ? n4 < e2 ? 1 : -1 : Vt2(r3), Gc(n4, e2, r3, t);
        };
      }
      function tr2(t) {
        return function(n4, e2) {
          return typeof n4 == "string" && typeof e2 == "string" || (n4 = xt2(n4), e2 = xt2(e2)), t(n4, e2);
        };
      }
      function Eu2(t, n4, e2, r3, u3, o5, f4, c5, l4, v4) {
        var _2 = n4 & Dt2, m2 = _2 ? f4 : i3, C2 = _2 ? i3 : f4, I3 = _2 ? o5 : i3, y6 = _2 ? i3 : o5;
        n4 |= _2 ? Nt2 : On, n4 &= ~(_2 ? On : Nt2), n4 & Gi || (n4 &= ~(vt2 | ln2));
        var L3 = [t, n4, u3, I3, m2, y6, C2, c5, l4, v4], S3 = e2.apply(i3, L3);
        return wi(t) && qu2(S3, L3), S3.placeholder = r3, Uu2(S3, t, n4);
      }
      function li2(t) {
        var n4 = X2[t];
        return function(e2, r3) {
          if (e2 = xt2(e2), r3 = r3 == null ? 0 : nt3(T3(r3), 292), r3 && Us2(e2)) {
            var u3 = (U3(e2) + "e").split("e"), o5 = n4(u3[0] + "e" + (+u3[1] + r3));
            return u3 = (U3(o5) + "e").split("e"), +(u3[0] + "e" + (+u3[1] - r3));
          }
          return n4(e2);
        };
      }
      var sh2 = qn && 1 / Re(new qn([, -0]))[1] == pn2 ? function(t) {
        return new qn(t);
      } : Di2;
      function yu2(t) {
        return function(n4) {
          var e2 = et3(n4);
          return e2 == Et2 ? Br(n4) : e2 == yt3 ? Af(n4) : df(n4, t(n4));
        };
      }
      function Yt3(t, n4, e2, r3, u3, o5, f4, c5) {
        var l4 = n4 & ln2;
        if (!l4 && typeof t != "function") throw new wt2(O4);
        var v4 = r3 ? r3.length : 0;
        if (v4 || (n4 &= ~(Nt2 | On), r3 = u3 = i3), f4 = f4 === i3 ? f4 : Q2(T3(f4), 0), c5 = c5 === i3 ? c5 : T3(c5), v4 -= u3 ? u3.length : 0, n4 & On) {
          var _2 = r3, m2 = u3;
          r3 = u3 = i3;
        }
        var C2 = l4 ? i3 : gi2(t), I3 = [t, n4, e2, r3, u3, _2, m2, o5, f4, c5];
        if (C2 && Ph(I3, C2), t = I3[0], n4 = I3[1], e2 = I3[2], r3 = I3[3], u3 = I3[4], c5 = I3[9] = I3[9] === i3 ? l4 ? 0 : t.length : Q2(I3[9] - v4, 0), !c5 && n4 & (Dt2 | Sn2) && (n4 &= ~(Dt2 | Sn2)), !n4 || n4 == vt2) var y6 = eh(t, n4, e2);
        else n4 == Dt2 || n4 == Sn2 ? y6 = rh(t, n4, c5) : (n4 == Nt2 || n4 == (vt2 | Nt2)) && !u3.length ? y6 = ih(t, n4, e2, r3) : y6 = Ve.apply(i3, I3);
        var L3 = C2 ? uu : qu2;
        return Uu2(L3(y6, I3), t, n4);
      }
      function Su2(t, n4, e2, r3) {
        return t === i3 || Rt2(t, $n[e2]) && !W2.call(r3, e2) ? n4 : t;
      }
      function Ou2(t, n4, e2, r3, u3, o5) {
        return K3(t) && K3(n4) && (o5.set(n4, t), Ye2(t, n4, i3, Ou2, o5), o5.delete(n4)), t;
      }
      function uh2(t) {
        return ge(t) ? i3 : t;
      }
      function Ru2(t, n4, e2, r3, u3, o5) {
        var f4 = e2 & yn2, c5 = t.length, l4 = n4.length;
        if (c5 != l4 && !(f4 && l4 > c5)) return false;
        var v4 = o5.get(t), _2 = o5.get(n4);
        if (v4 && _2) return v4 == n4 && _2 == t;
        var m2 = -1, C2 = true, I3 = e2 & me4 ? new _n2() : i3;
        for (o5.set(t, n4), o5.set(n4, t); ++m2 < c5; ) {
          var y6 = t[m2], L3 = n4[m2];
          if (r3) var S3 = f4 ? r3(L3, y6, m2, n4, t, o5) : r3(y6, L3, m2, t, n4, o5);
          if (S3 !== i3) {
            if (S3) continue;
            C2 = false;
            break;
          }
          if (I3) {
            if (!$r2(n4, function(D2, $3) {
              if (!ne2(I3, $3) && (y6 === D2 || u3(y6, D2, e2, r3, o5))) return I3.push($3);
            })) {
              C2 = false;
              break;
            }
          } else if (!(y6 === L3 || u3(y6, L3, e2, r3, o5))) {
            C2 = false;
            break;
          }
        }
        return o5.delete(t), o5.delete(n4), C2;
      }
      function ah2(t, n4, e2, r3, u3, o5, f4) {
        switch (e2) {
          case bn2:
            if (t.byteLength != n4.byteLength || t.byteOffset != n4.byteOffset) return false;
            t = t.buffer, n4 = n4.buffer;
          case te2:
            return !(t.byteLength != n4.byteLength || !o5(new Ne(t), new Ne(n4)));
          case Zn:
          case Xn:
          case Qn:
            return Rt2(+t, +n4);
          case Ce3:
            return t.name == n4.name && t.message == n4.message;
          case Vn:
          case kn:
            return t == n4 + "";
          case Et2:
            var c5 = Br;
          case yt3:
            var l4 = r3 & yn2;
            if (c5 || (c5 = Re), t.size != n4.size && !l4) return false;
            var v4 = f4.get(t);
            if (v4) return v4 == n4;
            r3 |= me4, f4.set(t, n4);
            var _2 = Ru2(c5(t), c5(n4), r3, u3, o5, f4);
            return f4.delete(t), _2;
          case Ie2:
            if (ue) return ue.call(t) == ue.call(n4);
        }
        return false;
      }
      function oh2(t, n4, e2, r3, u3, o5) {
        var f4 = e2 & yn2, c5 = pi2(t), l4 = c5.length, v4 = pi2(n4), _2 = v4.length;
        if (l4 != _2 && !f4) return false;
        for (var m2 = l4; m2--; ) {
          var C2 = c5[m2];
          if (!(f4 ? C2 in n4 : W2.call(n4, C2))) return false;
        }
        var I3 = o5.get(t), y6 = o5.get(n4);
        if (I3 && y6) return I3 == n4 && y6 == t;
        var L3 = true;
        o5.set(t, n4), o5.set(n4, t);
        for (var S3 = f4; ++m2 < l4; ) {
          C2 = c5[m2];
          var D2 = t[C2], $3 = n4[C2];
          if (r3) var dt3 = f4 ? r3($3, D2, C2, n4, t, o5) : r3(D2, $3, C2, t, n4, o5);
          if (!(dt3 === i3 ? D2 === $3 || u3(D2, $3, e2, r3, o5) : dt3)) {
            L3 = false;
            break;
          }
          S3 || (S3 = C2 == "constructor");
        }
        if (L3 && !S3) {
          var st3 = t.constructor, gt3 = n4.constructor;
          st3 != gt3 && "constructor" in t && "constructor" in n4 && !(typeof st3 == "function" && st3 instanceof st3 && typeof gt3 == "function" && gt3 instanceof gt3) && (L3 = false);
        }
        return o5.delete(t), o5.delete(n4), L3;
      }
      function Zt3(t) {
        return Ci(Nu2(t, i3, zu), t + "");
      }
      function pi2(t) {
        return Xs2(t, V3, _i);
      }
      function di2(t) {
        return Xs2(t, ot3, bu2);
      }
      var gi2 = Me ? function(t) {
        return Me.get(t);
      } : Di2;
      function nr2(t) {
        for (var n4 = t.name + "", e2 = Un[n4], r3 = W2.call(Un, n4) ? e2.length : 0; r3--; ) {
          var u3 = e2[r3], o5 = u3.func;
          if (o5 == null || o5 == t) return u3.name;
        }
        return n4;
      }
      function Bn(t) {
        var n4 = W2.call(a4, "placeholder") ? a4 : t;
        return n4.placeholder;
      }
      function E4() {
        var t = a4.iteratee || Li;
        return t = t === Li ? ks2 : t, arguments.length ? t(arguments[0], arguments[1]) : t;
      }
      function er3(t, n4) {
        var e2 = t.__data__;
        return vh2(n4) ? e2[typeof n4 == "string" ? "string" : "hash"] : e2.map;
      }
      function vi(t) {
        for (var n4 = V3(t), e2 = n4.length; e2--; ) {
          var r3 = n4[e2], u3 = t[r3];
          n4[e2] = [r3, u3, Hu(u3)];
        }
        return n4;
      }
      function Pn2(t, n4) {
        var e2 = wf(t, n4);
        return Vs2(e2) ? e2 : i3;
      }
      function fh2(t) {
        var n4 = W2.call(t, gn2), e2 = t[gn2];
        try {
          t[gn2] = i3;
          var r3 = true;
        } catch {
        }
        var u3 = He.call(t);
        return r3 && (n4 ? t[gn2] = e2 : delete t[gn2]), u3;
      }
      var _i = zr2 ? function(t) {
        return t == null ? [] : (t = M2(t), en2(zr2(t), function(n4) {
          return $s2.call(t, n4);
        }));
      } : Ni, bu2 = zr2 ? function(t) {
        for (var n4 = []; t; ) rn2(n4, _i(t)), t = $e2(t);
        return n4;
      } : Ni, et3 = rt3;
      (Kr && et3(new Kr(new ArrayBuffer(1))) != bn2 || re2 && et3(new re2()) != Et2 || Jr2 && et3(Jr2.resolve()) != Ji || qn && et3(new qn()) != yt3 || ie && et3(new ie()) != jn) && (et3 = function(t) {
        var n4 = rt3(t), e2 = n4 == Gt2 ? t.constructor : i3, r3 = e2 ? Cn2(e2) : "";
        if (r3) switch (r3) {
          case Kf:
            return bn2;
          case Jf2:
            return Et2;
          case Yf:
            return Ji;
          case Zf:
            return yt3;
          case Xf:
            return jn;
        }
        return n4;
      });
      function ch2(t, n4, e2) {
        for (var r3 = -1, u3 = e2.length; ++r3 < u3; ) {
          var o5 = e2[r3], f4 = o5.size;
          switch (o5.type) {
            case "drop":
              t += f4;
              break;
            case "dropRight":
              n4 -= f4;
              break;
            case "take":
              n4 = nt3(n4, t + f4);
              break;
            case "takeRight":
              t = Q2(t, n4 - f4);
              break;
          }
        }
        return { start: t, end: n4 };
      }
      function hh2(t) {
        var n4 = t.match(vo);
        return n4 ? n4[1].split(_o2) : [];
      }
      function Tu(t, n4, e2) {
        n4 = fn3(n4, t);
        for (var r3 = -1, u3 = n4.length, o5 = false; ++r3 < u3; ) {
          var f4 = Ft2(n4[r3]);
          if (!(o5 = t != null && e2(t, f4))) break;
          t = t[f4];
        }
        return o5 || ++r3 != u3 ? o5 : (u3 = t == null ? 0 : t.length, !!u3 && fr2(u3) && Xt2(f4, u3) && (b3(t) || An(t)));
      }
      function lh2(t) {
        var n4 = t.length, e2 = new t.constructor(n4);
        return n4 && typeof t[0] == "string" && W2.call(t, "index") && (e2.index = t.index, e2.input = t.input), e2;
      }
      function Lu(t) {
        return typeof t.constructor == "function" && !pe(t) ? Fn($e2(t)) : {};
      }
      function ph2(t, n4, e2) {
        var r3 = t.constructor;
        switch (n4) {
          case te2:
            return ci2(t);
          case Zn:
          case Xn:
            return new r3(+t);
          case bn2:
            return Qc(t, e2);
          case vr2:
          case _r2:
          case mr2:
          case wr2:
          case Pr2:
          case Cr2:
          case Ar2:
          case Ir3:
          case xr2:
            return du(t, e2);
          case Et2:
            return new r3();
          case Qn:
          case kn:
            return new r3(t);
          case Vn:
            return Vc(t);
          case yt3:
            return new r3();
          case Ie2:
            return kc(t);
        }
      }
      function dh2(t, n4) {
        var e2 = n4.length;
        if (!e2) return t;
        var r3 = e2 - 1;
        return n4[r3] = (e2 > 1 ? "& " : "") + n4[r3], n4 = n4.join(e2 > 2 ? ", " : " "), t.replace(go, `{
/* [wrapped with ` + n4 + `] */
`);
      }
      function gh2(t) {
        return b3(t) || An(t) || !!(qs3 && t && t[qs3]);
      }
      function Xt2(t, n4) {
        var e2 = typeof t;
        return n4 = n4 ?? nn2, !!n4 && (e2 == "number" || e2 != "symbol" && yo.test(t)) && t > -1 && t % 1 == 0 && t < n4;
      }
      function it3(t, n4, e2) {
        if (!K3(e2)) return false;
        var r3 = typeof n4;
        return (r3 == "number" ? at3(e2) && Xt2(n4, e2.length) : r3 == "string" && n4 in e2) ? Rt2(e2[n4], t) : false;
      }
      function mi2(t, n4) {
        if (b3(t)) return false;
        var e2 = typeof t;
        return e2 == "number" || e2 == "symbol" || e2 == "boolean" || t == null || pt3(t) ? true : co.test(t) || !fo.test(t) || n4 != null && t in M2(n4);
      }
      function vh2(t) {
        var n4 = typeof t;
        return n4 == "string" || n4 == "number" || n4 == "symbol" || n4 == "boolean" ? t !== "__proto__" : t === null;
      }
      function wi(t) {
        var n4 = nr2(t), e2 = a4[n4];
        if (typeof e2 != "function" || !(n4 in N2.prototype)) return false;
        if (t === e2) return true;
        var r3 = gi2(e2);
        return !!r3 && t === r3[0];
      }
      function _h(t) {
        return !!Hs2 && Hs2 in t;
      }
      var mh2 = Te2 ? Qt2 : $i2;
      function pe(t) {
        var n4 = t && t.constructor, e2 = typeof n4 == "function" && n4.prototype || $n;
        return t === e2;
      }
      function Hu(t) {
        return t === t && !K3(t);
      }
      function Du2(t, n4) {
        return function(e2) {
          return e2 == null ? false : e2[t] === n4 && (n4 !== i3 || t in M2(e2));
        };
      }
      function wh(t) {
        var n4 = ar2(t, function(r3) {
          return e2.size === Jn && e2.clear(), r3;
        }), e2 = n4.cache;
        return n4;
      }
      function Ph(t, n4) {
        var e2 = t[1], r3 = n4[1], u3 = e2 | r3, o5 = u3 < (vt2 | ln2 | Bt2), f4 = r3 == Bt2 && e2 == Dt2 || r3 == Bt2 && e2 == Yn && t[7].length <= n4[8] || r3 == (Bt2 | Yn) && n4[7].length <= n4[8] && e2 == Dt2;
        if (!(o5 || f4)) return t;
        r3 & vt2 && (t[2] = n4[2], u3 |= e2 & vt2 ? 0 : Gi);
        var c5 = n4[3];
        if (c5) {
          var l4 = t[3];
          t[3] = l4 ? vu(l4, c5, n4[4]) : c5, t[4] = l4 ? sn2(t[3], xn) : n4[4];
        }
        return c5 = n4[5], c5 && (l4 = t[5], t[5] = l4 ? _u2(l4, c5, n4[6]) : c5, t[6] = l4 ? sn2(t[5], xn) : n4[6]), c5 = n4[7], c5 && (t[7] = c5), r3 & Bt2 && (t[8] = t[8] == null ? n4[8] : nt3(t[8], n4[8])), t[9] == null && (t[9] = n4[9]), t[0] = n4[0], t[1] = u3, t;
      }
      function Ch(t) {
        var n4 = [];
        if (t != null) for (var e2 in M2(t)) n4.push(e2);
        return n4;
      }
      function Ah2(t) {
        return He.call(t);
      }
      function Nu2(t, n4, e2) {
        return n4 = Q2(n4 === i3 ? t.length - 1 : n4, 0), function() {
          for (var r3 = arguments, u3 = -1, o5 = Q2(r3.length - n4, 0), f4 = d3(o5); ++u3 < o5; ) f4[u3] = r3[n4 + u3];
          u3 = -1;
          for (var c5 = d3(n4 + 1); ++u3 < n4; ) c5[u3] = r3[u3];
          return c5[n4] = e2(f4), ct3(t, this, c5);
        };
      }
      function $u(t, n4) {
        return n4.length < 2 ? t : wn2(t, At2(n4, 0, -1));
      }
      function Ih(t, n4) {
        for (var e2 = t.length, r3 = nt3(n4.length, e2), u3 = ut3(t); r3--; ) {
          var o5 = n4[r3];
          t[r3] = Xt2(o5, e2) ? u3[o5] : i3;
        }
        return t;
      }
      function Pi(t, n4) {
        if (!(n4 === "constructor" && typeof t[n4] == "function") && n4 != "__proto__") return t[n4];
      }
      var qu2 = Fu(uu), de = Uf || function(t, n4) {
        return j4.setTimeout(t, n4);
      }, Ci = Fu(Jc);
      function Uu2(t, n4, e2) {
        var r3 = n4 + "";
        return Ci(t, dh2(r3, xh(hh2(r3), e2)));
      }
      function Fu(t) {
        var n4 = 0, e2 = 0;
        return function() {
          var r3 = Bf(), u3 = Ga - (r3 - e2);
          if (e2 = r3, u3 > 0) {
            if (++n4 >= Ba) return arguments[0];
          } else n4 = 0;
          return t.apply(i3, arguments);
        };
      }
      function rr3(t, n4) {
        var e2 = -1, r3 = t.length, u3 = r3 - 1;
        for (n4 = n4 === i3 ? r3 : n4; ++e2 < n4; ) {
          var o5 = ri2(e2, u3), f4 = t[o5];
          t[o5] = t[e2], t[e2] = f4;
        }
        return t.length = n4, t;
      }
      var Wu = wh(function(t) {
        var n4 = [];
        return t.charCodeAt(0) === 46 && n4.push(""), t.replace(ho, function(e2, r3, u3, o5) {
          n4.push(u3 ? o5.replace(Po, "$1") : r3 || e2);
        }), n4;
      });
      function Ft2(t) {
        if (typeof t == "string" || pt3(t)) return t;
        var n4 = t + "";
        return n4 == "0" && 1 / t == -pn2 ? "-0" : n4;
      }
      function Cn2(t) {
        if (t != null) {
          try {
            return Le2.call(t);
          } catch {
          }
          try {
            return t + "";
          } catch {
          }
        }
        return "";
      }
      function xh(t, n4) {
        return mt2(Xa, function(e2) {
          var r3 = "_." + e2[0];
          n4 & e2[1] && !Se2(t, r3) && t.push(r3);
        }), t.sort();
      }
      function Mu2(t) {
        if (t instanceof N2) return t.clone();
        var n4 = new Pt2(t.__wrapped__, t.__chain__);
        return n4.__actions__ = ut3(t.__actions__), n4.__index__ = t.__index__, n4.__values__ = t.__values__, n4;
      }
      function Eh2(t, n4, e2) {
        (e2 ? it3(t, n4, e2) : n4 === i3) ? n4 = 1 : n4 = Q2(T3(n4), 0);
        var r3 = t == null ? 0 : t.length;
        if (!r3 || n4 < 1) return [];
        for (var u3 = 0, o5 = 0, f4 = d3(Fe(r3 / n4)); u3 < r3; ) f4[o5++] = At2(t, u3, u3 += n4);
        return f4;
      }
      function yh2(t) {
        for (var n4 = -1, e2 = t == null ? 0 : t.length, r3 = 0, u3 = []; ++n4 < e2; ) {
          var o5 = t[n4];
          o5 && (u3[r3++] = o5);
        }
        return u3;
      }
      function Sh2() {
        var t = arguments.length;
        if (!t) return [];
        for (var n4 = d3(t - 1), e2 = arguments[0], r3 = t; r3--; ) n4[r3 - 1] = arguments[r3];
        return rn2(b3(e2) ? ut3(e2) : [e2], tt3(n4, 1));
      }
      var Oh = H(function(t, n4) {
        return Y(t) ? oe3(t, tt3(n4, 1, Y, true)) : [];
      }), Rh = H(function(t, n4) {
        var e2 = It2(n4);
        return Y(e2) && (e2 = i3), Y(t) ? oe3(t, tt3(n4, 1, Y, true), E4(e2, 2)) : [];
      }), bh2 = H(function(t, n4) {
        var e2 = It2(n4);
        return Y(e2) && (e2 = i3), Y(t) ? oe3(t, tt3(n4, 1, Y, true), i3, e2) : [];
      });
      function Th(t, n4, e2) {
        var r3 = t == null ? 0 : t.length;
        return r3 ? (n4 = e2 || n4 === i3 ? 1 : T3(n4), At2(t, n4 < 0 ? 0 : n4, r3)) : [];
      }
      function Lh(t, n4, e2) {
        var r3 = t == null ? 0 : t.length;
        return r3 ? (n4 = e2 || n4 === i3 ? 1 : T3(n4), n4 = r3 - n4, At2(t, 0, n4 < 0 ? 0 : n4)) : [];
      }
      function Hh(t, n4) {
        return t && t.length ? Xe2(t, E4(n4, 3), true, true) : [];
      }
      function Dh(t, n4) {
        return t && t.length ? Xe2(t, E4(n4, 3), true) : [];
      }
      function Nh2(t, n4, e2, r3) {
        var u3 = t == null ? 0 : t.length;
        return u3 ? (e2 && typeof e2 != "number" && it3(t, n4, e2) && (e2 = 0, r3 = u3), Sc(t, n4, e2, r3)) : [];
      }
      function Bu2(t, n4, e2) {
        var r3 = t == null ? 0 : t.length;
        if (!r3) return -1;
        var u3 = e2 == null ? 0 : T3(e2);
        return u3 < 0 && (u3 = Q2(r3 + u3, 0)), Oe(t, E4(n4, 3), u3);
      }
      function Gu2(t, n4, e2) {
        var r3 = t == null ? 0 : t.length;
        if (!r3) return -1;
        var u3 = r3 - 1;
        return e2 !== i3 && (u3 = T3(e2), u3 = e2 < 0 ? Q2(r3 + u3, 0) : nt3(u3, r3 - 1)), Oe(t, E4(n4, 3), u3, true);
      }
      function zu(t) {
        var n4 = t == null ? 0 : t.length;
        return n4 ? tt3(t, 1) : [];
      }
      function $h(t) {
        var n4 = t == null ? 0 : t.length;
        return n4 ? tt3(t, pn2) : [];
      }
      function qh(t, n4) {
        var e2 = t == null ? 0 : t.length;
        return e2 ? (n4 = n4 === i3 ? 1 : T3(n4), tt3(t, n4)) : [];
      }
      function Uh(t) {
        for (var n4 = -1, e2 = t == null ? 0 : t.length, r3 = {}; ++n4 < e2; ) {
          var u3 = t[n4];
          r3[u3[0]] = u3[1];
        }
        return r3;
      }
      function Ku(t) {
        return t && t.length ? t[0] : i3;
      }
      function Fh(t, n4, e2) {
        var r3 = t == null ? 0 : t.length;
        if (!r3) return -1;
        var u3 = e2 == null ? 0 : T3(e2);
        return u3 < 0 && (u3 = Q2(r3 + u3, 0)), Ln(t, n4, u3);
      }
      function Wh(t) {
        var n4 = t == null ? 0 : t.length;
        return n4 ? At2(t, 0, -1) : [];
      }
      var Mh2 = H(function(t) {
        var n4 = z4(t, oi2);
        return n4.length && n4[0] === t[0] ? kr2(n4) : [];
      }), Bh = H(function(t) {
        var n4 = It2(t), e2 = z4(t, oi2);
        return n4 === It2(e2) ? n4 = i3 : e2.pop(), e2.length && e2[0] === t[0] ? kr2(e2, E4(n4, 2)) : [];
      }), Gh = H(function(t) {
        var n4 = It2(t), e2 = z4(t, oi2);
        return n4 = typeof n4 == "function" ? n4 : i3, n4 && e2.pop(), e2.length && e2[0] === t[0] ? kr2(e2, i3, n4) : [];
      });
      function zh(t, n4) {
        return t == null ? "" : Wf.call(t, n4);
      }
      function It2(t) {
        var n4 = t == null ? 0 : t.length;
        return n4 ? t[n4 - 1] : i3;
      }
      function Kh(t, n4, e2) {
        var r3 = t == null ? 0 : t.length;
        if (!r3) return -1;
        var u3 = r3;
        return e2 !== i3 && (u3 = T3(e2), u3 = u3 < 0 ? Q2(r3 + u3, 0) : nt3(u3, r3 - 1)), n4 === n4 ? xf(t, n4, u3) : Oe(t, Es3, u3, true);
      }
      function Jh(t, n4) {
        return t && t.length ? eu(t, T3(n4)) : i3;
      }
      var Yh = H(Ju2);
      function Ju2(t, n4) {
        return t && t.length && n4 && n4.length ? ei2(t, n4) : t;
      }
      function Zh(t, n4, e2) {
        return t && t.length && n4 && n4.length ? ei2(t, n4, E4(e2, 2)) : t;
      }
      function Xh(t, n4, e2) {
        return t && t.length && n4 && n4.length ? ei2(t, n4, i3, e2) : t;
      }
      var Qh = Zt3(function(t, n4) {
        var e2 = t == null ? 0 : t.length, r3 = Zr2(t, n4);
        return su(t, z4(n4, function(u3) {
          return Xt2(u3, e2) ? +u3 : u3;
        }).sort(gu)), r3;
      });
      function Vh(t, n4) {
        var e2 = [];
        if (!(t && t.length)) return e2;
        var r3 = -1, u3 = [], o5 = t.length;
        for (n4 = E4(n4, 3); ++r3 < o5; ) {
          var f4 = t[r3];
          n4(f4, r3, t) && (e2.push(f4), u3.push(r3));
        }
        return su(t, u3), e2;
      }
      function Ai(t) {
        return t == null ? t : zf.call(t);
      }
      function kh(t, n4, e2) {
        var r3 = t == null ? 0 : t.length;
        return r3 ? (e2 && typeof e2 != "number" && it3(t, n4, e2) ? (n4 = 0, e2 = r3) : (n4 = n4 == null ? 0 : T3(n4), e2 = e2 === i3 ? r3 : T3(e2)), At2(t, n4, e2)) : [];
      }
      function jh(t, n4) {
        return Ze3(t, n4);
      }
      function tl(t, n4, e2) {
        return si2(t, n4, E4(e2, 2));
      }
      function nl(t, n4) {
        var e2 = t == null ? 0 : t.length;
        if (e2) {
          var r3 = Ze3(t, n4);
          if (r3 < e2 && Rt2(t[r3], n4)) return r3;
        }
        return -1;
      }
      function el(t, n4) {
        return Ze3(t, n4, true);
      }
      function rl(t, n4, e2) {
        return si2(t, n4, E4(e2, 2), true);
      }
      function il(t, n4) {
        var e2 = t == null ? 0 : t.length;
        if (e2) {
          var r3 = Ze3(t, n4, true) - 1;
          if (Rt2(t[r3], n4)) return r3;
        }
        return -1;
      }
      function sl(t) {
        return t && t.length ? au(t) : [];
      }
      function ul(t, n4) {
        return t && t.length ? au(t, E4(n4, 2)) : [];
      }
      function al(t) {
        var n4 = t == null ? 0 : t.length;
        return n4 ? At2(t, 1, n4) : [];
      }
      function ol(t, n4, e2) {
        return t && t.length ? (n4 = e2 || n4 === i3 ? 1 : T3(n4), At2(t, 0, n4 < 0 ? 0 : n4)) : [];
      }
      function fl(t, n4, e2) {
        var r3 = t == null ? 0 : t.length;
        return r3 ? (n4 = e2 || n4 === i3 ? 1 : T3(n4), n4 = r3 - n4, At2(t, n4 < 0 ? 0 : n4, r3)) : [];
      }
      function cl(t, n4) {
        return t && t.length ? Xe2(t, E4(n4, 3), false, true) : [];
      }
      function hl(t, n4) {
        return t && t.length ? Xe2(t, E4(n4, 3)) : [];
      }
      var ll = H(function(t) {
        return on2(tt3(t, 1, Y, true));
      }), pl = H(function(t) {
        var n4 = It2(t);
        return Y(n4) && (n4 = i3), on2(tt3(t, 1, Y, true), E4(n4, 2));
      }), dl = H(function(t) {
        var n4 = It2(t);
        return n4 = typeof n4 == "function" ? n4 : i3, on2(tt3(t, 1, Y, true), i3, n4);
      });
      function gl(t) {
        return t && t.length ? on2(t) : [];
      }
      function vl(t, n4) {
        return t && t.length ? on2(t, E4(n4, 2)) : [];
      }
      function _l(t, n4) {
        return n4 = typeof n4 == "function" ? n4 : i3, t && t.length ? on2(t, i3, n4) : [];
      }
      function Ii(t) {
        if (!(t && t.length)) return [];
        var n4 = 0;
        return t = en2(t, function(e2) {
          if (Y(e2)) return n4 = Q2(e2.length, n4), true;
        }), Wr3(n4, function(e2) {
          return z4(t, qr2(e2));
        });
      }
      function Yu2(t, n4) {
        if (!(t && t.length)) return [];
        var e2 = Ii(t);
        return n4 == null ? e2 : z4(e2, function(r3) {
          return ct3(n4, i3, r3);
        });
      }
      var ml = H(function(t, n4) {
        return Y(t) ? oe3(t, n4) : [];
      }), wl = H(function(t) {
        return ai2(en2(t, Y));
      }), Pl = H(function(t) {
        var n4 = It2(t);
        return Y(n4) && (n4 = i3), ai2(en2(t, Y), E4(n4, 2));
      }), Cl = H(function(t) {
        var n4 = It2(t);
        return n4 = typeof n4 == "function" ? n4 : i3, ai2(en2(t, Y), i3, n4);
      }), Al = H(Ii);
      function Il(t, n4) {
        return hu(t || [], n4 || [], ae3);
      }
      function xl(t, n4) {
        return hu(t || [], n4 || [], he);
      }
      var El = H(function(t) {
        var n4 = t.length, e2 = n4 > 1 ? t[n4 - 1] : i3;
        return e2 = typeof e2 == "function" ? (t.pop(), e2) : i3, Yu2(t, e2);
      });
      function Zu(t) {
        var n4 = a4(t);
        return n4.__chain__ = true, n4;
      }
      function yl(t, n4) {
        return n4(t), t;
      }
      function ir2(t, n4) {
        return n4(t);
      }
      var Sl = Zt3(function(t) {
        var n4 = t.length, e2 = n4 ? t[0] : 0, r3 = this.__wrapped__, u3 = function(o5) {
          return Zr2(o5, t);
        };
        return n4 > 1 || this.__actions__.length || !(r3 instanceof N2) || !Xt2(e2) ? this.thru(u3) : (r3 = r3.slice(e2, +e2 + (n4 ? 1 : 0)), r3.__actions__.push({ func: ir2, args: [u3], thisArg: i3 }), new Pt2(r3, this.__chain__).thru(function(o5) {
          return n4 && !o5.length && o5.push(i3), o5;
        }));
      });
      function Ol() {
        return Zu(this);
      }
      function Rl() {
        return new Pt2(this.value(), this.__chain__);
      }
      function bl() {
        this.__values__ === i3 && (this.__values__ = oa(this.value()));
        var t = this.__index__ >= this.__values__.length, n4 = t ? i3 : this.__values__[this.__index__++];
        return { done: t, value: n4 };
      }
      function Tl() {
        return this;
      }
      function Ll(t) {
        for (var n4, e2 = this; e2 instanceof Ge; ) {
          var r3 = Mu2(e2);
          r3.__index__ = 0, r3.__values__ = i3, n4 ? u3.__wrapped__ = r3 : n4 = r3;
          var u3 = r3;
          e2 = e2.__wrapped__;
        }
        return u3.__wrapped__ = t, n4;
      }
      function Hl() {
        var t = this.__wrapped__;
        if (t instanceof N2) {
          var n4 = t;
          return this.__actions__.length && (n4 = new N2(this)), n4 = n4.reverse(), n4.__actions__.push({ func: ir2, args: [Ai], thisArg: i3 }), new Pt2(n4, this.__chain__);
        }
        return this.thru(Ai);
      }
      function Dl() {
        return cu2(this.__wrapped__, this.__actions__);
      }
      var Nl = Qe2(function(t, n4, e2) {
        W2.call(t, e2) ? ++t[e2] : Jt2(t, e2, 1);
      });
      function $l(t, n4, e2) {
        var r3 = b3(t) ? Is3 : yc;
        return e2 && it3(t, n4, e2) && (n4 = i3), r3(t, E4(n4, 3));
      }
      function ql(t, n4) {
        var e2 = b3(t) ? en2 : Ys2;
        return e2(t, E4(n4, 3));
      }
      var Ul = Cu2(Bu2), Fl = Cu2(Gu2);
      function Wl(t, n4) {
        return tt3(sr2(t, n4), 1);
      }
      function Ml(t, n4) {
        return tt3(sr2(t, n4), pn2);
      }
      function Bl(t, n4, e2) {
        return e2 = e2 === i3 ? 1 : T3(e2), tt3(sr2(t, n4), e2);
      }
      function Xu(t, n4) {
        var e2 = b3(t) ? mt2 : an2;
        return e2(t, E4(n4, 3));
      }
      function Qu(t, n4) {
        var e2 = b3(t) ? af : Js2;
        return e2(t, E4(n4, 3));
      }
      var Gl = Qe2(function(t, n4, e2) {
        W2.call(t, e2) ? t[e2].push(n4) : Jt2(t, e2, [n4]);
      });
      function zl(t, n4, e2, r3) {
        t = at3(t) ? t : zn(t), e2 = e2 && !r3 ? T3(e2) : 0;
        var u3 = t.length;
        return e2 < 0 && (e2 = Q2(u3 + e2, 0)), cr2(t) ? e2 <= u3 && t.indexOf(n4, e2) > -1 : !!u3 && Ln(t, n4, e2) > -1;
      }
      var Kl = H(function(t, n4, e2) {
        var r3 = -1, u3 = typeof n4 == "function", o5 = at3(t) ? d3(t.length) : [];
        return an2(t, function(f4) {
          o5[++r3] = u3 ? ct3(n4, f4, e2) : fe2(f4, n4, e2);
        }), o5;
      }), Jl = Qe2(function(t, n4, e2) {
        Jt2(t, e2, n4);
      });
      function sr2(t, n4) {
        var e2 = b3(t) ? z4 : js2;
        return e2(t, E4(n4, 3));
      }
      function Yl(t, n4, e2, r3) {
        return t == null ? [] : (b3(n4) || (n4 = n4 == null ? [] : [n4]), e2 = r3 ? i3 : e2, b3(e2) || (e2 = e2 == null ? [] : [e2]), ru(t, n4, e2));
      }
      var Zl = Qe2(function(t, n4, e2) {
        t[e2 ? 0 : 1].push(n4);
      }, function() {
        return [[], []];
      });
      function Xl(t, n4, e2) {
        var r3 = b3(t) ? Nr2 : Ss3, u3 = arguments.length < 3;
        return r3(t, E4(n4, 4), e2, u3, an2);
      }
      function Ql(t, n4, e2) {
        var r3 = b3(t) ? of : Ss3, u3 = arguments.length < 3;
        return r3(t, E4(n4, 4), e2, u3, Js2);
      }
      function Vl(t, n4) {
        var e2 = b3(t) ? en2 : Ys2;
        return e2(t, or2(E4(n4, 3)));
      }
      function kl(t) {
        var n4 = b3(t) ? Bs2 : zc;
        return n4(t);
      }
      function jl(t, n4, e2) {
        (e2 ? it3(t, n4, e2) : n4 === i3) ? n4 = 1 : n4 = T3(n4);
        var r3 = b3(t) ? Cc : Kc;
        return r3(t, n4);
      }
      function tp(t) {
        var n4 = b3(t) ? Ac : Yc;
        return n4(t);
      }
      function np(t) {
        if (t == null) return 0;
        if (at3(t)) return cr2(t) ? Dn2(t) : t.length;
        var n4 = et3(t);
        return n4 == Et2 || n4 == yt3 ? t.size : ti2(t).length;
      }
      function ep(t, n4, e2) {
        var r3 = b3(t) ? $r2 : Zc;
        return e2 && it3(t, n4, e2) && (n4 = i3), r3(t, E4(n4, 3));
      }
      var rp = H(function(t, n4) {
        if (t == null) return [];
        var e2 = n4.length;
        return e2 > 1 && it3(t, n4[0], n4[1]) ? n4 = [] : e2 > 2 && it3(n4[0], n4[1], n4[2]) && (n4 = [n4[0]]), ru(t, tt3(n4, 1), []);
      }), ur2 = qf || function() {
        return j4.Date.now();
      };
      function ip(t, n4) {
        if (typeof n4 != "function") throw new wt2(O4);
        return t = T3(t), function() {
          if (--t < 1) return n4.apply(this, arguments);
        };
      }
      function Vu(t, n4, e2) {
        return n4 = e2 ? i3 : n4, n4 = t && n4 == null ? t.length : n4, Yt3(t, Bt2, i3, i3, i3, i3, n4);
      }
      function ku2(t, n4) {
        var e2;
        if (typeof n4 != "function") throw new wt2(O4);
        return t = T3(t), function() {
          return --t > 0 && (e2 = n4.apply(this, arguments)), t <= 1 && (n4 = i3), e2;
        };
      }
      var xi = H(function(t, n4, e2) {
        var r3 = vt2;
        if (e2.length) {
          var u3 = sn2(e2, Bn(xi));
          r3 |= Nt2;
        }
        return Yt3(t, r3, n4, e2, u3);
      }), ju = H(function(t, n4, e2) {
        var r3 = vt2 | ln2;
        if (e2.length) {
          var u3 = sn2(e2, Bn(ju));
          r3 |= Nt2;
        }
        return Yt3(n4, r3, t, e2, u3);
      });
      function ta(t, n4, e2) {
        n4 = e2 ? i3 : n4;
        var r3 = Yt3(t, Dt2, i3, i3, i3, i3, i3, n4);
        return r3.placeholder = ta.placeholder, r3;
      }
      function na(t, n4, e2) {
        n4 = e2 ? i3 : n4;
        var r3 = Yt3(t, Sn2, i3, i3, i3, i3, i3, n4);
        return r3.placeholder = na.placeholder, r3;
      }
      function ea(t, n4, e2) {
        var r3, u3, o5, f4, c5, l4, v4 = 0, _2 = false, m2 = false, C2 = true;
        if (typeof t != "function") throw new wt2(O4);
        n4 = xt2(n4) || 0, K3(e2) && (_2 = !!e2.leading, m2 = "maxWait" in e2, o5 = m2 ? Q2(xt2(e2.maxWait) || 0, n4) : o5, C2 = "trailing" in e2 ? !!e2.trailing : C2);
        function I3(Z2) {
          var bt2 = r3, kt2 = u3;
          return r3 = u3 = i3, v4 = Z2, f4 = t.apply(kt2, bt2), f4;
        }
        function y6(Z2) {
          return v4 = Z2, c5 = de(D2, n4), _2 ? I3(Z2) : f4;
        }
        function L3(Z2) {
          var bt2 = Z2 - l4, kt2 = Z2 - v4, Ca = n4 - bt2;
          return m2 ? nt3(Ca, o5 - kt2) : Ca;
        }
        function S3(Z2) {
          var bt2 = Z2 - l4, kt2 = Z2 - v4;
          return l4 === i3 || bt2 >= n4 || bt2 < 0 || m2 && kt2 >= o5;
        }
        function D2() {
          var Z2 = ur2();
          if (S3(Z2)) return $3(Z2);
          c5 = de(D2, L3(Z2));
        }
        function $3(Z2) {
          return c5 = i3, C2 && r3 ? I3(Z2) : (r3 = u3 = i3, f4);
        }
        function dt3() {
          c5 !== i3 && lu2(c5), v4 = 0, r3 = l4 = u3 = c5 = i3;
        }
        function st3() {
          return c5 === i3 ? f4 : $3(ur2());
        }
        function gt3() {
          var Z2 = ur2(), bt2 = S3(Z2);
          if (r3 = arguments, u3 = this, l4 = Z2, bt2) {
            if (c5 === i3) return y6(l4);
            if (m2) return lu2(c5), c5 = de(D2, n4), I3(l4);
          }
          return c5 === i3 && (c5 = de(D2, n4)), f4;
        }
        return gt3.cancel = dt3, gt3.flush = st3, gt3;
      }
      var sp = H(function(t, n4) {
        return Ks2(t, 1, n4);
      }), up = H(function(t, n4, e2) {
        return Ks2(t, xt2(n4) || 0, e2);
      });
      function ap(t) {
        return Yt3(t, gr3);
      }
      function ar2(t, n4) {
        if (typeof t != "function" || n4 != null && typeof n4 != "function") throw new wt2(O4);
        var e2 = function() {
          var r3 = arguments, u3 = n4 ? n4.apply(this, r3) : r3[0], o5 = e2.cache;
          if (o5.has(u3)) return o5.get(u3);
          var f4 = t.apply(this, r3);
          return e2.cache = o5.set(u3, f4) || o5, f4;
        };
        return e2.cache = new (ar2.Cache || Kt2)(), e2;
      }
      ar2.Cache = Kt2;
      function or2(t) {
        if (typeof t != "function") throw new wt2(O4);
        return function() {
          var n4 = arguments;
          switch (n4.length) {
            case 0:
              return !t.call(this);
            case 1:
              return !t.call(this, n4[0]);
            case 2:
              return !t.call(this, n4[0], n4[1]);
            case 3:
              return !t.call(this, n4[0], n4[1], n4[2]);
          }
          return !t.apply(this, n4);
        };
      }
      function op(t) {
        return ku2(2, t);
      }
      var fp = Xc(function(t, n4) {
        n4 = n4.length == 1 && b3(n4[0]) ? z4(n4[0], ht3(E4())) : z4(tt3(n4, 1), ht3(E4()));
        var e2 = n4.length;
        return H(function(r3) {
          for (var u3 = -1, o5 = nt3(r3.length, e2); ++u3 < o5; ) r3[u3] = n4[u3].call(this, r3[u3]);
          return ct3(t, this, r3);
        });
      }), Ei = H(function(t, n4) {
        var e2 = sn2(n4, Bn(Ei));
        return Yt3(t, Nt2, i3, n4, e2);
      }), ra = H(function(t, n4) {
        var e2 = sn2(n4, Bn(ra));
        return Yt3(t, On, i3, n4, e2);
      }), cp = Zt3(function(t, n4) {
        return Yt3(t, Yn, i3, i3, i3, n4);
      });
      function hp(t, n4) {
        if (typeof t != "function") throw new wt2(O4);
        return n4 = n4 === i3 ? n4 : T3(n4), H(t, n4);
      }
      function lp(t, n4) {
        if (typeof t != "function") throw new wt2(O4);
        return n4 = n4 == null ? 0 : Q2(T3(n4), 0), H(function(e2) {
          var r3 = e2[n4], u3 = cn2(e2, 0, n4);
          return r3 && rn2(u3, r3), ct3(t, this, u3);
        });
      }
      function pp(t, n4, e2) {
        var r3 = true, u3 = true;
        if (typeof t != "function") throw new wt2(O4);
        return K3(e2) && (r3 = "leading" in e2 ? !!e2.leading : r3, u3 = "trailing" in e2 ? !!e2.trailing : u3), ea(t, n4, { leading: r3, maxWait: n4, trailing: u3 });
      }
      function dp(t) {
        return Vu(t, 1);
      }
      function gp(t, n4) {
        return Ei(fi(n4), t);
      }
      function vp() {
        if (!arguments.length) return [];
        var t = arguments[0];
        return b3(t) ? t : [t];
      }
      function _p(t) {
        return Ct2(t, En2);
      }
      function mp(t, n4) {
        return n4 = typeof n4 == "function" ? n4 : i3, Ct2(t, En2, n4);
      }
      function wp(t) {
        return Ct2(t, Ht2 | En2);
      }
      function Pp(t, n4) {
        return n4 = typeof n4 == "function" ? n4 : i3, Ct2(t, Ht2 | En2, n4);
      }
      function Cp(t, n4) {
        return n4 == null || zs2(t, n4, V3(n4));
      }
      function Rt2(t, n4) {
        return t === n4 || t !== t && n4 !== n4;
      }
      var Ap = tr2(Vr2), Ip = tr2(function(t, n4) {
        return t >= n4;
      }), An = Qs2(/* @__PURE__ */ function() {
        return arguments;
      }()) ? Qs2 : function(t) {
        return J(t) && W2.call(t, "callee") && !$s2.call(t, "callee");
      }, b3 = d3.isArray, xp = _s3 ? ht3(_s3) : Lc;
      function at3(t) {
        return t != null && fr2(t.length) && !Qt2(t);
      }
      function Y(t) {
        return J(t) && at3(t);
      }
      function Ep(t) {
        return t === true || t === false || J(t) && rt3(t) == Zn;
      }
      var hn2 = Ff || $i2, yp = ms4 ? ht3(ms4) : Hc;
      function Sp(t) {
        return J(t) && t.nodeType === 1 && !ge(t);
      }
      function Op(t) {
        if (t == null) return true;
        if (at3(t) && (b3(t) || typeof t == "string" || typeof t.splice == "function" || hn2(t) || Gn(t) || An(t))) return !t.length;
        var n4 = et3(t);
        if (n4 == Et2 || n4 == yt3) return !t.size;
        if (pe(t)) return !ti2(t).length;
        for (var e2 in t) if (W2.call(t, e2)) return false;
        return true;
      }
      function Rp(t, n4) {
        return ce(t, n4);
      }
      function bp(t, n4, e2) {
        e2 = typeof e2 == "function" ? e2 : i3;
        var r3 = e2 ? e2(t, n4) : i3;
        return r3 === i3 ? ce(t, n4, i3, e2) : !!r3;
      }
      function yi2(t) {
        if (!J(t)) return false;
        var n4 = rt3(t);
        return n4 == Ce3 || n4 == Va || typeof t.message == "string" && typeof t.name == "string" && !ge(t);
      }
      function Tp(t) {
        return typeof t == "number" && Us2(t);
      }
      function Qt2(t) {
        if (!K3(t)) return false;
        var n4 = rt3(t);
        return n4 == Ae || n4 == Ki || n4 == Qa || n4 == ja;
      }
      function ia(t) {
        return typeof t == "number" && t == T3(t);
      }
      function fr2(t) {
        return typeof t == "number" && t > -1 && t % 1 == 0 && t <= nn2;
      }
      function K3(t) {
        var n4 = typeof t;
        return t != null && (n4 == "object" || n4 == "function");
      }
      function J(t) {
        return t != null && typeof t == "object";
      }
      var sa = ws4 ? ht3(ws4) : Nc;
      function Lp(t, n4) {
        return t === n4 || jr(t, n4, vi(n4));
      }
      function Hp(t, n4, e2) {
        return e2 = typeof e2 == "function" ? e2 : i3, jr(t, n4, vi(n4), e2);
      }
      function Dp(t) {
        return ua(t) && t != +t;
      }
      function Np(t) {
        if (mh2(t)) throw new R2(x3);
        return Vs2(t);
      }
      function $p(t) {
        return t === null;
      }
      function qp(t) {
        return t == null;
      }
      function ua(t) {
        return typeof t == "number" || J(t) && rt3(t) == Qn;
      }
      function ge(t) {
        if (!J(t) || rt3(t) != Gt2) return false;
        var n4 = $e2(t);
        if (n4 === null) return true;
        var e2 = W2.call(n4, "constructor") && n4.constructor;
        return typeof e2 == "function" && e2 instanceof e2 && Le2.call(e2) == Hf;
      }
      var Si = Ps2 ? ht3(Ps2) : $c;
      function Up(t) {
        return ia(t) && t >= -nn2 && t <= nn2;
      }
      var aa = Cs2 ? ht3(Cs2) : qc;
      function cr2(t) {
        return typeof t == "string" || !b3(t) && J(t) && rt3(t) == kn;
      }
      function pt3(t) {
        return typeof t == "symbol" || J(t) && rt3(t) == Ie2;
      }
      var Gn = As3 ? ht3(As3) : Uc;
      function Fp(t) {
        return t === i3;
      }
      function Wp(t) {
        return J(t) && et3(t) == jn;
      }
      function Mp(t) {
        return J(t) && rt3(t) == no;
      }
      var Bp = tr2(ni2), Gp = tr2(function(t, n4) {
        return t <= n4;
      });
      function oa(t) {
        if (!t) return [];
        if (at3(t)) return cr2(t) ? St2(t) : ut3(t);
        if (ee2 && t[ee2]) return Cf(t[ee2]());
        var n4 = et3(t), e2 = n4 == Et2 ? Br : n4 == yt3 ? Re : zn;
        return e2(t);
      }
      function Vt2(t) {
        if (!t) return t === 0 ? t : 0;
        if (t = xt2(t), t === pn2 || t === -pn2) {
          var n4 = t < 0 ? -1 : 1;
          return n4 * Ja;
        }
        return t === t ? t : 0;
      }
      function T3(t) {
        var n4 = Vt2(t), e2 = n4 % 1;
        return n4 === n4 ? e2 ? n4 - e2 : n4 : 0;
      }
      function fa(t) {
        return t ? mn3(T3(t), 0, $t2) : 0;
      }
      function xt2(t) {
        if (typeof t == "number") return t;
        if (pt3(t)) return we3;
        if (K3(t)) {
          var n4 = typeof t.valueOf == "function" ? t.valueOf() : t;
          t = K3(n4) ? n4 + "" : n4;
        }
        if (typeof t != "string") return t === 0 ? t : +t;
        t = Os2(t);
        var e2 = Io.test(t);
        return e2 || Eo.test(t) ? rf(t.slice(2), e2 ? 2 : 8) : Ao2.test(t) ? we3 : +t;
      }
      function ca(t) {
        return Ut2(t, ot3(t));
      }
      function zp(t) {
        return t ? mn3(T3(t), -nn2, nn2) : t === 0 ? t : 0;
      }
      function U3(t) {
        return t == null ? "" : lt3(t);
      }
      var Kp = Wn(function(t, n4) {
        if (pe(n4) || at3(n4)) {
          Ut2(n4, V3(n4), t);
          return;
        }
        for (var e2 in n4) W2.call(n4, e2) && ae3(t, e2, n4[e2]);
      }), ha = Wn(function(t, n4) {
        Ut2(n4, ot3(n4), t);
      }), hr2 = Wn(function(t, n4, e2, r3) {
        Ut2(n4, ot3(n4), t, r3);
      }), Jp = Wn(function(t, n4, e2, r3) {
        Ut2(n4, V3(n4), t, r3);
      }), Yp = Zt3(Zr2);
      function Zp(t, n4) {
        var e2 = Fn(t);
        return n4 == null ? e2 : Gs2(e2, n4);
      }
      var Xp = H(function(t, n4) {
        t = M2(t);
        var e2 = -1, r3 = n4.length, u3 = r3 > 2 ? n4[2] : i3;
        for (u3 && it3(n4[0], n4[1], u3) && (r3 = 1); ++e2 < r3; ) for (var o5 = n4[e2], f4 = ot3(o5), c5 = -1, l4 = f4.length; ++c5 < l4; ) {
          var v4 = f4[c5], _2 = t[v4];
          (_2 === i3 || Rt2(_2, $n[v4]) && !W2.call(t, v4)) && (t[v4] = o5[v4]);
        }
        return t;
      }), Qp = H(function(t) {
        return t.push(i3, Ou2), ct3(la, i3, t);
      });
      function Vp(t, n4) {
        return xs3(t, E4(n4, 3), qt2);
      }
      function kp(t, n4) {
        return xs3(t, E4(n4, 3), Qr2);
      }
      function jp(t, n4) {
        return t == null ? t : Xr3(t, E4(n4, 3), ot3);
      }
      function td(t, n4) {
        return t == null ? t : Zs2(t, E4(n4, 3), ot3);
      }
      function nd(t, n4) {
        return t && qt2(t, E4(n4, 3));
      }
      function ed(t, n4) {
        return t && Qr2(t, E4(n4, 3));
      }
      function rd(t) {
        return t == null ? [] : Je2(t, V3(t));
      }
      function id(t) {
        return t == null ? [] : Je2(t, ot3(t));
      }
      function Oi(t, n4, e2) {
        var r3 = t == null ? i3 : wn2(t, n4);
        return r3 === i3 ? e2 : r3;
      }
      function sd(t, n4) {
        return t != null && Tu(t, n4, Oc);
      }
      function Ri(t, n4) {
        return t != null && Tu(t, n4, Rc);
      }
      var ud = Iu2(function(t, n4, e2) {
        n4 != null && typeof n4.toString != "function" && (n4 = He.call(n4)), t[n4] = e2;
      }, Ti(ft2)), ad = Iu2(function(t, n4, e2) {
        n4 != null && typeof n4.toString != "function" && (n4 = He.call(n4)), W2.call(t, n4) ? t[n4].push(e2) : t[n4] = [e2];
      }, E4), od = H(fe2);
      function V3(t) {
        return at3(t) ? Ms3(t) : ti2(t);
      }
      function ot3(t) {
        return at3(t) ? Ms3(t, true) : Fc(t);
      }
      function fd(t, n4) {
        var e2 = {};
        return n4 = E4(n4, 3), qt2(t, function(r3, u3, o5) {
          Jt2(e2, n4(r3, u3, o5), r3);
        }), e2;
      }
      function cd(t, n4) {
        var e2 = {};
        return n4 = E4(n4, 3), qt2(t, function(r3, u3, o5) {
          Jt2(e2, u3, n4(r3, u3, o5));
        }), e2;
      }
      var hd = Wn(function(t, n4, e2) {
        Ye2(t, n4, e2);
      }), la = Wn(function(t, n4, e2, r3) {
        Ye2(t, n4, e2, r3);
      }), ld = Zt3(function(t, n4) {
        var e2 = {};
        if (t == null) return e2;
        var r3 = false;
        n4 = z4(n4, function(o5) {
          return o5 = fn3(o5, t), r3 || (r3 = o5.length > 1), o5;
        }), Ut2(t, di2(t), e2), r3 && (e2 = Ct2(e2, Ht2 | Mt2 | En2, uh2));
        for (var u3 = n4.length; u3--; ) ui2(e2, n4[u3]);
        return e2;
      });
      function pd(t, n4) {
        return pa(t, or2(E4(n4)));
      }
      var dd = Zt3(function(t, n4) {
        return t == null ? {} : Mc(t, n4);
      });
      function pa(t, n4) {
        if (t == null) return {};
        var e2 = z4(di2(t), function(r3) {
          return [r3];
        });
        return n4 = E4(n4), iu(t, e2, function(r3, u3) {
          return n4(r3, u3[0]);
        });
      }
      function gd(t, n4, e2) {
        n4 = fn3(n4, t);
        var r3 = -1, u3 = n4.length;
        for (u3 || (u3 = 1, t = i3); ++r3 < u3; ) {
          var o5 = t == null ? i3 : t[Ft2(n4[r3])];
          o5 === i3 && (r3 = u3, o5 = e2), t = Qt2(o5) ? o5.call(t) : o5;
        }
        return t;
      }
      function vd(t, n4, e2) {
        return t == null ? t : he(t, n4, e2);
      }
      function _d(t, n4, e2, r3) {
        return r3 = typeof r3 == "function" ? r3 : i3, t == null ? t : he(t, n4, e2, r3);
      }
      var da = yu2(V3), ga = yu2(ot3);
      function md(t, n4, e2) {
        var r3 = b3(t), u3 = r3 || hn2(t) || Gn(t);
        if (n4 = E4(n4, 4), e2 == null) {
          var o5 = t && t.constructor;
          u3 ? e2 = r3 ? new o5() : [] : K3(t) ? e2 = Qt2(o5) ? Fn($e2(t)) : {} : e2 = {};
        }
        return (u3 ? mt2 : qt2)(t, function(f4, c5, l4) {
          return n4(e2, f4, c5, l4);
        }), e2;
      }
      function wd(t, n4) {
        return t == null ? true : ui2(t, n4);
      }
      function Pd(t, n4, e2) {
        return t == null ? t : fu(t, n4, fi(e2));
      }
      function Cd(t, n4, e2, r3) {
        return r3 = typeof r3 == "function" ? r3 : i3, t == null ? t : fu(t, n4, fi(e2), r3);
      }
      function zn(t) {
        return t == null ? [] : Mr2(t, V3(t));
      }
      function Ad(t) {
        return t == null ? [] : Mr2(t, ot3(t));
      }
      function Id(t, n4, e2) {
        return e2 === i3 && (e2 = n4, n4 = i3), e2 !== i3 && (e2 = xt2(e2), e2 = e2 === e2 ? e2 : 0), n4 !== i3 && (n4 = xt2(n4), n4 = n4 === n4 ? n4 : 0), mn3(xt2(t), n4, e2);
      }
      function xd(t, n4, e2) {
        return n4 = Vt2(n4), e2 === i3 ? (e2 = n4, n4 = 0) : e2 = Vt2(e2), t = xt2(t), bc(t, n4, e2);
      }
      function Ed(t, n4, e2) {
        if (e2 && typeof e2 != "boolean" && it3(t, n4, e2) && (n4 = e2 = i3), e2 === i3 && (typeof n4 == "boolean" ? (e2 = n4, n4 = i3) : typeof t == "boolean" && (e2 = t, t = i3)), t === i3 && n4 === i3 ? (t = 0, n4 = 1) : (t = Vt2(t), n4 === i3 ? (n4 = t, t = 0) : n4 = Vt2(n4)), t > n4) {
          var r3 = t;
          t = n4, n4 = r3;
        }
        if (e2 || t % 1 || n4 % 1) {
          var u3 = Fs2();
          return nt3(t + u3 * (n4 - t + ef("1e-" + ((u3 + "").length - 1))), n4);
        }
        return ri2(t, n4);
      }
      var yd = Mn(function(t, n4, e2) {
        return n4 = n4.toLowerCase(), t + (e2 ? va(n4) : n4);
      });
      function va(t) {
        return bi2(U3(t).toLowerCase());
      }
      function _a(t) {
        return t = U3(t), t && t.replace(So, vf).replace(Jo, "");
      }
      function Sd(t, n4, e2) {
        t = U3(t), n4 = lt3(n4);
        var r3 = t.length;
        e2 = e2 === i3 ? r3 : mn3(T3(e2), 0, r3);
        var u3 = e2;
        return e2 -= n4.length, e2 >= 0 && t.slice(e2, u3) == n4;
      }
      function Od(t) {
        return t = U3(t), t && uo.test(t) ? t.replace(Zi, _f) : t;
      }
      function Rd(t) {
        return t = U3(t), t && lo.test(t) ? t.replace(Er2, "\\$&") : t;
      }
      var bd = Mn(function(t, n4, e2) {
        return t + (e2 ? "-" : "") + n4.toLowerCase();
      }), Td = Mn(function(t, n4, e2) {
        return t + (e2 ? " " : "") + n4.toLowerCase();
      }), Ld = Pu2("toLowerCase");
      function Hd(t, n4, e2) {
        t = U3(t), n4 = T3(n4);
        var r3 = n4 ? Dn2(t) : 0;
        if (!n4 || r3 >= n4) return t;
        var u3 = (n4 - r3) / 2;
        return je(We2(u3), e2) + t + je(Fe(u3), e2);
      }
      function Dd(t, n4, e2) {
        t = U3(t), n4 = T3(n4);
        var r3 = n4 ? Dn2(t) : 0;
        return n4 && r3 < n4 ? t + je(n4 - r3, e2) : t;
      }
      function Nd(t, n4, e2) {
        t = U3(t), n4 = T3(n4);
        var r3 = n4 ? Dn2(t) : 0;
        return n4 && r3 < n4 ? je(n4 - r3, e2) + t : t;
      }
      function $d(t, n4, e2) {
        return e2 || n4 == null ? n4 = 0 : n4 && (n4 = +n4), Gf(U3(t).replace(yr2, ""), n4 || 0);
      }
      function qd(t, n4, e2) {
        return (e2 ? it3(t, n4, e2) : n4 === i3) ? n4 = 1 : n4 = T3(n4), ii2(U3(t), n4);
      }
      function Ud() {
        var t = arguments, n4 = U3(t[0]);
        return t.length < 3 ? n4 : n4.replace(t[1], t[2]);
      }
      var Fd = Mn(function(t, n4, e2) {
        return t + (e2 ? "_" : "") + n4.toLowerCase();
      });
      function Wd(t, n4, e2) {
        return e2 && typeof e2 != "number" && it3(t, n4, e2) && (n4 = e2 = i3), e2 = e2 === i3 ? $t2 : e2 >>> 0, e2 ? (t = U3(t), t && (typeof n4 == "string" || n4 != null && !Si(n4)) && (n4 = lt3(n4), !n4 && Hn(t)) ? cn2(St2(t), 0, e2) : t.split(n4, e2)) : [];
      }
      var Md = Mn(function(t, n4, e2) {
        return t + (e2 ? " " : "") + bi2(n4);
      });
      function Bd(t, n4, e2) {
        return t = U3(t), e2 = e2 == null ? 0 : mn3(T3(e2), 0, t.length), n4 = lt3(n4), t.slice(e2, e2 + n4.length) == n4;
      }
      function Gd(t, n4, e2) {
        var r3 = a4.templateSettings;
        e2 && it3(t, n4, e2) && (n4 = i3), t = U3(t), n4 = hr2({}, n4, r3, Su2);
        var u3 = hr2({}, n4.imports, r3.imports, Su2), o5 = V3(u3), f4 = Mr2(u3, o5), c5, l4, v4 = 0, _2 = n4.interpolate || xe2, m2 = "__p += '", C2 = Gr((n4.escape || xe2).source + "|" + _2.source + "|" + (_2 === Xi ? Co2 : xe2).source + "|" + (n4.evaluate || xe2).source + "|$", "g"), I3 = "//# sourceURL=" + (W2.call(n4, "sourceURL") ? (n4.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Vo + "]") + `
`;
        t.replace(C2, function(S3, D2, $3, dt3, st3, gt3) {
          return $3 || ($3 = dt3), m2 += t.slice(v4, gt3).replace(Oo, mf), D2 && (c5 = true, m2 += `' +
__e(` + D2 + `) +
'`), st3 && (l4 = true, m2 += `';
` + st3 + `;
__p += '`), $3 && (m2 += `' +
((__t = (` + $3 + `)) == null ? '' : __t) +
'`), v4 = gt3 + S3.length, S3;
        }), m2 += `';
`;
        var y6 = W2.call(n4, "variable") && n4.variable;
        if (!y6) m2 = `with (obj) {
` + m2 + `
}
`;
        else if (wo.test(y6)) throw new R2(k3);
        m2 = (l4 ? m2.replace(eo, "") : m2).replace(ro, "$1").replace(io2, "$1;"), m2 = "function(" + (y6 || "obj") + `) {
` + (y6 ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (c5 ? ", __e = _.escape" : "") + (l4 ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + m2 + `return __p
}`;
        var L3 = wa(function() {
          return q2(o5, I3 + "return " + m2).apply(i3, f4);
        });
        if (L3.source = m2, yi2(L3)) throw L3;
        return L3;
      }
      function zd(t) {
        return U3(t).toLowerCase();
      }
      function Kd(t) {
        return U3(t).toUpperCase();
      }
      function Jd(t, n4, e2) {
        if (t = U3(t), t && (e2 || n4 === i3)) return Os2(t);
        if (!t || !(n4 = lt3(n4))) return t;
        var r3 = St2(t), u3 = St2(n4), o5 = Rs3(r3, u3), f4 = bs3(r3, u3) + 1;
        return cn2(r3, o5, f4).join("");
      }
      function Yd(t, n4, e2) {
        if (t = U3(t), t && (e2 || n4 === i3)) return t.slice(0, Ls2(t) + 1);
        if (!t || !(n4 = lt3(n4))) return t;
        var r3 = St2(t), u3 = bs3(r3, St2(n4)) + 1;
        return cn2(r3, 0, u3).join("");
      }
      function Zd(t, n4, e2) {
        if (t = U3(t), t && (e2 || n4 === i3)) return t.replace(yr2, "");
        if (!t || !(n4 = lt3(n4))) return t;
        var r3 = St2(t), u3 = Rs3(r3, St2(n4));
        return cn2(r3, u3).join("");
      }
      function Xd(t, n4) {
        var e2 = Wa, r3 = Ma;
        if (K3(n4)) {
          var u3 = "separator" in n4 ? n4.separator : u3;
          e2 = "length" in n4 ? T3(n4.length) : e2, r3 = "omission" in n4 ? lt3(n4.omission) : r3;
        }
        t = U3(t);
        var o5 = t.length;
        if (Hn(t)) {
          var f4 = St2(t);
          o5 = f4.length;
        }
        if (e2 >= o5) return t;
        var c5 = e2 - Dn2(r3);
        if (c5 < 1) return r3;
        var l4 = f4 ? cn2(f4, 0, c5).join("") : t.slice(0, c5);
        if (u3 === i3) return l4 + r3;
        if (f4 && (c5 += l4.length - c5), Si(u3)) {
          if (t.slice(c5).search(u3)) {
            var v4, _2 = l4;
            for (u3.global || (u3 = Gr(u3.source, U3(Qi.exec(u3)) + "g")), u3.lastIndex = 0; v4 = u3.exec(_2); ) var m2 = v4.index;
            l4 = l4.slice(0, m2 === i3 ? c5 : m2);
          }
        } else if (t.indexOf(lt3(u3), c5) != c5) {
          var C2 = l4.lastIndexOf(u3);
          C2 > -1 && (l4 = l4.slice(0, C2));
        }
        return l4 + r3;
      }
      function Qd(t) {
        return t = U3(t), t && so.test(t) ? t.replace(Yi2, Ef) : t;
      }
      var Vd = Mn(function(t, n4, e2) {
        return t + (e2 ? " " : "") + n4.toUpperCase();
      }), bi2 = Pu2("toUpperCase");
      function ma(t, n4, e2) {
        return t = U3(t), n4 = e2 ? i3 : n4, n4 === i3 ? Pf(t) ? Of(t) : hf(t) : t.match(n4) || [];
      }
      var wa = H(function(t, n4) {
        try {
          return ct3(t, i3, n4);
        } catch (e2) {
          return yi2(e2) ? e2 : new R2(e2);
        }
      }), kd = Zt3(function(t, n4) {
        return mt2(n4, function(e2) {
          e2 = Ft2(e2), Jt2(t, e2, xi(t[e2], t));
        }), t;
      });
      function jd(t) {
        var n4 = t == null ? 0 : t.length, e2 = E4();
        return t = n4 ? z4(t, function(r3) {
          if (typeof r3[1] != "function") throw new wt2(O4);
          return [e2(r3[0]), r3[1]];
        }) : [], H(function(r3) {
          for (var u3 = -1; ++u3 < n4; ) {
            var o5 = t[u3];
            if (ct3(o5[0], this, r3)) return ct3(o5[1], this, r3);
          }
        });
      }
      function tg(t) {
        return Ec(Ct2(t, Ht2));
      }
      function Ti(t) {
        return function() {
          return t;
        };
      }
      function ng(t, n4) {
        return t == null || t !== t ? n4 : t;
      }
      var eg = Au2(), rg = Au2(true);
      function ft2(t) {
        return t;
      }
      function Li(t) {
        return ks2(typeof t == "function" ? t : Ct2(t, Ht2));
      }
      function ig(t) {
        return tu(Ct2(t, Ht2));
      }
      function sg(t, n4) {
        return nu(t, Ct2(n4, Ht2));
      }
      var ug = H(function(t, n4) {
        return function(e2) {
          return fe2(e2, t, n4);
        };
      }), ag = H(function(t, n4) {
        return function(e2) {
          return fe2(t, e2, n4);
        };
      });
      function Hi(t, n4, e2) {
        var r3 = V3(n4), u3 = Je2(n4, r3);
        e2 == null && !(K3(n4) && (u3.length || !r3.length)) && (e2 = n4, n4 = t, t = this, u3 = Je2(n4, V3(n4)));
        var o5 = !(K3(e2) && "chain" in e2) || !!e2.chain, f4 = Qt2(t);
        return mt2(u3, function(c5) {
          var l4 = n4[c5];
          t[c5] = l4, f4 && (t.prototype[c5] = function() {
            var v4 = this.__chain__;
            if (o5 || v4) {
              var _2 = t(this.__wrapped__), m2 = _2.__actions__ = ut3(this.__actions__);
              return m2.push({ func: l4, args: arguments, thisArg: t }), _2.__chain__ = v4, _2;
            }
            return l4.apply(t, rn2([this.value()], arguments));
          });
        }), t;
      }
      function og() {
        return j4._ === this && (j4._ = Df), this;
      }
      function Di2() {
      }
      function fg(t) {
        return t = T3(t), H(function(n4) {
          return eu(n4, t);
        });
      }
      var cg = hi2(z4), hg = hi2(Is3), lg = hi2($r2);
      function Pa(t) {
        return mi2(t) ? qr2(Ft2(t)) : Bc(t);
      }
      function pg(t) {
        return function(n4) {
          return t == null ? i3 : wn2(t, n4);
        };
      }
      var dg = xu(), gg = xu(true);
      function Ni() {
        return [];
      }
      function $i2() {
        return false;
      }
      function vg() {
        return {};
      }
      function _g() {
        return "";
      }
      function mg() {
        return true;
      }
      function wg(t, n4) {
        if (t = T3(t), t < 1 || t > nn2) return [];
        var e2 = $t2, r3 = nt3(t, $t2);
        n4 = E4(n4), t -= $t2;
        for (var u3 = Wr3(r3, n4); ++e2 < t; ) n4(e2);
        return u3;
      }
      function Pg(t) {
        return b3(t) ? z4(t, Ft2) : pt3(t) ? [t] : ut3(Wu(U3(t)));
      }
      function Cg(t) {
        var n4 = ++Lf;
        return U3(t) + n4;
      }
      var Ag = ke(function(t, n4) {
        return t + n4;
      }, 0), Ig = li2("ceil"), xg = ke(function(t, n4) {
        return t / n4;
      }, 1), Eg = li2("floor");
      function yg(t) {
        return t && t.length ? Ke2(t, ft2, Vr2) : i3;
      }
      function Sg(t, n4) {
        return t && t.length ? Ke2(t, E4(n4, 2), Vr2) : i3;
      }
      function Og(t) {
        return ys4(t, ft2);
      }
      function Rg(t, n4) {
        return ys4(t, E4(n4, 2));
      }
      function bg(t) {
        return t && t.length ? Ke2(t, ft2, ni2) : i3;
      }
      function Tg(t, n4) {
        return t && t.length ? Ke2(t, E4(n4, 2), ni2) : i3;
      }
      var Lg = ke(function(t, n4) {
        return t * n4;
      }, 1), Hg = li2("round"), Dg = ke(function(t, n4) {
        return t - n4;
      }, 0);
      function Ng(t) {
        return t && t.length ? Fr2(t, ft2) : 0;
      }
      function $g(t, n4) {
        return t && t.length ? Fr2(t, E4(n4, 2)) : 0;
      }
      return a4.after = ip, a4.ary = Vu, a4.assign = Kp, a4.assignIn = ha, a4.assignInWith = hr2, a4.assignWith = Jp, a4.at = Yp, a4.before = ku2, a4.bind = xi, a4.bindAll = kd, a4.bindKey = ju, a4.castArray = vp, a4.chain = Zu, a4.chunk = Eh2, a4.compact = yh2, a4.concat = Sh2, a4.cond = jd, a4.conforms = tg, a4.constant = Ti, a4.countBy = Nl, a4.create = Zp, a4.curry = ta, a4.curryRight = na, a4.debounce = ea, a4.defaults = Xp, a4.defaultsDeep = Qp, a4.defer = sp, a4.delay = up, a4.difference = Oh, a4.differenceBy = Rh, a4.differenceWith = bh2, a4.drop = Th, a4.dropRight = Lh, a4.dropRightWhile = Hh, a4.dropWhile = Dh, a4.fill = Nh2, a4.filter = ql, a4.flatMap = Wl, a4.flatMapDeep = Ml, a4.flatMapDepth = Bl, a4.flatten = zu, a4.flattenDeep = $h, a4.flattenDepth = qh, a4.flip = ap, a4.flow = eg, a4.flowRight = rg, a4.fromPairs = Uh, a4.functions = rd, a4.functionsIn = id, a4.groupBy = Gl, a4.initial = Wh, a4.intersection = Mh2, a4.intersectionBy = Bh, a4.intersectionWith = Gh, a4.invert = ud, a4.invertBy = ad, a4.invokeMap = Kl, a4.iteratee = Li, a4.keyBy = Jl, a4.keys = V3, a4.keysIn = ot3, a4.map = sr2, a4.mapKeys = fd, a4.mapValues = cd, a4.matches = ig, a4.matchesProperty = sg, a4.memoize = ar2, a4.merge = hd, a4.mergeWith = la, a4.method = ug, a4.methodOf = ag, a4.mixin = Hi, a4.negate = or2, a4.nthArg = fg, a4.omit = ld, a4.omitBy = pd, a4.once = op, a4.orderBy = Yl, a4.over = cg, a4.overArgs = fp, a4.overEvery = hg, a4.overSome = lg, a4.partial = Ei, a4.partialRight = ra, a4.partition = Zl, a4.pick = dd, a4.pickBy = pa, a4.property = Pa, a4.propertyOf = pg, a4.pull = Yh, a4.pullAll = Ju2, a4.pullAllBy = Zh, a4.pullAllWith = Xh, a4.pullAt = Qh, a4.range = dg, a4.rangeRight = gg, a4.rearg = cp, a4.reject = Vl, a4.remove = Vh, a4.rest = hp, a4.reverse = Ai, a4.sampleSize = jl, a4.set = vd, a4.setWith = _d, a4.shuffle = tp, a4.slice = kh, a4.sortBy = rp, a4.sortedUniq = sl, a4.sortedUniqBy = ul, a4.split = Wd, a4.spread = lp, a4.tail = al, a4.take = ol, a4.takeRight = fl, a4.takeRightWhile = cl, a4.takeWhile = hl, a4.tap = yl, a4.throttle = pp, a4.thru = ir2, a4.toArray = oa, a4.toPairs = da, a4.toPairsIn = ga, a4.toPath = Pg, a4.toPlainObject = ca, a4.transform = md, a4.unary = dp, a4.union = ll, a4.unionBy = pl, a4.unionWith = dl, a4.uniq = gl, a4.uniqBy = vl, a4.uniqWith = _l, a4.unset = wd, a4.unzip = Ii, a4.unzipWith = Yu2, a4.update = Pd, a4.updateWith = Cd, a4.values = zn, a4.valuesIn = Ad, a4.without = ml, a4.words = ma, a4.wrap = gp, a4.xor = wl, a4.xorBy = Pl, a4.xorWith = Cl, a4.zip = Al, a4.zipObject = Il, a4.zipObjectDeep = xl, a4.zipWith = El, a4.entries = da, a4.entriesIn = ga, a4.extend = ha, a4.extendWith = hr2, Hi(a4, a4), a4.add = Ag, a4.attempt = wa, a4.camelCase = yd, a4.capitalize = va, a4.ceil = Ig, a4.clamp = Id, a4.clone = _p, a4.cloneDeep = wp, a4.cloneDeepWith = Pp, a4.cloneWith = mp, a4.conformsTo = Cp, a4.deburr = _a, a4.defaultTo = ng, a4.divide = xg, a4.endsWith = Sd, a4.eq = Rt2, a4.escape = Od, a4.escapeRegExp = Rd, a4.every = $l, a4.find = Ul, a4.findIndex = Bu2, a4.findKey = Vp, a4.findLast = Fl, a4.findLastIndex = Gu2, a4.findLastKey = kp, a4.floor = Eg, a4.forEach = Xu, a4.forEachRight = Qu, a4.forIn = jp, a4.forInRight = td, a4.forOwn = nd, a4.forOwnRight = ed, a4.get = Oi, a4.gt = Ap, a4.gte = Ip, a4.has = sd, a4.hasIn = Ri, a4.head = Ku, a4.identity = ft2, a4.includes = zl, a4.indexOf = Fh, a4.inRange = xd, a4.invoke = od, a4.isArguments = An, a4.isArray = b3, a4.isArrayBuffer = xp, a4.isArrayLike = at3, a4.isArrayLikeObject = Y, a4.isBoolean = Ep, a4.isBuffer = hn2, a4.isDate = yp, a4.isElement = Sp, a4.isEmpty = Op, a4.isEqual = Rp, a4.isEqualWith = bp, a4.isError = yi2, a4.isFinite = Tp, a4.isFunction = Qt2, a4.isInteger = ia, a4.isLength = fr2, a4.isMap = sa, a4.isMatch = Lp, a4.isMatchWith = Hp, a4.isNaN = Dp, a4.isNative = Np, a4.isNil = qp, a4.isNull = $p, a4.isNumber = ua, a4.isObject = K3, a4.isObjectLike = J, a4.isPlainObject = ge, a4.isRegExp = Si, a4.isSafeInteger = Up, a4.isSet = aa, a4.isString = cr2, a4.isSymbol = pt3, a4.isTypedArray = Gn, a4.isUndefined = Fp, a4.isWeakMap = Wp, a4.isWeakSet = Mp, a4.join = zh, a4.kebabCase = bd, a4.last = It2, a4.lastIndexOf = Kh, a4.lowerCase = Td, a4.lowerFirst = Ld, a4.lt = Bp, a4.lte = Gp, a4.max = yg, a4.maxBy = Sg, a4.mean = Og, a4.meanBy = Rg, a4.min = bg, a4.minBy = Tg, a4.stubArray = Ni, a4.stubFalse = $i2, a4.stubObject = vg, a4.stubString = _g, a4.stubTrue = mg, a4.multiply = Lg, a4.nth = Jh, a4.noConflict = og, a4.noop = Di2, a4.now = ur2, a4.pad = Hd, a4.padEnd = Dd, a4.padStart = Nd, a4.parseInt = $d, a4.random = Ed, a4.reduce = Xl, a4.reduceRight = Ql, a4.repeat = qd, a4.replace = Ud, a4.result = gd, a4.round = Hg, a4.runInContext = h4, a4.sample = kl, a4.size = np, a4.snakeCase = Fd, a4.some = ep, a4.sortedIndex = jh, a4.sortedIndexBy = tl, a4.sortedIndexOf = nl, a4.sortedLastIndex = el, a4.sortedLastIndexBy = rl, a4.sortedLastIndexOf = il, a4.startCase = Md, a4.startsWith = Bd, a4.subtract = Dg, a4.sum = Ng, a4.sumBy = $g, a4.template = Gd, a4.times = wg, a4.toFinite = Vt2, a4.toInteger = T3, a4.toLength = fa, a4.toLower = zd, a4.toNumber = xt2, a4.toSafeInteger = zp, a4.toString = U3, a4.toUpper = Kd, a4.trim = Jd, a4.trimEnd = Yd, a4.trimStart = Zd, a4.truncate = Xd, a4.unescape = Qd, a4.uniqueId = Cg, a4.upperCase = Vd, a4.upperFirst = bi2, a4.each = Xu, a4.eachRight = Qu, a4.first = Ku, Hi(a4, function() {
        var t = {};
        return qt2(a4, function(n4, e2) {
          W2.call(a4.prototype, e2) || (t[e2] = n4);
        }), t;
      }(), { chain: false }), a4.VERSION = p3, mt2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(t) {
        a4[t].placeholder = a4;
      }), mt2(["drop", "take"], function(t, n4) {
        N2.prototype[t] = function(e2) {
          e2 = e2 === i3 ? 1 : Q2(T3(e2), 0);
          var r3 = this.__filtered__ && !n4 ? new N2(this) : this.clone();
          return r3.__filtered__ ? r3.__takeCount__ = nt3(e2, r3.__takeCount__) : r3.__views__.push({ size: nt3(e2, $t2), type: t + (r3.__dir__ < 0 ? "Right" : "") }), r3;
        }, N2.prototype[t + "Right"] = function(e2) {
          return this.reverse()[t](e2).reverse();
        };
      }), mt2(["filter", "map", "takeWhile"], function(t, n4) {
        var e2 = n4 + 1, r3 = e2 == zi || e2 == Ka;
        N2.prototype[t] = function(u3) {
          var o5 = this.clone();
          return o5.__iteratees__.push({ iteratee: E4(u3, 3), type: e2 }), o5.__filtered__ = o5.__filtered__ || r3, o5;
        };
      }), mt2(["head", "last"], function(t, n4) {
        var e2 = "take" + (n4 ? "Right" : "");
        N2.prototype[t] = function() {
          return this[e2](1).value()[0];
        };
      }), mt2(["initial", "tail"], function(t, n4) {
        var e2 = "drop" + (n4 ? "" : "Right");
        N2.prototype[t] = function() {
          return this.__filtered__ ? new N2(this) : this[e2](1);
        };
      }), N2.prototype.compact = function() {
        return this.filter(ft2);
      }, N2.prototype.find = function(t) {
        return this.filter(t).head();
      }, N2.prototype.findLast = function(t) {
        return this.reverse().find(t);
      }, N2.prototype.invokeMap = H(function(t, n4) {
        return typeof t == "function" ? new N2(this) : this.map(function(e2) {
          return fe2(e2, t, n4);
        });
      }), N2.prototype.reject = function(t) {
        return this.filter(or2(E4(t)));
      }, N2.prototype.slice = function(t, n4) {
        t = T3(t);
        var e2 = this;
        return e2.__filtered__ && (t > 0 || n4 < 0) ? new N2(e2) : (t < 0 ? e2 = e2.takeRight(-t) : t && (e2 = e2.drop(t)), n4 !== i3 && (n4 = T3(n4), e2 = n4 < 0 ? e2.dropRight(-n4) : e2.take(n4 - t)), e2);
      }, N2.prototype.takeRightWhile = function(t) {
        return this.reverse().takeWhile(t).reverse();
      }, N2.prototype.toArray = function() {
        return this.take($t2);
      }, qt2(N2.prototype, function(t, n4) {
        var e2 = /^(?:filter|find|map|reject)|While$/.test(n4), r3 = /^(?:head|last)$/.test(n4), u3 = a4[r3 ? "take" + (n4 == "last" ? "Right" : "") : n4], o5 = r3 || /^find/.test(n4);
        u3 && (a4.prototype[n4] = function() {
          var f4 = this.__wrapped__, c5 = r3 ? [1] : arguments, l4 = f4 instanceof N2, v4 = c5[0], _2 = l4 || b3(f4), m2 = function(D2) {
            var $3 = u3.apply(a4, rn2([D2], c5));
            return r3 && C2 ? $3[0] : $3;
          };
          _2 && e2 && typeof v4 == "function" && v4.length != 1 && (l4 = _2 = false);
          var C2 = this.__chain__, I3 = !!this.__actions__.length, y6 = o5 && !C2, L3 = l4 && !I3;
          if (!o5 && _2) {
            f4 = L3 ? f4 : new N2(this);
            var S3 = t.apply(f4, c5);
            return S3.__actions__.push({ func: ir2, args: [m2], thisArg: i3 }), new Pt2(S3, C2);
          }
          return y6 && L3 ? t.apply(this, c5) : (S3 = this.thru(m2), y6 ? r3 ? S3.value()[0] : S3.value() : S3);
        });
      }), mt2(["pop", "push", "shift", "sort", "splice", "unshift"], function(t) {
        var n4 = be3[t], e2 = /^(?:push|sort|unshift)$/.test(t) ? "tap" : "thru", r3 = /^(?:pop|shift)$/.test(t);
        a4.prototype[t] = function() {
          var u3 = arguments;
          if (r3 && !this.__chain__) {
            var o5 = this.value();
            return n4.apply(b3(o5) ? o5 : [], u3);
          }
          return this[e2](function(f4) {
            return n4.apply(b3(f4) ? f4 : [], u3);
          });
        };
      }), qt2(N2.prototype, function(t, n4) {
        var e2 = a4[n4];
        if (e2) {
          var r3 = e2.name + "";
          W2.call(Un, r3) || (Un[r3] = []), Un[r3].push({ name: n4, func: e2 });
        }
      }), Un[Ve(i3, ln2).name] = [{ name: "wrapper", func: i3 }], N2.prototype.clone = Qf, N2.prototype.reverse = Vf, N2.prototype.value = kf, a4.prototype.at = Sl, a4.prototype.chain = Ol, a4.prototype.commit = Rl, a4.prototype.next = bl, a4.prototype.plant = Ll, a4.prototype.reverse = Hl, a4.prototype.toJSON = a4.prototype.valueOf = a4.prototype.value = Dl, a4.prototype.first = a4.prototype.head, ee2 && (a4.prototype[ee2] = Tl), a4;
    }, Nn = Rf();
    dn2 ? ((dn2.exports = Nn)._ = Nn, Lr2._ = Nn) : j4._ = Nn;
  }).call(_e3);
})(Ui, Ui.exports);
var Xg = Object.defineProperty;
var Qg = Object.defineProperties;
var Vg = Object.getOwnPropertyDescriptors;
var Oa = Object.getOwnPropertySymbols;
var kg = Object.prototype.hasOwnProperty;
var jg = Object.prototype.propertyIsEnumerable;
var Ra = (P3, s2, i3) => s2 in P3 ? Xg(P3, s2, { enumerable: true, configurable: true, writable: true, value: i3 }) : P3[s2] = i3;
var lr2 = (P3, s2) => {
  for (var i3 in s2 || (s2 = {})) kg.call(s2, i3) && Ra(P3, i3, s2[i3]);
  if (Oa) for (var i3 of Oa(s2)) jg.call(s2, i3) && Ra(P3, i3, s2[i3]);
  return P3;
};
var tv = (P3, s2) => Qg(P3, Vg(s2));
function Lt3(P3, s2, i3) {
  var p3;
  const w4 = mn(P3);
  return ((p3 = s2.rpcMap) == null ? void 0 : p3[w4.reference]) || `${Zg}?chainId=${w4.namespace}:${w4.reference}&projectId=${i3}`;
}
function In2(P3) {
  return P3.includes(":") ? P3.split(":")[1] : P3;
}
function ba(P3) {
  return P3.map((s2) => `${s2.split(":")[0]}:${s2.split(":")[1]}`);
}
function nv(P3, s2) {
  const i3 = Object.keys(s2.namespaces).filter((w4) => w4.includes(P3));
  if (!i3.length) return [];
  const p3 = [];
  return i3.forEach((w4) => {
    const x3 = s2.namespaces[w4].accounts;
    p3.push(...x3);
  }), p3;
}
function Fi(P3 = {}, s2 = {}) {
  const i3 = Ta(P3), p3 = Ta(s2);
  return Ui.exports.merge(i3, p3);
}
function Ta(P3) {
  var s2, i3, p3, w4;
  const x3 = {};
  if (!Xr(P3)) return x3;
  for (const [O4, k3] of Object.entries(P3)) {
    const tn2 = fn(O4) ? [O4] : k3.chains, Jn = k3.methods || [], xn = k3.events || [], Ht2 = k3.rpcMap || {}, Mt2 = Ao(O4);
    x3[Mt2] = tv(lr2(lr2({}, x3[Mt2]), k3), { chains: me(tn2, (s2 = x3[Mt2]) == null ? void 0 : s2.chains), methods: me(Jn, (i3 = x3[Mt2]) == null ? void 0 : i3.methods), events: me(xn, (p3 = x3[Mt2]) == null ? void 0 : p3.events), rpcMap: lr2(lr2({}, Ht2), (w4 = x3[Mt2]) == null ? void 0 : w4.rpcMap) });
  }
  return x3;
}
function ev(P3) {
  return P3.includes(":") ? P3.split(":")[2] : P3;
}
function La(P3) {
  const s2 = {};
  for (const [i3, p3] of Object.entries(P3)) {
    const w4 = p3.methods || [], x3 = p3.events || [], O4 = p3.accounts || [], k3 = fn(i3) ? [i3] : p3.chains ? p3.chains : ba(p3.accounts);
    s2[i3] = { chains: k3, methods: w4, events: x3, accounts: O4 };
  }
  return s2;
}
function Wi(P3) {
  return typeof P3 == "number" ? P3 : P3.includes("0x") ? parseInt(P3, 16) : (P3 = P3.includes(":") ? P3.split(":")[1] : P3, isNaN(Number(P3)) ? P3 : Number(P3));
}
var Ha = {};
var F2 = (P3) => Ha[P3];
var Mi = (P3, s2) => {
  Ha[P3] = s2;
};
var rv = class {
  constructor(s2) {
    this.name = "polkadot", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      const w4 = In2(i3);
      s2[w4] = this.createHttpProvider(w4, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p3, F2("disableProviderPing")));
  }
};
var iv = Object.defineProperty;
var sv = Object.defineProperties;
var uv = Object.getOwnPropertyDescriptors;
var Da = Object.getOwnPropertySymbols;
var av = Object.prototype.hasOwnProperty;
var ov = Object.prototype.propertyIsEnumerable;
var Na = (P3, s2, i3) => s2 in P3 ? iv(P3, s2, { enumerable: true, configurable: true, writable: true, value: i3 }) : P3[s2] = i3;
var $a = (P3, s2) => {
  for (var i3 in s2 || (s2 = {})) av.call(s2, i3) && Na(P3, i3, s2[i3]);
  if (Da) for (var i3 of Da(s2)) ov.call(s2, i3) && Na(P3, i3, s2[i3]);
  return P3;
};
var qa = (P3, s2) => sv(P3, uv(s2));
var fv = class {
  constructor(s2) {
    this.name = "eip155", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(s2) {
    switch (s2.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(s2);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(s2);
    }
    return this.namespace.methods.includes(s2.request.method) ? await this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(parseInt(s2), i3), this.chainId = parseInt(s2), this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(`${this.name}:${s2}`, this.namespace, this.client.core.projectId);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p3, F2("disableProviderPing")));
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      const w4 = parseInt(In2(i3));
      s2[w4] = this.createHttpProvider(w4, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const s2 = this.chainId, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  async handleSwitchChain(s2) {
    var i3, p3;
    let w4 = s2.request.params ? (i3 = s2.request.params[0]) == null ? void 0 : i3.chainId : "0x0";
    w4 = w4.startsWith("0x") ? w4 : `0x${w4}`;
    const x3 = parseInt(w4, 16);
    if (this.isChainApproved(x3)) this.setDefaultChain(`${x3}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: s2.topic, request: { method: s2.request.method, params: [{ chainId: w4 }] }, chainId: (p3 = this.namespace.chains) == null ? void 0 : p3[0] }), this.setDefaultChain(`${x3}`);
    else throw new Error(`Failed to switch to chain 'eip155:${x3}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(s2) {
    return this.namespace.chains.includes(`${this.name}:${s2}`);
  }
  async getCapabilities(s2) {
    var i3, p3, w4;
    const x3 = (p3 = (i3 = s2.request) == null ? void 0 : i3.params) == null ? void 0 : p3[0];
    if (!x3) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const O4 = this.client.session.get(s2.topic), k3 = ((w4 = O4 == null ? void 0 : O4.sessionProperties) == null ? void 0 : w4.capabilities) || {};
    if (k3 != null && k3[x3]) return k3 == null ? void 0 : k3[x3];
    const tn2 = await this.client.request(s2);
    try {
      await this.client.session.update(s2.topic, { sessionProperties: qa($a({}, O4.sessionProperties || {}), { capabilities: qa($a({}, k3 || {}), { [x3]: tn2 }) }) });
    } catch (Jn) {
      console.warn("Failed to update session with capabilities", Jn);
    }
    return tn2;
  }
};
var cv = class {
  constructor(s2) {
    this.name = "solana", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      const w4 = In2(i3);
      s2[w4] = this.createHttpProvider(w4, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p3, F2("disableProviderPing")));
  }
};
var hv = class {
  constructor(s2) {
    this.name = "cosmos", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      const w4 = In2(i3);
      s2[w4] = this.createHttpProvider(w4, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p3, F2("disableProviderPing")));
  }
};
var lv = class {
  constructor(s2) {
    this.name = "algorand", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    if (!this.httpProviders[s2]) {
      const p3 = i3 || Lt3(`${this.name}:${s2}`, this.namespace, this.client.core.projectId);
      if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
      this.setHttpProvider(s2, p3);
    }
    this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      s2[i3] = this.createHttpProvider(i3, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    return typeof p3 > "u" ? void 0 : new o3(new f3(p3, F2("disableProviderPing")));
  }
};
var pv = class {
  constructor(s2) {
    this.name = "cip34", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      const p3 = this.getCardanoRPCUrl(i3), w4 = In2(i3);
      s2[w4] = this.createHttpProvider(w4, p3);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  getCardanoRPCUrl(s2) {
    const i3 = this.namespace.rpcMap;
    if (i3) return i3[s2];
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || this.getCardanoRPCUrl(s2);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p3, F2("disableProviderPing")));
  }
};
var dv = class {
  constructor(s2) {
    this.name = "elrond", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      const w4 = In2(i3);
      s2[w4] = this.createHttpProvider(w4, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p3, F2("disableProviderPing")));
  }
};
var gv = class {
  constructor(s2) {
    this.name = "multiversx", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      const w4 = In2(i3);
      s2[w4] = this.createHttpProvider(w4, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p3, F2("disableProviderPing")));
  }
};
var vv = class {
  constructor(s2) {
    this.name = "near", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    if (this.chainId = s2, !this.httpProviders[s2]) {
      const p3 = i3 || Lt3(`${this.name}:${s2}`, this.namespace);
      if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
      this.setHttpProvider(s2, p3);
    }
    this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      s2[i3] = this.createHttpProvider(i3, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace);
    return typeof p3 > "u" ? void 0 : new o3(new f3(p3, F2("disableProviderPing")));
  }
};
var _v = class {
  constructor(s2) {
    this.name = Kn, this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(s2.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(s2.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(s2.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(s2.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider(s2.chainId).request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var s2, i3;
    const p3 = {};
    return (i3 = (s2 = this.namespace) == null ? void 0 : s2.accounts) == null || i3.forEach((w4) => {
      const x3 = mn(w4);
      p3[`${x3.namespace}:${x3.reference}`] = this.createHttpProvider(w4);
    }), p3;
  }
  getHttpProvider(s2) {
    const i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f3(p3, F2("disableProviderPing")));
  }
};
var mv = Object.defineProperty;
var wv = Object.defineProperties;
var Pv = Object.getOwnPropertyDescriptors;
var Ua = Object.getOwnPropertySymbols;
var Cv = Object.prototype.hasOwnProperty;
var Av = Object.prototype.propertyIsEnumerable;
var Fa = (P3, s2, i3) => s2 in P3 ? mv(P3, s2, { enumerable: true, configurable: true, writable: true, value: i3 }) : P3[s2] = i3;
var pr3 = (P3, s2) => {
  for (var i3 in s2 || (s2 = {})) Cv.call(s2, i3) && Fa(P3, i3, s2[i3]);
  if (Ua) for (var i3 of Ua(s2)) Av.call(s2, i3) && Fa(P3, i3, s2[i3]);
  return P3;
};
var Bi = (P3, s2) => wv(P3, Pv(s2));
var dr2 = class _dr {
  constructor(s2) {
    this.events = new import_events10.default(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = false, this.maxPairingAttempts = 10, this.disableProviderPing = false, this.providerOpts = s2, this.logger = typeof (s2 == null ? void 0 : s2.logger) < "u" && typeof (s2 == null ? void 0 : s2.logger) != "string" ? s2.logger : (0, import_pino.default)(k({ level: (s2 == null ? void 0 : s2.logger) || ya })), this.disableProviderPing = (s2 == null ? void 0 : s2.disableProviderPing) || false;
  }
  static async init(s2) {
    const i3 = new _dr(s2);
    return await i3.initialize(), i3;
  }
  async request(s2, i3, p3) {
    const [w4, x3] = this.validateChain(i3);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(w4).request({ request: pr3({}, s2), chainId: `${w4}:${x3}`, topic: this.session.topic, expiry: p3 });
  }
  sendAsync(s2, i3, p3, w4) {
    const x3 = (/* @__PURE__ */ new Date()).getTime();
    this.request(s2, p3, w4).then((O4) => i3(null, formatJsonRpcResult(x3, O4))).catch((O4) => i3(O4, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var s2;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (s2 = this.session) == null ? void 0 : s2.topic, reason: er("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(s2) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(s2), await this.cleanupPendingPairings(), !s2.skipPairing) return await this.pair(s2.pairingTopic);
  }
  async authenticate(s2, i3) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(s2), await this.cleanupPendingPairings();
    const { uri: p3, response: w4 } = await this.client.authenticate(s2, i3);
    p3 && (this.uri = p3, this.events.emit("display_uri", p3));
    const x3 = await w4();
    if (this.session = x3.session, this.session) {
      const O4 = La(this.session.namespaces);
      this.namespaces = Fi(this.namespaces, O4), this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return x3;
  }
  on(s2, i3) {
    this.events.on(s2, i3);
  }
  once(s2, i3) {
    this.events.once(s2, i3);
  }
  removeListener(s2, i3) {
    this.events.removeListener(s2, i3);
  }
  off(s2, i3) {
    this.events.off(s2, i3);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(s2) {
    this.shouldAbortPairingAttempt = false;
    let i3 = 0;
    do {
      if (this.shouldAbortPairingAttempt) throw new Error("Pairing aborted");
      if (i3 >= this.maxPairingAttempts) throw new Error("Max auto pairing attempts reached");
      const { uri: p3, approval: w4 } = await this.client.connect({ pairingTopic: s2, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
      p3 && (this.uri = p3, this.events.emit("display_uri", p3)), await w4().then((x3) => {
        this.session = x3;
        const O4 = La(x3.namespaces);
        this.namespaces = Fi(this.namespaces, O4), this.persist("namespaces", this.namespaces);
      }).catch((x3) => {
        if (x3.message !== it2) throw x3;
        i3++;
      });
    } while (!this.session);
    return this.onConnect(), this.session;
  }
  setDefaultChain(s2, i3) {
    try {
      if (!this.session) return;
      const [p3, w4] = this.validateChain(s2), x3 = this.getProvider(p3);
      x3.name === Kn ? x3.setDefaultChain(`${p3}:${w4}`, i3) : x3.setDefaultChain(w4, i3);
    } catch (p3) {
      if (!/Please call connect/.test(p3.message)) throw p3;
    }
  }
  async cleanupPendingPairings(s2 = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const i3 = this.client.pairing.getAll();
    if (Ir(i3)) {
      for (const p3 of i3) s2.deletePairings ? this.client.core.expirer.set(p3.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(p3.topic);
      this.logger.info(`Inactive pairings cleared: ${i3.length}`);
    }
  }
  abortPairingAttempt() {
    this.shouldAbortPairingAttempt = true;
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const s2 = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[s2]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await _e2.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || ya, relayUrl: this.providerOpts.relayUrl || Kg, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const s2 = [...new Set(Object.keys(this.session.namespaces).map((i3) => Ao(i3)))];
    Mi("client", this.client), Mi("events", this.events), Mi("disableProviderPing", this.disableProviderPing), s2.forEach((i3) => {
      if (!this.session) return;
      const p3 = nv(i3, this.session), w4 = ba(p3), x3 = Fi(this.namespaces, this.optionalNamespaces), O4 = Bi(pr3({}, x3[i3]), { accounts: p3, chains: w4 });
      switch (i3) {
        case "eip155":
          this.rpcProviders[i3] = new fv({ namespace: O4 });
          break;
        case "algorand":
          this.rpcProviders[i3] = new lv({ namespace: O4 });
          break;
        case "solana":
          this.rpcProviders[i3] = new cv({ namespace: O4 });
          break;
        case "cosmos":
          this.rpcProviders[i3] = new hv({ namespace: O4 });
          break;
        case "polkadot":
          this.rpcProviders[i3] = new rv({ namespace: O4 });
          break;
        case "cip34":
          this.rpcProviders[i3] = new pv({ namespace: O4 });
          break;
        case "elrond":
          this.rpcProviders[i3] = new dv({ namespace: O4 });
          break;
        case "multiversx":
          this.rpcProviders[i3] = new gv({ namespace: O4 });
          break;
        case "near":
          this.rpcProviders[i3] = new vv({ namespace: O4 });
          break;
        default:
          this.rpcProviders[Kn] ? this.rpcProviders[Kn].updateNamespace(O4) : this.rpcProviders[Kn] = new _v({ namespace: O4 });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (s2) => {
      this.events.emit("session_ping", s2);
    }), this.client.on("session_event", (s2) => {
      const { params: i3 } = s2, { event: p3 } = i3;
      if (p3.name === "accountsChanged") {
        const w4 = p3.data;
        w4 && Ir(w4) && this.events.emit("accountsChanged", w4.map(ev));
      } else if (p3.name === "chainChanged") {
        const w4 = i3.chainId, x3 = i3.event.data, O4 = Ao(w4), k3 = Wi(w4) !== Wi(x3) ? `${O4}:${Wi(x3)}` : w4;
        this.onChainChanged(k3);
      } else this.events.emit(p3.name, p3.data);
      this.events.emit("session_event", s2);
    }), this.client.on("session_update", ({ topic: s2, params: i3 }) => {
      var p3;
      const { namespaces: w4 } = i3, x3 = (p3 = this.client) == null ? void 0 : p3.session.get(s2);
      this.session = Bi(pr3({}, x3), { namespaces: w4 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: s2, params: i3 });
    }), this.client.on("session_delete", async (s2) => {
      await this.cleanup(), this.events.emit("session_delete", s2), this.events.emit("disconnect", Bi(pr3({}, er("USER_DISCONNECTED")), { data: s2.topic }));
    }), this.on(Tt2.DEFAULT_CHAIN_CHANGED, (s2) => {
      this.onChainChanged(s2, true);
    });
  }
  getProvider(s2) {
    return this.rpcProviders[s2] || this.rpcProviders[Kn];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((s2) => {
      var i3;
      this.getProvider(s2).updateNamespace((i3 = this.session) == null ? void 0 : i3.namespaces[s2]);
    });
  }
  setNamespaces(s2) {
    const { namespaces: i3, optionalNamespaces: p3, sessionProperties: w4 } = s2;
    i3 && Object.keys(i3).length && (this.namespaces = i3), p3 && Object.keys(p3).length && (this.optionalNamespaces = p3), this.sessionProperties = w4, this.persist("namespaces", i3), this.persist("optionalNamespaces", p3);
  }
  validateChain(s2) {
    const [i3, p3] = (s2 == null ? void 0 : s2.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [i3, p3];
    if (i3 && !Object.keys(this.namespaces || {}).map((O4) => Ao(O4)).includes(i3)) throw new Error(`Namespace '${i3}' is not configured. Please call connect() first with namespace config.`);
    if (i3 && p3) return [i3, p3];
    const w4 = Ao(Object.keys(this.namespaces)[0]), x3 = this.rpcProviders[w4].getDefaultChain();
    return [w4, x3];
  }
  async requestAccounts() {
    const [s2] = this.validateChain();
    return await this.getProvider(s2).requestAccounts();
  }
  onChainChanged(s2, i3 = false) {
    if (!this.namespaces) return;
    const [p3, w4] = this.validateChain(s2);
    w4 && (i3 || this.getProvider(p3).setDefaultChain(w4), this.namespaces[p3] ? this.namespaces[p3].defaultChain = w4 : this.namespaces[`${p3}:${w4}`] ? this.namespaces[`${p3}:${w4}`].defaultChain = w4 : this.namespaces[`${p3}:${w4}`] = { defaultChain: w4 }, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", w4));
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: true });
  }
  persist(s2, i3) {
    this.client.core.storage.setItem(`${Sa}/${s2}`, i3);
  }
  async getFromStore(s2) {
    return await this.client.core.storage.getItem(`${Sa}/${s2}`);
  }
};

// node_modules/@reown/appkit/dist/esm/src/store/ProviderUtil.js
var state2 = proxy({
  providers: { eip155: void 0, solana: void 0, polkadot: void 0 },
  providerIds: { eip155: void 0, solana: void 0, polkadot: void 0 }
});
var ProviderUtil = {
  state: state2,
  subscribeKey(key, callback) {
    return subscribeKey(state2, key, callback);
  },
  subscribeProviders(callback) {
    return subscribe(state2.providers, () => callback(state2.providers));
  },
  setProvider(chainNamespace, provider) {
    if (provider) {
      state2.providers[chainNamespace] = ref(provider);
    }
  },
  getProvider(chainNamespace) {
    return state2.providers[chainNamespace];
  },
  setProviderId(chainNamespace, providerId) {
    if (providerId) {
      state2.providerIds[chainNamespace] = providerId;
    }
  },
  getProviderId(chainNamespace) {
    return state2.providerIds[chainNamespace];
  },
  reset() {
    state2.providers = { eip155: void 0, solana: void 0, polkadot: void 0 };
    state2.providerIds = { eip155: void 0, solana: void 0, polkadot: void 0 };
  },
  resetChain(chainNamespace) {
    state2.providers[chainNamespace] = void 0;
    state2.providerIds[chainNamespace] = void 0;
  }
};

// node_modules/@reown/appkit/dist/esm/src/universal-adapter/client.js
var OPTIONAL_METHODS = [
  "eth_accounts",
  "eth_requestAccounts",
  "eth_sendRawTransaction",
  "eth_sign",
  "eth_signTransaction",
  "eth_signTypedData",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "eth_sendTransaction",
  "personal_sign",
  "wallet_switchEthereumChain",
  "wallet_addEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode"
];
var UniversalAdapterClient = class {
  constructor(options) {
    this.appKit = void 0;
    this.isUniversalAdapterClient = true;
    this.defaultNetwork = void 0;
    this.options = void 0;
    this.adapterType = "universal";
    const { siweConfig, metadata } = options;
    this.caipNetworks = options.networks;
    this.chainNamespace = "eip155";
    this.metadata = metadata;
    this.defaultNetwork = options.defaultNetwork || options.networks[0];
    this.networkControllerClient = {
      // @ts-expect-error switchCaipNetwork is async for some adapter but not for this adapter
      switchCaipNetwork: (caipNetwork) => {
        if (caipNetwork) {
          try {
            this.switchNetwork(caipNetwork);
          } catch (error) {
            throw new Error("networkControllerClient:switchCaipNetwork - unable to switch chain");
          }
        }
      },
      getApprovedCaipNetworksData: async () => {
        await this.getWalletConnectProvider();
        return new Promise((resolve) => {
          var _a, _b;
          const ns = (_b = (_a = this.walletConnectProvider) == null ? void 0 : _a.session) == null ? void 0 : _b.namespaces;
          const nsChains = [];
          if (ns) {
            Object.keys(ns).forEach((key) => {
              var _a2;
              const chains = (_a2 = ns == null ? void 0 : ns[key]) == null ? void 0 : _a2.chains;
              if (chains) {
                nsChains.push(...chains);
              }
            });
          }
          const result = {
            supportsAllNetworks: true,
            approvedCaipNetworkIds: nsChains
          };
          resolve(result);
        });
      }
    };
    this.connectionControllerClient = {
      connectWalletConnect: async (onUri) => {
        var _a, _b, _c, _d, _e4, _f, _g, _h, _i, _j, _k;
        const WalletConnectProvider = await this.getWalletConnectProvider();
        if (!WalletConnectProvider) {
          throw new Error("connectionControllerClient:getWalletConnectUri - provider is undefined");
        }
        WalletConnectProvider.on("display_uri", (uri) => {
          onUri(uri);
        });
        if (ChainController.state.activeChain && ((_c = (_b = (_a = ChainController.state) == null ? void 0 : _a.chains) == null ? void 0 : _b.get(ChainController.state.activeChain)) == null ? void 0 : _c.adapterType) === "wagmi") {
          const adapter = ChainController.state.chains.get(ChainController.state.activeChain);
          await ((_e4 = (_d = adapter == null ? void 0 : adapter.connectionControllerClient) == null ? void 0 : _d.connectWalletConnect) == null ? void 0 : _e4.call(_d, onUri));
          this.setWalletConnectProvider();
        } else {
          const siweParams = await ((_f = siweConfig == null ? void 0 : siweConfig.getMessageParams) == null ? void 0 : _f.call(siweConfig));
          const isSiweEnabled = (_g = siweConfig == null ? void 0 : siweConfig.options) == null ? void 0 : _g.enabled;
          const isProviderSupported = typeof (WalletConnectProvider == null ? void 0 : WalletConnectProvider.authenticate) === "function";
          const isSiweParamsValid = siweParams && Object.keys(siweParams || {}).length > 0;
          if (siweConfig && isSiweEnabled && siweParams && isProviderSupported && isSiweParamsValid) {
            const { SIWEController, getDidChainId, getDidAddress } = await import("./exports-S4LPZMO3.js");
            const chains = (_h = this.caipNetworks) == null ? void 0 : _h.filter((network) => network.chainNamespace === "eip155").map((chain) => chain.id);
            siweParams.chains = (_i = this.caipNetworks) == null ? void 0 : _i.filter((network) => network.chainNamespace === "eip155").map((chain) => chain.chainId);
            const result = await WalletConnectProvider.authenticate({
              nonce: await ((_j = siweConfig == null ? void 0 : siweConfig.getNonce) == null ? void 0 : _j.call(siweConfig)),
              methods: [...OPTIONAL_METHODS],
              ...siweParams,
              chains
            });
            const signedCacao = (_k = result == null ? void 0 : result.auths) == null ? void 0 : _k[0];
            if (signedCacao) {
              const { p: p3, s: s2 } = signedCacao;
              const cacaoChainId = getDidChainId(p3.iss);
              const address = getDidAddress(p3.iss);
              if (address && cacaoChainId) {
                SIWEController.setSession({
                  address,
                  chainId: parseInt(cacaoChainId, 10)
                });
              }
              try {
                const message = WalletConnectProvider.client.formatAuthMessage({
                  request: p3,
                  iss: p3.iss
                });
                await SIWEController.verifyMessage({
                  message,
                  signature: s2.s,
                  cacao: signedCacao
                });
              } catch (error) {
                console.error("Error verifying message", error);
                await WalletConnectProvider.disconnect().catch(console.error);
                await SIWEController.signOut().catch(console.error);
                throw error;
              }
            }
          } else {
            const optionalNamespaces = WcHelpersUtil.createNamespaces(this.caipNetworks);
            await WalletConnectProvider.connect({ optionalNamespaces });
          }
          this.setWalletConnectProvider();
        }
      },
      disconnect: async () => {
        var _a, _b, _c, _d;
        SafeLocalStorage.removeItem(SafeLocalStorageKeys.WALLET_ID);
        if ((_a = siweConfig == null ? void 0 : siweConfig.options) == null ? void 0 : _a.signOutOnDisconnect) {
          const { SIWEController } = await import("./exports-S4LPZMO3.js");
          await SIWEController.signOut();
        }
        await ((_b = this.walletConnectProvider) == null ? void 0 : _b.disconnect());
        (_c = this.appKit) == null ? void 0 : _c.resetAccount("eip155");
        (_d = this.appKit) == null ? void 0 : _d.resetAccount("solana");
      },
      signMessage: async (message) => {
        const provider = await this.getWalletConnectProvider();
        const caipAddress = ChainController.state.activeCaipAddress;
        const address = CoreHelperUtil.getPlainAddress(caipAddress);
        if (!provider) {
          throw new Error("connectionControllerClient:signMessage - provider is undefined");
        }
        const signature = await provider.request({
          method: "personal_sign",
          params: [message, address]
        });
        return signature;
      },
      estimateGas: async () => await Promise.resolve(BigInt(0)),
      // -- Transaction methods ---------------------------------------------------
      /**
       *
       * These methods are supported only on `wagmi` and `ethers` since the Solana SDK does not support them in the same way.
       * These function definition is to have a type parity between the clients. Currently not in use.
       */
      getEnsAvatar: async (value) => await Promise.resolve(value),
      getEnsAddress: async (value) => await Promise.resolve(value),
      writeContract: async () => await Promise.resolve("0x"),
      sendTransaction: async () => await Promise.resolve("0x"),
      parseUnits: () => BigInt(0),
      formatUnits: () => ""
    };
  }
  // -- Public ------------------------------------------------------------------
  construct(appkit, options) {
    if (!options.projectId) {
      throw new Error("Solana:construct - projectId is undefined");
    }
    this.appKit = appkit;
    this.options = options;
    this.createProvider();
    this.syncRequestedNetworks(this.caipNetworks);
    this.syncConnectors();
  }
  switchNetwork(caipNetwork) {
    if (caipNetwork) {
      if (this.walletConnectProvider) {
        this.walletConnectProvider.setDefaultChain(caipNetwork.id);
      }
    }
  }
  async disconnect() {
    var _a, _b;
    if (this.walletConnectProvider) {
      await this.walletConnectProvider.disconnect();
      (_a = this.appKit) == null ? void 0 : _a.resetAccount("eip155");
      (_b = this.appKit) == null ? void 0 : _b.resetAccount("solana");
    }
  }
  async getWalletConnectProvider() {
    if (!this.walletConnectProvider) {
      try {
        await this.createProvider();
      } catch (error) {
        throw new Error("EthereumAdapter:getWalletConnectProvider - Cannot create provider");
      }
    }
    return this.walletConnectProvider;
  }
  // -- Private -----------------------------------------------------------------
  createProvider() {
    var _a, _b;
    if (!this.walletConnectProviderInitPromise && typeof window !== "undefined" && ((_a = this.options) == null ? void 0 : _a.projectId)) {
      this.walletConnectProviderInitPromise = this.initWalletConnectProvider((_b = this.options) == null ? void 0 : _b.projectId);
    }
    return this.walletConnectProviderInitPromise;
  }
  async initWalletConnectProvider(projectId) {
    const walletConnectProviderOptions = {
      projectId,
      metadata: {
        name: this.metadata ? this.metadata.name : "",
        description: this.metadata ? this.metadata.description : "",
        url: this.metadata ? this.metadata.url : "",
        icons: this.metadata ? this.metadata.icons : [""]
      }
    };
    this.walletConnectProvider = await dr2.init(walletConnectProviderOptions);
    await this.checkActiveWalletConnectProvider();
  }
  syncRequestedNetworks(caipNetworks) {
    const uniqueChainNamespaces = [
      ...new Set(caipNetworks.map((caipNetwork) => caipNetwork.chainNamespace))
    ];
    uniqueChainNamespaces.filter((c5) => Boolean(c5)).forEach((chainNamespace) => {
      var _a;
      (_a = this.appKit) == null ? void 0 : _a.setRequestedCaipNetworks(caipNetworks.filter((caipNetwork) => caipNetwork.chainNamespace === chainNamespace), chainNamespace);
    });
  }
  async checkActiveWalletConnectProvider() {
    const WalletConnectProvider = await this.getWalletConnectProvider();
    const walletId = SafeLocalStorage.getItem(SafeLocalStorageKeys.WALLET_ID);
    if (WalletConnectProvider) {
      if (walletId === ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID) {
        this.setWalletConnectProvider();
      }
    }
  }
  setWalletConnectProvider() {
    var _a, _b, _c;
    SafeLocalStorage.setItem(SafeLocalStorageKeys.WALLET_ID, ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID);
    const nameSpaces = (_b = (_a = this.walletConnectProvider) == null ? void 0 : _a.session) == null ? void 0 : _b.namespaces;
    if (nameSpaces) {
      Object.keys(nameSpaces).reverse().forEach((key) => {
        var _a2, _b2;
        const caipAddress = (_a2 = nameSpaces == null ? void 0 : nameSpaces[key]) == null ? void 0 : _a2.accounts[0];
        ProviderUtil.setProvider(key, this.walletConnectProvider);
        ProviderUtil.setProviderId(key, "walletConnect");
        if (caipAddress) {
          (_b2 = this.appKit) == null ? void 0 : _b2.setCaipAddress(caipAddress, key);
        }
      });
      const storedCaipNetwork = StorageUtil.getStoredActiveCaipNetwork();
      const activeCaipNetwork = ChainController.state.activeCaipNetwork;
      try {
        if (storedCaipNetwork) {
          NetworkController.setActiveCaipNetwork(storedCaipNetwork);
        } else if (!activeCaipNetwork) {
          this.setDefaultNetwork(nameSpaces);
        } else if (!((_c = NetworkController.state.approvedCaipNetworkIds) == null ? void 0 : _c.includes(activeCaipNetwork.id))) {
          this.setDefaultNetwork(nameSpaces);
        }
      } catch (error) {
        console.warn(">>> Error setting active caip network", error);
      }
    }
    this.syncAccount();
    this.watchWalletConnect();
  }
  setDefaultNetwork(nameSpaces) {
    var _a, _b;
    const chainNamespace = (_a = this.caipNetworks[0]) == null ? void 0 : _a.chainNamespace;
    if (chainNamespace) {
      const namespace = nameSpaces == null ? void 0 : nameSpaces[chainNamespace];
      if (namespace == null ? void 0 : namespace.chains) {
        const chainId = namespace.chains[0];
        if (chainId) {
          const requestedCaipNetworks = (_b = NetworkController.state) == null ? void 0 : _b.requestedCaipNetworks;
          if (requestedCaipNetworks) {
            const network = requestedCaipNetworks.find((c5) => c5.id === chainId);
            if (network) {
              NetworkController.setActiveCaipNetwork(network);
            }
          }
        }
      }
    }
  }
  async watchWalletConnect() {
    var _a;
    const provider = await this.getWalletConnectProvider();
    const namespaces = ((_a = provider == null ? void 0 : provider.session) == null ? void 0 : _a.namespaces) || {};
    function disconnectHandler() {
      Object.keys(namespaces).forEach((key) => {
        AccountController.resetAccount(key);
      });
      ConnectionController.resetWcConnection();
      SafeLocalStorage.removeItem(SafeLocalStorageKeys.WALLET_ID);
      provider == null ? void 0 : provider.removeListener("disconnect", disconnectHandler);
      provider == null ? void 0 : provider.removeListener("accountsChanged", accountsChangedHandler);
    }
    const accountsChangedHandler = (accounts) => {
      if (accounts.length > 0) {
        this.syncAccount();
      }
    };
    const chainChanged = (chainId) => {
      var _a2, _b, _c;
      const caipNetwork = this.caipNetworks.find((c5) => c5.chainId == chainId);
      const currentCaipNetwork = (_a2 = this.appKit) == null ? void 0 : _a2.getCaipNetwork();
      if (!caipNetwork) {
        NetworkController.setActiveCaipNetwork({
          chainId: Number(chainId),
          id: `eip155:${chainId}`,
          name: "Unknown Network",
          currency: "",
          explorerUrl: "",
          rpcUrl: "",
          chainNamespace: ((_b = this.appKit) == null ? void 0 : _b.getActiveChainNamespace()) || "eip155"
        });
        return;
      }
      if (!currentCaipNetwork || (currentCaipNetwork == null ? void 0 : currentCaipNetwork.id) !== (caipNetwork == null ? void 0 : caipNetwork.id)) {
        (_c = this.appKit) == null ? void 0 : _c.setCaipNetwork(caipNetwork);
      }
    };
    if (provider) {
      provider.on("disconnect", disconnectHandler);
      provider.on("accountsChanged", accountsChangedHandler);
      provider.on("chainChanged", chainChanged);
    }
  }
  getProviderData() {
    var _a, _b, _c, _d;
    const namespaces = ((_b = (_a = this.walletConnectProvider) == null ? void 0 : _a.session) == null ? void 0 : _b.namespaces) || {};
    const isConnected = ((_c = this.appKit) == null ? void 0 : _c.getIsConnectedState()) || false;
    const preferredAccountType = ((_d = this.appKit) == null ? void 0 : _d.getPreferredAccountType()) || "";
    return {
      provider: this.walletConnectProvider,
      namespaces,
      namespaceKeys: namespaces ? Object.keys(namespaces) : [],
      isConnected,
      preferredAccountType
    };
  }
  syncAccount() {
    var _a, _b, _c, _d;
    const { namespaceKeys, namespaces } = this.getProviderData();
    const preferredAccountType = (_a = this.appKit) == null ? void 0 : _a.getPreferredAccountType();
    const isConnected = ((_b = this.appKit) == null ? void 0 : _b.getIsConnectedState()) || false;
    if (isConnected) {
      namespaceKeys.forEach(async (key) => {
        var _a2, _b2, _c2, _d2, _e4;
        const chainNamespace = key;
        const address = (_a2 = namespaces == null ? void 0 : namespaces[key]) == null ? void 0 : _a2.accounts[0];
        const isNamespaceConnected = (_b2 = this.appKit) == null ? void 0 : _b2.getCaipAddress(chainNamespace);
        if (!isNamespaceConnected) {
          (_c2 = this.appKit) == null ? void 0 : _c2.setPreferredAccountType(preferredAccountType, chainNamespace);
          (_d2 = this.appKit) == null ? void 0 : _d2.setCaipAddress(address, chainNamespace);
          this.syncConnectedWalletInfo();
          await Promise.all([(_e4 = this.appKit) == null ? void 0 : _e4.setApprovedCaipNetworksData(chainNamespace)]);
        }
        this.syncAccounts();
      });
    } else {
      (_c = this.appKit) == null ? void 0 : _c.resetWcConnection();
      (_d = this.appKit) == null ? void 0 : _d.resetNetwork();
      this.syncAccounts(true);
    }
  }
  syncAccounts(reset = false) {
    const { namespaces } = this.getProviderData();
    const chainNamespaces = Object.keys(namespaces);
    chainNamespaces.forEach((chainNamespace) => {
      var _a, _b, _c, _d;
      const addresses = (_b = (_a = namespaces == null ? void 0 : namespaces[chainNamespace]) == null ? void 0 : _a.accounts) == null ? void 0 : _b.map((account) => {
        const [, , address] = account.split(":");
        return address;
      }).filter((address, index, self2) => self2.indexOf(address) === index);
      if (reset) {
        (_c = this.appKit) == null ? void 0 : _c.setAllAccounts([], chainNamespace);
      }
      if (addresses) {
        (_d = this.appKit) == null ? void 0 : _d.setAllAccounts(addresses.map((address) => ({ address, type: "eoa" })), chainNamespace);
      }
    });
  }
  syncConnectedWalletInfo() {
    var _a, _b;
    const currentActiveWallet = SafeLocalStorage.getItem(SafeLocalStorageKeys.WALLET_ID);
    const namespaces = ((_b = (_a = this.walletConnectProvider) == null ? void 0 : _a.session) == null ? void 0 : _b.namespaces) || {};
    const chainNamespaces = Object.keys(namespaces);
    chainNamespaces.forEach((chainNamespace) => {
      var _a2, _b2, _c, _d, _e4;
      if ((_a2 = this.walletConnectProvider) == null ? void 0 : _a2.session) {
        (_c = this.appKit) == null ? void 0 : _c.setConnectedWalletInfo({
          ...this.walletConnectProvider.session.peer.metadata,
          name: this.walletConnectProvider.session.peer.metadata.name,
          icon: (_b2 = this.walletConnectProvider.session.peer.metadata.icons) == null ? void 0 : _b2[0]
        }, chainNamespace);
      } else if (currentActiveWallet) {
        (_d = this.appKit) == null ? void 0 : _d.setConnectedWalletInfo({ name: currentActiveWallet }, "eip155");
        (_e4 = this.appKit) == null ? void 0 : _e4.setConnectedWalletInfo({ name: currentActiveWallet }, "solana");
      }
    });
  }
  syncConnectors() {
    var _a;
    const w3mConnectors = [];
    w3mConnectors.push({
      id: ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID,
      explorerId: PresetsUtil.ConnectorExplorerIds[ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID],
      imageId: PresetsUtil.ConnectorImageIds[ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID],
      name: PresetsUtil.ConnectorNamesMap[ConstantsUtil3.WALLET_CONNECT_CONNECTOR_ID],
      type: "WALLET_CONNECT",
      chain: this.chainNamespace
    });
    (_a = this.appKit) == null ? void 0 : _a.setConnectors(w3mConnectors);
  }
};

// node_modules/@reown/appkit/dist/esm/src/client.js
var isInitialized = false;
var AppKit = class {
  constructor(options) {
    var _a;
    this.initPromise = void 0;
    this.setStatus = (status, chain) => {
      AccountController.setStatus(status, chain);
    };
    this.getIsConnectedState = () => Boolean(ChainController.state.activeCaipAddress);
    this.setAllAccounts = (addresses, chain) => {
      AccountController.setAllAccounts(addresses, chain);
      OptionsController.setHasMultipleAddresses((addresses == null ? void 0 : addresses.length) > 1);
    };
    this.addAddressLabel = (address, label, chain) => {
      AccountController.addAddressLabel(address, label, chain);
    };
    this.removeAddressLabel = (address, chain) => {
      AccountController.removeAddressLabel(address, chain);
    };
    this.getCaipAddress = (chainNamespace) => {
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return ChainController.state.activeCaipAddress;
      }
      return ChainController.getAccountProp("caipAddress", chainNamespace);
    };
    this.getAddress = (chainNamespace) => {
      if (ChainController.state.activeChain === chainNamespace || !chainNamespace) {
        return AccountController.state.address;
      }
      return ChainController.getAccountProp("address", chainNamespace);
    };
    this.getProvider = () => AccountController.state.provider;
    this.getPreferredAccountType = () => AccountController.state.preferredAccountType;
    this.setCaipAddress = (caipAddress, chain) => {
      AccountController.setCaipAddress(caipAddress, chain);
    };
    this.setProvider = (provider, chain) => {
      AccountController.setProvider(provider, chain);
    };
    this.setBalance = (balance, balanceSymbol, chain) => {
      AccountController.setBalance(balance, balanceSymbol, chain);
    };
    this.setProfileName = (profileName, chain) => {
      AccountController.setProfileName(profileName, chain);
    };
    this.setProfileImage = (profileImage, chain) => {
      AccountController.setProfileImage(profileImage, chain);
    };
    this.resetAccount = (chain) => {
      AccountController.resetAccount(chain);
    };
    this.setCaipNetwork = (caipNetwork) => {
      ChainController.setActiveCaipNetwork(caipNetwork);
    };
    this.getCaipNetwork = (chainNamespace) => {
      var _a2;
      if (chainNamespace) {
        return (_a2 = NetworkController.getRequestedCaipNetworks().filter((c5) => c5.chainNamespace === chainNamespace)) == null ? void 0 : _a2[0];
      }
      return ChainController.state.activeCaipNetwork;
    };
    this.getCaipNetworks = () => NetworkController.getRequestedCaipNetworks();
    this.getActiveChainNamespace = () => ChainController.state.activeChain;
    this.setRequestedCaipNetworks = (requestedCaipNetworks, chain) => {
      NetworkController.setRequestedCaipNetworks(requestedCaipNetworks, chain);
    };
    this.getApprovedCaipNetworkIds = () => NetworkController.getApprovedCaipNetworkIds();
    this.setApprovedCaipNetworksData = (chain) => NetworkController.setApprovedCaipNetworksData(chain);
    this.resetNetwork = () => {
      NetworkController.resetNetwork();
    };
    this.setConnectors = (connectors) => {
      const allConnectors = [...ConnectorController.getConnectors(), ...connectors];
      ConnectorController.setConnectors(allConnectors);
    };
    this.addConnector = (connector) => {
      ConnectorController.addConnector(connector);
    };
    this.getConnectors = () => ConnectorController.getConnectors();
    this.resetWcConnection = () => {
      ConnectionController.resetWcConnection();
    };
    this.fetchIdentity = (request) => BlockchainApiController.fetchIdentity(request);
    this.setAddressExplorerUrl = (addressExplorerUrl, chain) => {
      AccountController.setAddressExplorerUrl(addressExplorerUrl, chain);
    };
    this.setSmartAccountDeployed = (isDeployed, chain) => {
      AccountController.setSmartAccountDeployed(isDeployed, chain);
    };
    this.setConnectedWalletInfo = (connectedWalletInfo, chain) => {
      AccountController.setConnectedWalletInfo(connectedWalletInfo, chain);
    };
    this.setSmartAccountEnabledNetworks = (smartAccountEnabledNetworks, chain) => {
      NetworkController.setSmartAccountEnabledNetworks(smartAccountEnabledNetworks, chain);
    };
    this.setPreferredAccountType = (preferredAccountType, chain) => {
      AccountController.setPreferredAccountType(preferredAccountType, chain);
    };
    this.getReownName = (address) => EnsController.getNamesForAddress(address);
    this.resolveReownName = async (name) => {
      var _a2;
      const wcNameAddress = await EnsController.resolveName(name);
      const networkNameAddresses = Object.values(wcNameAddress == null ? void 0 : wcNameAddress.addresses) || [];
      return ((_a2 = networkNameAddresses[0]) == null ? void 0 : _a2.address) || false;
    };
    this.setEIP6963Enabled = (enabled) => {
      OptionsController.setEIP6963Enabled(enabled);
    };
    this.setClientId = (clientId) => {
      BlockchainApiController.setClientId(clientId);
    };
    this.getConnectorImage = (connector) => AssetUtil.getConnectorImage(connector);
    this.handleUnsafeRPCRequest = () => {
      if (this.isOpen()) {
        if (this.isTransactionStackEmpty()) {
          return;
        }
        this.redirect("ApproveTransaction");
      } else {
        this.open({ view: "ApproveTransaction" });
      }
    };
    this.adapter = (_a = options.adapters) == null ? void 0 : _a[0];
    this.initControllers(options);
    this.initOrContinue();
  }
  static getInstance() {
    return this.instance;
  }
  // -- Public -------------------------------------------------------------------
  async open(options) {
    await this.initOrContinue();
    ModalController.open(options);
  }
  async close() {
    await this.initOrContinue();
    ModalController.close();
  }
  setLoading(loading) {
    ModalController.setLoading(loading);
  }
  // -- Adapter Methods ----------------------------------------------------------
  getError() {
    return "";
  }
  getChainId() {
    var _a;
    return (_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.chainId;
  }
  switchNetwork(caipNetwork) {
    return NetworkController.switchActiveNetwork(caipNetwork);
  }
  getWalletProvider() {
    return ChainController.state.activeChain ? ProviderUtil.state.providers[ChainController.state.activeChain] : null;
  }
  getWalletProviderType() {
    return ChainController.state.activeChain ? ProviderUtil.state.providerIds[ChainController.state.activeChain] : null;
  }
  subscribeProvider() {
    return null;
  }
  getThemeMode() {
    return ThemeController.state.themeMode;
  }
  getThemeVariables() {
    return ThemeController.state.themeVariables;
  }
  setThemeMode(themeMode) {
    ThemeController.setThemeMode(themeMode);
    setColorTheme(ThemeController.state.themeMode);
  }
  setThemeVariables(themeVariables) {
    ThemeController.setThemeVariables(themeVariables);
    setThemeVariables(ThemeController.state.themeVariables);
  }
  subscribeTheme(callback) {
    return ThemeController.subscribe(callback);
  }
  getWalletInfo() {
    return AccountController.state.connectedWalletInfo;
  }
  subscribeWalletInfo(callback) {
    return AccountController.subscribeKey("connectedWalletInfo", callback);
  }
  subscribeShouldUpdateToAddress(callback) {
    AccountController.subscribeKey("shouldUpdateToAddress", callback);
  }
  subscribeCaipNetworkChange(callback) {
    NetworkController.subscribeKey("caipNetwork", callback);
  }
  getState() {
    return PublicStateController.state;
  }
  subscribeState(callback) {
    return PublicStateController.subscribe(callback);
  }
  showErrorMessage(message) {
    SnackController.showError(message);
  }
  showSuccessMessage(message) {
    SnackController.showSuccess(message);
  }
  getEvent() {
    return { ...EventsController.state };
  }
  subscribeEvents(callback) {
    return EventsController.subscribe(callback);
  }
  replace(route) {
    RouterController.replace(route);
  }
  redirect(route) {
    RouterController.push(route);
  }
  popTransactionStack(cancel) {
    RouterController.popTransactionStack(cancel);
  }
  isOpen() {
    return ModalController.state.open;
  }
  isTransactionStackEmpty() {
    return RouterController.state.transactionStack.length === 0;
  }
  isTransactionShouldReplaceView() {
    var _a;
    return (_a = RouterController.state.transactionStack[RouterController.state.transactionStack.length - 1]) == null ? void 0 : _a.replace;
  }
  // -- Private ------------------------------------------------------------------
  async initControllers(options) {
    var _a;
    OptionsController.setProjectId(options.projectId);
    OptionsController.setSdkVersion(options.sdkVersion);
    this.adapters = options.adapters;
    this.setMetadata(options);
    this.extendCaipNetworks(options);
    this.initializeUniversalAdapter(options);
    this.initializeAdapters(options);
    this.setDefaultNetwork(options);
    OptionsController.setAllWallets(options.allWallets);
    OptionsController.setIncludeWalletIds(options.includeWalletIds);
    OptionsController.setExcludeWalletIds(options.excludeWalletIds);
    if (options.excludeWalletIds) {
      ApiController.searchWalletByIds({ ids: options.excludeWalletIds });
    }
    OptionsController.setFeaturedWalletIds(options.featuredWalletIds);
    OptionsController.setTokens(options.tokens);
    OptionsController.setTermsConditionsUrl(options.termsConditionsUrl);
    OptionsController.setPrivacyPolicyUrl(options.privacyPolicyUrl);
    OptionsController.setCustomWallets(options.customWallets);
    OptionsController.setFeatures(options.features);
    OptionsController.setEnableWalletConnect(options.enableWalletConnect !== false);
    OptionsController.setEnableWallets(options.enableWallets !== false);
    if (options.metadata) {
      OptionsController.setMetadata(options.metadata);
    }
    if (options.themeMode) {
      ThemeController.setThemeMode(options.themeMode);
    }
    if (options.themeVariables) {
      ThemeController.setThemeVariables(options.themeVariables);
    }
    if (options.disableAppend) {
      OptionsController.setDisableAppend(Boolean(options.disableAppend));
    }
    const evmAdapter = (_a = options.adapters) == null ? void 0 : _a.find((adapter) => adapter.chainNamespace === ConstantsUtil.CHAIN.EVM);
    if (evmAdapter) {
      if (options.siweConfig) {
        const { SIWEController } = await import("./exports-S4LPZMO3.js");
        SIWEController.setSIWEClient(options.siweConfig);
      }
    }
  }
  setMetadata(options) {
    var _a, _b, _c;
    if (typeof window === "undefined" || typeof document === "undefined") {
      return;
    }
    options.metadata = {
      name: ((_a = document.getElementsByTagName("title")[0]) == null ? void 0 : _a.textContent) || "",
      description: ((_b = document.querySelector('meta[property="og:description"]')) == null ? void 0 : _b.content) || "",
      url: window.location.origin,
      icons: [((_c = document.querySelector('link[rel~="icon"]')) == null ? void 0 : _c.href) || ""]
    };
  }
  extendCaipNetworks(options) {
    options.networks = CaipNetworksUtil.extendCaipNetworks(options.networks, {
      networkImageIds: PresetsUtil.NetworkImageIds,
      customNetworkImageUrls: options.chainImages,
      projectId: options.projectId
    });
    options.defaultNetwork = options.networks.find((n4) => {
      var _a;
      return n4.id === ((_a = options.defaultNetwork) == null ? void 0 : _a.id);
    });
  }
  initializeUniversalAdapter(options) {
    var _a, _b;
    this.universalAdapter = new UniversalAdapterClient(options);
    ChainController.initializeUniversalAdapter(this.universalAdapter, options.adapters || []);
    (_b = (_a = this.universalAdapter).construct) == null ? void 0 : _b.call(_a, this, options);
  }
  initializeAdapters(options) {
    var _a;
    ChainController.initialize(options.adapters || []);
    (_a = options.adapters) == null ? void 0 : _a.forEach((adapter) => {
      var _a2;
      (_a2 = adapter.construct) == null ? void 0 : _a2.call(adapter, this, options);
    });
  }
  setDefaultNetwork(options) {
    const extendedDefaultNetwork = options.defaultNetwork ? CaipNetworksUtil.extendCaipNetwork(options.defaultNetwork, {
      networkImageIds: PresetsUtil.NetworkImageIds,
      customNetworkImageUrls: options.chainImages,
      projectId: options.projectId
    }) : void 0;
    const previousNetwork = SafeLocalStorage.getItem(SafeLocalStorageKeys.ACTIVE_CAIP_NETWORK_ID);
    const caipNetwork = previousNetwork ? options.networks.find((n4) => n4.id === previousNetwork) : void 0;
    const network = caipNetwork ?? extendedDefaultNetwork ?? options.networks[0];
    ChainController.setActiveCaipNetwork(network);
  }
  async initOrContinue() {
    if (!this.initPromise && !isInitialized && CoreHelperUtil.isClient()) {
      isInitialized = true;
      this.initPromise = new Promise(async (resolve) => {
        await Promise.all([
          import("./esm-A5NKFU5Q.js"),
          import("./w3m-modal-PA2BXLDH.js")
        ]);
        const modal = document.createElement("w3m-modal");
        if (!OptionsController.state.disableAppend) {
          document.body.insertAdjacentElement("beforeend", modal);
        }
        resolve();
      });
    }
    return this.initPromise;
  }
};

// node_modules/@reown/appkit/dist/esm/package.json
var package_default = {
  name: "@reown/appkit",
  version: "1.0.4",
  type: "module",
  main: "./dist/esm/exports/index.js",
  types: "./dist/types/exports/index.d.ts",
  files: [
    "dist",
    "!tsconfig.tsbuildinfo"
  ],
  scripts: {
    "build:clean": "rm -rf dist",
    build: "tsc --build tsconfig.build.json",
    watch: "tsc --watch",
    typecheck: "tsc --noEmit",
    lint: "eslint . --ext .js,.jsx,.ts,.tsx",
    test: "vitest run --coverage.enabled=true --coverage.reporter=json --coverage.reporter=json-summary --coverage.reportOnFailure=true"
  },
  exports: {
    ".": {
      types: "./dist/types/exports/index.d.ts",
      import: "./dist/esm/exports/index.js",
      default: "./dist/esm/exports/index.js"
    },
    "./react": {
      types: "./dist/types/exports/react.d.ts",
      import: "./dist/esm/exports/react.js",
      default: "./dist/esm/exports/react.js"
    },
    "./vue": {
      types: "./dist/types/exports/vue.d.ts",
      import: "./dist/esm/exports/vue.js",
      default: "./dist/esm/exports/vue.js"
    },
    "./library/react": {
      types: "./dist/types/exports/library/react.d.ts",
      import: "./dist/esm/exports/library/react.js",
      default: "./dist/esm/exports/library/react.js"
    },
    "./library/vue": {
      types: "./dist/types/exports/library/vue.d.ts",
      import: "./dist/esm/exports/library/vue.js",
      default: "./dist/esm/exports/library/vue.js"
    },
    "./store": {
      types: "./dist/types/exports/store.d.ts",
      import: "./dist/esm/exports/store.js",
      default: "./dist/esm/exports/store.js"
    },
    "./utils": {
      types: "./dist/types/exports/utils.d.ts",
      import: "./dist/esm/exports/utils.js",
      default: "./dist/esm/exports/utils.js"
    },
    "./networks": {
      types: "./dist/types/exports/networks.d.ts",
      import: "./dist/esm/exports/networks.js",
      default: "./dist/esm/exports/networks.js"
    },
    "./auth-provider": {
      types: "./dist/types/exports/auth-provider.d.ts",
      import: "./dist/esm/exports/auth-provider.js",
      default: "./dist/esm/exports/auth-provider.js"
    }
  },
  typesVersions: {
    "*": {
      react: [
        "./dist/types/exports/react.d.ts"
      ],
      vue: [
        "./dist/types/exports/vue.d.ts"
      ],
      "library/react": [
        "./dist/types/exports/library/react.d.ts"
      ],
      "library/vue": [
        "./dist/types/exports/library/vue.d.ts"
      ],
      store: [
        "./dist/types/exports/store.d.ts"
      ],
      networks: [
        "./dist/types/exports/networks.d.ts"
      ],
      "auth-provider": [
        "./dist/types/exports/auth-provider.d.ts"
      ]
    }
  },
  dependencies: {
    "@walletconnect/universal-provider": "2.16.1",
    "@reown/appkit-common": "workspace:*",
    "@reown/appkit-core": "workspace:*",
    "@reown/appkit-polyfills": "workspace:*",
    "@reown/appkit-scaffold-ui": "workspace:*",
    "@reown/appkit-utils": "workspace:*",
    "@reown/appkit-siwe": "workspace:*",
    "@reown/appkit-ui": "workspace:*",
    "@reown/appkit-wallet": "workspace:*",
    "@walletconnect/types": "2.16.1",
    "@walletconnect/utils": "2.16.1",
    valtio: "1.11.2"
  },
  optionalDependencies: {
    borsh: "0.7.0",
    bs58: "5.0.0"
  },
  devDependencies: {
    "@types/react": "18.2.0",
    "@types/react-dom": "18.2.0",
    "@vitest/coverage-v8": "2.0.5",
    "@vue/runtime-core": "3.4.3",
    "@wagmi/connectors": "5.1.9",
    "@wagmi/core": "2.13.4",
    "@wallet-standard/app": "1.0.1",
    "@wallet-standard/base": "1.0.1",
    "@wallet-standard/features": "1.0.3",
    "@wallet-standard/wallet": "1.0.1",
    "@walletconnect/types": "2.13.3",
    "@walletconnect/universal-provider": "2.16.1",
    ethers: "6.13.2",
    ethers5: "npm:ethers@5.7.2",
    react: "18.2.0",
    "react-dom": "18.2.0",
    viem: "2.21.4",
    vitest: "2.0.5",
    vue: "3.4.3",
    wagmi: "2.12.9"
  },
  author: "Reown <support@reown.com> (https://reown.com)",
  license: "Apache-2.0",
  homepage: "https://github.com/WalletConnect/web3modal",
  repository: {
    type: "git",
    url: "git+https://github.com/WalletConnect/web3modal.git"
  },
  bugs: {
    url: "https://github.com/WalletConnect/web3modal/issues"
  }
};

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-account-button/index.js
var __decorate = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountButton = class W3mAccountButton2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.balance = "show";
    this.charsStart = 4;
    this.charsEnd = 6;
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.balanceVal = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.profileName = AccountController.state.profileName;
    this.profileImage = AccountController.state.profileImage;
    this.network = ChainController.state.activeCaipNetwork;
    this.networkImage = this.network ? AssetUtil.getNetworkImage(this.network) : void 0;
    this.isUnsupportedChain = NetworkController.state.isUnsupportedChain;
    this.unsubscribe.push(...[
      AssetController.subscribeNetworkImages(() => {
        var _a;
        this.networkImage = ((_a = this.network) == null ? void 0 : _a.imageId) ? AssetUtil.getNetworkImage(this.network) : void 0;
      }),
      ChainController.subscribeKey("activeCaipAddress", (val) => this.caipAddress = val),
      AccountController.subscribeKey("balance", (val) => this.balanceVal = val),
      AccountController.subscribeKey("balanceSymbol", (val) => this.balanceSymbol = val),
      AccountController.subscribeKey("profileName", (val) => this.profileName = val),
      AccountController.subscribeKey("profileImage", (val) => this.profileImage = val),
      ChainController.subscribeKey("activeCaipNetwork", (val) => {
        this.network = val;
        this.networkImage = (val == null ? void 0 : val.imageId) ? AssetUtil.getNetworkImage(val) : void 0;
      }),
      NetworkController.subscribeKey("isUnsupportedChain", (val) => {
        this.isUnsupportedChain = val;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const showBalance = this.balance === "show";
    return html`
      <wui-account-button
        .disabled=${Boolean(this.disabled)}
        .isUnsupportedChain=${this.isUnsupportedChain}
        address=${ifDefined(CoreHelperUtil.getPlainAddress(this.caipAddress))}
        profileName=${ifDefined(this.profileName)}
        networkSrc=${ifDefined(this.networkImage)}
        avatarSrc=${ifDefined(this.profileImage)}
        balance=${showBalance ? CoreHelperUtil.formatBalance(this.balanceVal, this.balanceSymbol) : ""}
        @click=${this.onClick.bind(this)}
        data-testid="account-button"
        .charsStart=${this.charsStart}
        .charsEnd=${this.charsEnd}
      >
      </wui-account-button>
    `;
  }
  onClick() {
    if (this.isUnsupportedChain) {
      ModalController.open({ view: "UnsupportedChain" });
    } else {
      ModalController.open();
    }
  }
};
__decorate([
  property({ type: Boolean })
], W3mAccountButton.prototype, "disabled", void 0);
__decorate([
  property()
], W3mAccountButton.prototype, "balance", void 0);
__decorate([
  property()
], W3mAccountButton.prototype, "charsStart", void 0);
__decorate([
  property()
], W3mAccountButton.prototype, "charsEnd", void 0);
__decorate([
  state()
], W3mAccountButton.prototype, "caipAddress", void 0);
__decorate([
  state()
], W3mAccountButton.prototype, "balanceVal", void 0);
__decorate([
  state()
], W3mAccountButton.prototype, "balanceSymbol", void 0);
__decorate([
  state()
], W3mAccountButton.prototype, "profileName", void 0);
__decorate([
  state()
], W3mAccountButton.prototype, "profileImage", void 0);
__decorate([
  state()
], W3mAccountButton.prototype, "network", void 0);
__decorate([
  state()
], W3mAccountButton.prototype, "networkImage", void 0);
__decorate([
  state()
], W3mAccountButton.prototype, "isUnsupportedChain", void 0);
W3mAccountButton = __decorate([
  customElement("w3m-account-button")
], W3mAccountButton);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-button/styles.js
var styles_default = css`
  :host {
    display: block;
    width: max-content;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-button/index.js
var __decorate2 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mButton = class W3mButton2 extends LitElement {
  constructor() {
    super(...arguments);
    this.unsubscribe = [];
    this.disabled = false;
    this.balance = void 0;
    this.size = void 0;
    this.label = void 0;
    this.loadingLabel = void 0;
    this.charsStart = 4;
    this.charsEnd = 6;
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.isLoading = ModalController.state.loading;
  }
  firstUpdated() {
    this.unsubscribe.push(ChainController.subscribeKey("activeCaipAddress", (val) => this.caipAddress = val), ModalController.subscribeKey("loading", (val) => this.isLoading = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return this.caipAddress && !this.isLoading ? html`
          <w3m-account-button
            .disabled=${Boolean(this.disabled)}
            balance=${ifDefined(this.balance)}
            .charsStart=${ifDefined(this.charsStart)}
            .charsEnd=${ifDefined(this.charsEnd)}
          >
          </w3m-account-button>
        ` : html`
          <w3m-connect-button
            size=${ifDefined(this.size)}
            label=${ifDefined(this.label)}
            loadingLabel=${ifDefined(this.loadingLabel)}
          ></w3m-connect-button>
        `;
  }
};
W3mButton.styles = styles_default;
__decorate2([
  property({ type: Boolean })
], W3mButton.prototype, "disabled", void 0);
__decorate2([
  property()
], W3mButton.prototype, "balance", void 0);
__decorate2([
  property()
], W3mButton.prototype, "size", void 0);
__decorate2([
  property()
], W3mButton.prototype, "label", void 0);
__decorate2([
  property()
], W3mButton.prototype, "loadingLabel", void 0);
__decorate2([
  property()
], W3mButton.prototype, "charsStart", void 0);
__decorate2([
  property()
], W3mButton.prototype, "charsEnd", void 0);
__decorate2([
  state()
], W3mButton.prototype, "caipAddress", void 0);
__decorate2([
  state()
], W3mButton.prototype, "isLoading", void 0);
W3mButton = __decorate2([
  customElement("w3m-button")
], W3mButton);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-connect-button/index.js
var __decorate3 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectButton = class W3mConnectButton2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.size = "md";
    this.label = "Connect Wallet";
    this.loadingLabel = "Connecting...";
    this.open = ModalController.state.open;
    this.loading = ModalController.state.loading;
    this.unsubscribe.push(ModalController.subscribe((val) => {
      this.open = val.open;
      this.loading = val.loading;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const isLoading = this.loading || this.open;
    return html`
      <wui-connect-button
        size=${ifDefined(this.size)}
        .loading=${isLoading}
        @click=${this.onClick.bind(this)}
        data-testid="connect-button"
      >
        ${isLoading ? this.loadingLabel : this.label}
      </wui-connect-button>
    `;
  }
  onClick() {
    if (this.open) {
      ModalController.close();
    } else if (!this.loading) {
      ModalController.open();
    }
  }
};
__decorate3([
  property()
], W3mConnectButton.prototype, "size", void 0);
__decorate3([
  property()
], W3mConnectButton.prototype, "label", void 0);
__decorate3([
  property()
], W3mConnectButton.prototype, "loadingLabel", void 0);
__decorate3([
  state()
], W3mConnectButton.prototype, "open", void 0);
__decorate3([
  state()
], W3mConnectButton.prototype, "loading", void 0);
W3mConnectButton = __decorate3([
  customElement("w3m-connect-button")
], W3mConnectButton);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-network-button/styles.js
var styles_default2 = css`
  :host {
    display: block;
    width: max-content;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-network-button/index.js
var __decorate4 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mNetworkButton = class W3mNetworkButton2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.network = ChainController.state.activeCaipNetwork;
    this.networkImage = this.network ? AssetUtil.getNetworkImage(this.network) : void 0;
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.loading = ModalController.state.loading;
    this.isUnsupportedChain = NetworkController.state.isUnsupportedChain;
    this.unsubscribe.push(...[
      AssetController.subscribeNetworkImages(() => {
        var _a;
        this.networkImage = ((_a = this.network) == null ? void 0 : _a.imageId) ? AssetUtil.getNetworkImage(this.network) : void 0;
      }),
      ChainController.subscribeKey("activeCaipAddress", (val) => {
        this.caipAddress = val;
      }),
      ChainController.subscribeKey("activeCaipNetwork", (val) => {
        this.network = val;
        this.networkImage = (val == null ? void 0 : val.imageId) ? AssetUtil.getNetworkImage(val) : void 0;
      }),
      ModalController.subscribeKey("loading", (val) => this.loading = val),
      NetworkController.subscribeKey("isUnsupportedChain", (val) => this.isUnsupportedChain = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      <wui-network-button
        data-testid="wui-network-button"
        .disabled=${Boolean(this.disabled || this.loading)}
        .isUnsupportedChain=${this.isUnsupportedChain}
        imageSrc=${ifDefined(this.networkImage)}
        @click=${this.onClick.bind(this)}
      >
        ${this.getLabel()}
        <slot></slot>
      </wui-network-button>
    `;
  }
  getLabel() {
    if (this.network) {
      return this.network.name;
    }
    if (this.label) {
      return this.label;
    }
    if (this.isUnsupportedChain) {
      return "Switch Network";
    }
    if (this.caipAddress) {
      return "Unknown Network";
    }
    return "Select Network";
  }
  onClick() {
    if (!this.loading) {
      EventsController.sendEvent({ type: "track", event: "CLICK_NETWORKS" });
      ModalController.open({ view: "Networks" });
    }
  }
};
W3mNetworkButton.styles = styles_default2;
__decorate4([
  property({ type: Boolean })
], W3mNetworkButton.prototype, "disabled", void 0);
__decorate4([
  property({ type: String })
], W3mNetworkButton.prototype, "label", void 0);
__decorate4([
  state()
], W3mNetworkButton.prototype, "network", void 0);
__decorate4([
  state()
], W3mNetworkButton.prototype, "networkImage", void 0);
__decorate4([
  state()
], W3mNetworkButton.prototype, "caipAddress", void 0);
__decorate4([
  state()
], W3mNetworkButton.prototype, "loading", void 0);
__decorate4([
  state()
], W3mNetworkButton.prototype, "isUnsupportedChain", void 0);
W3mNetworkButton = __decorate4([
  customElement("w3m-network-button")
], W3mNetworkButton);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-router/styles.js
var styles_default3 = css`
  :host {
    --prev-height: 0px;
    --new-height: 0px;
    display: block;
  }

  div.w3m-router-container {
    transform: translateY(0);
    opacity: 1;
  }

  div.w3m-router-container[view-direction='prev'] {
    animation:
      slide-left-out 150ms forwards ease,
      slide-left-in 150ms forwards ease;
    animation-delay: 0ms, 200ms;
  }

  div.w3m-router-container[view-direction='next'] {
    animation:
      slide-right-out 150ms forwards ease,
      slide-right-in 150ms forwards ease;
    animation-delay: 0ms, 200ms;
  }

  @keyframes slide-left-out {
    from {
      transform: translateX(0px);
      opacity: 1;
    }
    to {
      transform: translateX(10px);
      opacity: 0;
    }
  }

  @keyframes slide-left-in {
    from {
      transform: translateX(-10px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }

  @keyframes slide-right-out {
    from {
      transform: translateX(0px);
      opacity: 1;
    }
    to {
      transform: translateX(-10px);
      opacity: 0;
    }
  }

  @keyframes slide-right-in {
    from {
      transform: translateX(10px);
      opacity: 0;
    }
    to {
      transform: translateX(0);
      opacity: 1;
    }
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/ConstantsUtil.js
var ConstantsUtil4 = {
  ACCOUNT_TABS: [{ label: "Tokens" }, { label: "NFTs" }, { label: "Activity" }],
  SECURE_SITE_ORIGIN: process.env["NEXT_PUBLIC_SECURE_SITE_ORIGIN"] || "https://secure.walletconnect.org",
  VIEW_DIRECTION: {
    Next: "next",
    Prev: "prev"
  },
  ANIMATION_DURATIONS: {
    HeaderText: 120,
    ModalHeight: 150,
    ViewTransition: 150
  }
};

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-router/index.js
var __decorate5 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mRouter = class W3mRouter2 extends LitElement {
  constructor() {
    super();
    this.resizeObserver = void 0;
    this.prevHeight = "0px";
    this.prevHistoryLength = 1;
    this.unsubscribe = [];
    this.view = RouterController.state.view;
    this.viewDirection = "";
    this.unsubscribe.push(RouterController.subscribeKey("view", (val) => this.onViewChange(val)));
  }
  firstUpdated() {
    this.resizeObserver = new ResizeObserver(([content]) => {
      const height = `${content == null ? void 0 : content.contentRect.height}px`;
      if (this.prevHeight !== "0px") {
        this.style.setProperty("--prev-height", this.prevHeight);
        this.style.setProperty("--new-height", height);
        this.style.animation = "w3m-view-height 150ms forwards ease";
        this.style.height = "auto";
      }
      setTimeout(() => {
        this.prevHeight = height;
        this.style.animation = "unset";
      }, ConstantsUtil4.ANIMATION_DURATIONS.ModalHeight);
    });
    this.resizeObserver.observe(this.getWrapper());
  }
  disconnectedCallback() {
    var _a;
    (_a = this.resizeObserver) == null ? void 0 : _a.unobserve(this.getWrapper());
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`<div class="w3m-router-container" view-direction="${this.viewDirection}">
      ${this.viewTemplate()}
    </div>`;
  }
  viewTemplate() {
    switch (this.view) {
      case "AccountSettings":
        return html`<w3m-account-settings-view></w3m-account-settings-view>`;
      case "Account":
        return html`<w3m-account-view></w3m-account-view>`;
      case "AllWallets":
        return html`<w3m-all-wallets-view></w3m-all-wallets-view>`;
      case "ApproveTransaction":
        return html`<w3m-approve-transaction-view></w3m-approve-transaction-view>`;
      case "BuyInProgress":
        return html`<w3m-buy-in-progress-view></w3m-buy-in-progress-view>`;
      case "ChooseAccountName":
        return html`<w3m-choose-account-name-view></w3m-choose-account-name-view>`;
      case "Connect":
        return html`<w3m-connect-view></w3m-connect-view>`;
      case "ConnectingWalletConnect":
        return html`<w3m-connecting-wc-view></w3m-connecting-wc-view>`;
      case "ConnectingExternal":
        return html`<w3m-connecting-external-view></w3m-connecting-external-view>`;
      case "ConnectingSiwe":
        return html`<w3m-connecting-siwe-view></w3m-connecting-siwe-view>`;
      case "ConnectWallets":
        return html`<w3m-connect-wallets-view></w3m-connect-wallets-view>`;
      case "ConnectSocials":
        return html`<w3m-connect-socials-view></w3m-connect-socials-view>`;
      case "ConnectingSocial":
        return html`<w3m-connecting-social-view></w3m-connecting-social-view>`;
      case "Downloads":
        return html`<w3m-downloads-view></w3m-downloads-view>`;
      case "EmailVerifyOtp":
        return html`<w3m-email-verify-otp-view></w3m-email-verify-otp-view>`;
      case "EmailVerifyDevice":
        return html`<w3m-email-verify-device-view></w3m-email-verify-device-view>`;
      case "GetWallet":
        return html`<w3m-get-wallet-view></w3m-get-wallet-view>`;
      case "Networks":
        return html`<w3m-networks-view></w3m-networks-view>`;
      case "SwitchNetwork":
        return html`<w3m-network-switch-view></w3m-network-switch-view>`;
      case "Profile":
        return html`<w3m-profile-view></w3m-profile-view>`;
      case "SelectAddresses":
        return html`<w3m-select-addresses-view></w3m-select-addresses-view>`;
      case "SwitchAddress":
        return html`<w3m-switch-address-view></w3m-switch-address-view>`;
      case "Transactions":
        return html`<w3m-transactions-view></w3m-transactions-view>`;
      case "OnRampProviders":
        return html`<w3m-onramp-providers-view></w3m-onramp-providers-view>`;
      case "OnRampActivity":
        return html`<w3m-onramp-activity-view></w3m-onramp-activity-view>`;
      case "OnRampTokenSelect":
        return html`<w3m-onramp-token-select-view></w3m-onramp-token-select-view>`;
      case "OnRampFiatSelect":
        return html`<w3m-onramp-fiat-select-view></w3m-onramp-fiat-select-view>`;
      case "UpgradeEmailWallet":
        return html`<w3m-upgrade-wallet-view></w3m-upgrade-wallet-view>`;
      case "UpgradeToSmartAccount":
        return html`<w3m-upgrade-to-smart-account-view></w3m-upgrade-to-smart-account-view>`;
      case "UpdateEmailWallet":
        return html`<w3m-update-email-wallet-view></w3m-update-email-wallet-view>`;
      case "UpdateEmailPrimaryOtp":
        return html`<w3m-update-email-primary-otp-view></w3m-update-email-primary-otp-view>`;
      case "UpdateEmailSecondaryOtp":
        return html`<w3m-update-email-secondary-otp-view></w3m-update-email-secondary-otp-view>`;
      case "UnsupportedChain":
        return html`<w3m-unsupported-chain-view></w3m-unsupported-chain-view>`;
      case "Swap":
        return html`<w3m-swap-view></w3m-swap-view>`;
      case "SwapSelectToken":
        return html`<w3m-swap-select-token-view></w3m-swap-select-token-view>`;
      case "SwapPreview":
        return html`<w3m-swap-preview-view></w3m-swap-preview-view>`;
      case "WalletSend":
        return html`<w3m-wallet-send-view></w3m-wallet-send-view>`;
      case "WalletSendSelectToken":
        return html`<w3m-wallet-send-select-token-view></w3m-wallet-send-select-token-view>`;
      case "WalletSendPreview":
        return html`<w3m-wallet-send-preview-view></w3m-wallet-send-preview-view>`;
      case "WhatIsABuy":
        return html`<w3m-what-is-a-buy-view></w3m-what-is-a-buy-view>`;
      case "WalletReceive":
        return html`<w3m-wallet-receive-view></w3m-wallet-receive-view>`;
      case "WalletCompatibleNetworks":
        return html`<w3m-wallet-compatible-networks-view></w3m-wallet-compatible-networks-view>`;
      case "WhatIsAWallet":
        return html`<w3m-what-is-a-wallet-view></w3m-what-is-a-wallet-view>`;
      case "ConnectingMultiChain":
        return html`<w3m-connecting-multi-chain-view></w3m-connecting-multi-chain-view>`;
      case "WhatIsANetwork":
        return html`<w3m-what-is-a-network-view></w3m-what-is-a-network-view>`;
      case "ConnectingFarcaster":
        return html`<w3m-connecting-farcaster-view></w3m-connecting-farcaster-view>`;
      case "SwitchActiveChain":
        return html`<w3m-switch-active-chain-view></w3m-switch-active-chain-view>`;
      case "RegisterAccountName":
        return html`<w3m-register-account-name-view></w3m-register-account-name-view>`;
      case "RegisterAccountNameSuccess":
        return html`<w3m-register-account-name-success-view></w3m-register-account-name-success-view>`;
      default:
        return html`<w3m-connect-view></w3m-connect-view>`;
    }
  }
  onViewChange(newView) {
    TooltipController.hide();
    let direction = ConstantsUtil4.VIEW_DIRECTION.Next;
    const { history } = RouterController.state;
    if (history.length < this.prevHistoryLength) {
      direction = ConstantsUtil4.VIEW_DIRECTION.Prev;
    }
    this.prevHistoryLength = history.length;
    this.viewDirection = direction;
    setTimeout(() => {
      this.view = newView;
    }, ConstantsUtil4.ANIMATION_DURATIONS.ViewTransition);
  }
  getWrapper() {
    var _a;
    return (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("div");
  }
};
W3mRouter.styles = styles_default3;
__decorate5([
  state()
], W3mRouter.prototype, "view", void 0);
__decorate5([
  state()
], W3mRouter.prototype, "viewDirection", void 0);
W3mRouter = __decorate5([
  customElement("w3m-router")
], W3mRouter);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-onramp-widget/styles.js
var styles_default4 = css`
  :host > wui-flex {
    width: 100%;
    max-width: 360px;
  }

  :host > wui-flex > wui-flex {
    border-radius: var(--wui-border-radius-l);
    width: 100%;
  }

  .amounts-container {
    width: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/modal/w3m-onramp-widget/index.js
var __decorate6 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var PAYMENT_CURRENCY_SYMBOLS = {
  USD: "$",
  EUR: "",
  GBP: ""
};
var BUY_PRESET_AMOUNTS = [100, 250, 500, 1e3];
var W3mOnrampWidget = class W3mOnrampWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.disabled = false;
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.loading = ModalController.state.loading;
    this.paymentCurrency = OnRampController.state.paymentCurrency;
    this.paymentAmount = OnRampController.state.paymentAmount;
    this.purchaseAmount = OnRampController.state.purchaseAmount;
    this.quoteLoading = OnRampController.state.quotesLoading;
    this.unsubscribe.push(...[
      ChainController.subscribeKey("activeCaipAddress", (val) => this.caipAddress = val),
      ModalController.subscribeKey("loading", (val) => {
        this.loading = val;
      }),
      OnRampController.subscribe((val) => {
        this.paymentCurrency = val.paymentCurrency;
        this.paymentAmount = val.paymentAmount;
        this.purchaseAmount = val.purchaseAmount;
        this.quoteLoading = val.quotesLoading;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      <wui-flex flexDirection="column" justifyContent="center" alignItems="center">
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <w3m-onramp-input
            type="Fiat"
            @inputChange=${this.onPaymentAmountChange.bind(this)}
            .value=${this.paymentAmount || 0}
          ></w3m-onramp-input>
          <w3m-onramp-input
            type="Token"
            .value=${this.purchaseAmount || 0}
            .loading=${this.quoteLoading}
          ></w3m-onramp-input>
          <wui-flex justifyContent="space-evenly" class="amounts-container" gap="xs">
            ${BUY_PRESET_AMOUNTS.map((amount) => {
      var _a;
      return html`<wui-button
                  variant=${this.paymentAmount === amount ? "accent" : "neutral"}
                  size="md"
                  textVariant="paragraph-600"
                  fullWidth
                  @click=${() => this.selectPresetAmount(amount)}
                  >${`${PAYMENT_CURRENCY_SYMBOLS[((_a = this.paymentCurrency) == null ? void 0 : _a.id) || "USD"]} ${amount}`}</wui-button
                >`;
    })}
          </wui-flex>
          ${this.templateButton()}
        </wui-flex>
      </wui-flex>
    `;
  }
  templateButton() {
    return this.caipAddress ? html`<wui-button
          @click=${this.getQuotes.bind(this)}
          variant="main"
          fullWidth
          size="lg"
          borderRadius="xs"
        >
          Get quotes
        </wui-button>` : html`<wui-button
          @click=${this.openModal.bind(this)}
          variant="accent"
          fullWidth
          size="lg"
          borderRadius="xs"
        >
          Connect wallet
        </wui-button>`;
  }
  getQuotes() {
    if (!this.loading) {
      ModalController.open({ view: "OnRampProviders" });
    }
  }
  openModal() {
    ModalController.open({ view: "Connect" });
  }
  async onPaymentAmountChange(event) {
    OnRampController.setPaymentAmount(Number(event.detail));
    await OnRampController.getQuote();
  }
  async selectPresetAmount(amount) {
    OnRampController.setPaymentAmount(amount);
    await OnRampController.getQuote();
  }
};
W3mOnrampWidget.styles = styles_default4;
__decorate6([
  property({ type: Boolean })
], W3mOnrampWidget.prototype, "disabled", void 0);
__decorate6([
  state()
], W3mOnrampWidget.prototype, "caipAddress", void 0);
__decorate6([
  state()
], W3mOnrampWidget.prototype, "loading", void 0);
__decorate6([
  state()
], W3mOnrampWidget.prototype, "paymentCurrency", void 0);
__decorate6([
  state()
], W3mOnrampWidget.prototype, "paymentAmount", void 0);
__decorate6([
  state()
], W3mOnrampWidget.prototype, "purchaseAmount", void 0);
__decorate6([
  state()
], W3mOnrampWidget.prototype, "quoteLoading", void 0);
W3mOnrampWidget = __decorate6([
  customElement("w3m-onramp-widget")
], W3mOnrampWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-account-settings-view/index.js
var __decorate7 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountSettingsView = class W3mAccountSettingsView2 extends LitElement {
  constructor() {
    super();
    this.usubscribe = [];
    this.networkImages = AssetController.state.networkImages;
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.network = ChainController.state.activeCaipNetwork;
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.disconnecting = false;
    this.loading = false;
    this.switched = false;
    this.text = "";
    this.usubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileImage = val.profileImage;
          this.profileName = val.profileName;
          this.preferredAccountType = val.preferredAccountType;
        } else {
          ModalController.close();
        }
      }),
      AccountController.subscribeKey("preferredAccountType", (val) => this.preferredAccountType = val),
      ChainController.subscribeKey("activeCaipNetwork", (val) => {
        if (val == null ? void 0 : val.id) {
          this.network = val;
        }
      })
    ]);
  }
  disconnectedCallback() {
    this.usubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a, _b;
    if (!this.address) {
      throw new Error("w3m-account-settings-view: No account provided");
    }
    const networkImage = this.networkImages[((_a = this.network) == null ? void 0 : _a.imageId) ?? ""];
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="l"
        .padding=${["0", "xl", "m", "xl"]}
      >
        <wui-avatar
          alt=${this.address}
          address=${this.address}
          imageSrc=${ifDefined(this.profileImage)}
          size="2lg"
        ></wui-avatar>
        <wui-flex flexDirection="column" alignItems="center">
          <wui-flex gap="3xs" alignItems="center" justifyContent="center">
            <wui-text variant="title-6-600" color="fg-100" data-testid="account-settings-address">
              ${UiHelperUtil.getTruncateString({
      string: this.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}
            </wui-text>
            <wui-icon-link
              size="md"
              icon="copy"
              iconColor="fg-200"
              @click=${this.onCopyAddress}
            ></wui-icon-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
      <wui-flex flexDirection="column" gap="m">
        <wui-flex flexDirection="column" gap="xs" .padding=${["0", "l", "m", "l"]}>
          ${this.authCardTemplate()}
          <w3m-account-auth-button></w3m-account-auth-button>
          <wui-list-item
            .variant=${networkImage ? "image" : "icon"}
            iconVariant="overlay"
            icon="networkPlaceholder"
            imageSrc=${ifDefined(networkImage)}
            ?chevron=${this.isAllowedNetworkSwitch()}
            @click=${this.onNetworks.bind(this)}
            data-testid="account-switch-network-button"
          >
            <wui-text variant="paragraph-500" color="fg-100">
              ${((_b = this.network) == null ? void 0 : _b.name) ?? "Unknown"}
            </wui-text>
          </wui-list-item>
          ${this.togglePreferredAccountBtnTemplate()} ${this.chooseNameButtonTemplate()}
          <wui-list-item
            variant="icon"
            iconVariant="overlay"
            icon="disconnect"
            ?chevron=${false}
            .loading=${this.disconnecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
          </wui-list-item>
        </wui-flex>
      </wui-flex>
    `;
  }
  chooseNameButtonTemplate() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector || type !== "AUTH" || this.profileName) {
      return null;
    }
    return html`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="id"
        iconSize="sm"
        ?chevron=${true}
        @click=${this.onChooseName.bind(this)}
        data-testid="account-choose-name-button"
      >
        <wui-text variant="paragraph-500" color="fg-100">Choose account name </wui-text>
      </wui-list-item>
    `;
  }
  authCardTemplate() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    const { origin } = location;
    if (!authConnector || type !== "AUTH" || origin.includes(ConstantsUtil2.SECURE_SITE)) {
      return null;
    }
    return html`
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a self-custodial wallet"
        icon="wallet"
        data-testid="w3m-wallet-upgrade-card"
      ></wui-notice-card>
    `;
  }
  isAllowedNetworkSwitch() {
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
    const isValidNetwork = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.find(({ id }) => {
      var _a;
      return id === ((_a = this.network) == null ? void 0 : _a.id);
    });
    return isMultiNetwork || !isValidNetwork;
  }
  onCopyAddress() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
  togglePreferredAccountBtnTemplate() {
    const networkEnabled = NetworkController.checkIfSmartAccountEnabled();
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector || type !== "AUTH" || !networkEnabled) {
      return null;
    }
    if (!this.switched) {
      this.text = this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT ? "Switch to your EOA" : "Switch to your smart account";
    }
    return html`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon="swapHorizontalBold"
        iconSize="sm"
        ?chevron=${true}
        ?loading=${this.loading}
        @click=${this.changePreferredAccountType.bind(this)}
        data-testid="account-toggle-preferred-account-type"
      >
        <wui-text variant="paragraph-500" color="fg-100">${this.text}</wui-text>
      </wui-list-item>
    `;
  }
  onChooseName() {
    RouterController.push("ChooseAccountName");
  }
  async changePreferredAccountType() {
    const smartAccountEnabled = NetworkController.checkIfSmartAccountEnabled();
    const accountTypeTarget = this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT || !smartAccountEnabled ? W3mFrameRpcConstants.ACCOUNT_TYPES.EOA : W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT;
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector) {
      return;
    }
    this.loading = true;
    await ConnectionController.setPreferredAccountType(accountTypeTarget);
    this.text = accountTypeTarget === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT ? "Switch to your EOA" : "Switch to your smart account";
    this.switched = true;
    SendController.resetSend();
    this.loading = false;
    this.requestUpdate();
  }
  onNetworks() {
    if (this.isAllowedNetworkSwitch()) {
      RouterController.push("Networks");
    }
  }
  async onDisconnect() {
    try {
      this.disconnecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_SUCCESS" });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconnecting = false;
    }
  }
  onGoToUpgradeView() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_UPGRADE_FROM_MODAL" });
    RouterController.push("UpgradeEmailWallet");
  }
};
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "address", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "profileImage", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "profileName", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "network", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "preferredAccountType", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "disconnecting", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "loading", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "switched", void 0);
__decorate7([
  state()
], W3mAccountSettingsView.prototype, "text", void 0);
W3mAccountSettingsView = __decorate7([
  customElement("w3m-account-settings-view")
], W3mAccountSettingsView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-account-view/index.js
var __decorate8 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountView = class W3mAccountView2 extends LitElement {
  render() {
    const connectedConnectorType = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    return html`
      ${authConnector && connectedConnectorType === "AUTH" ? this.walletFeaturesTemplate() : this.defaultTemplate()}
    `;
  }
  walletFeaturesTemplate() {
    return html`<w3m-account-wallet-features-widget></w3m-account-wallet-features-widget>`;
  }
  defaultTemplate() {
    return html`<w3m-account-default-widget></w3m-account-default-widget>`;
  }
};
W3mAccountView = __decorate8([
  customElement("w3m-account-view")
], W3mAccountView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-all-wallets-view/index.js
var __decorate9 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAllWalletsView = class W3mAllWalletsView2 extends LitElement {
  constructor() {
    super(...arguments);
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
      this.search = value;
    });
  }
  render() {
    const isSearch = this.search.length >= 2;
    return html`
      <wui-flex .padding=${["0", "s", "s", "s"]} gap="s">
        <wui-search-bar @inputChange=${this.onInputChange.bind(this)}></wui-search-bar>
        ${this.qrButtonTemplate()}
      </wui-flex>
      ${isSearch ? html`<w3m-all-wallets-search query=${this.search}></w3m-all-wallets-search>` : html`<w3m-all-wallets-list></w3m-all-wallets-list>`}
    `;
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  qrButtonTemplate() {
    if (CoreHelperUtil.isMobile()) {
      return html`
        <wui-icon-box
          size="lg"
          iconSize="xl"
          iconColor="accent-100"
          backgroundColor="accent-100"
          icon="qrCode"
          background="transparent"
          border
          borderColor="wui-accent-glass-010"
          @click=${this.onWalletConnectQr.bind(this)}
        ></wui-icon-box>
      `;
    }
    return null;
  }
  onWalletConnectQr() {
    RouterController.push("ConnectingWalletConnect");
  }
};
__decorate9([
  state()
], W3mAllWalletsView.prototype, "search", void 0);
W3mAllWalletsView = __decorate9([
  customElement("w3m-all-wallets-view")
], W3mAllWalletsView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-buy-in-progress-view/styles.js
var styles_default5 = css`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-visual {
    width: var(--wui-wallet-image-size-lg);
    height: var(--wui-wallet-image-size-lg);
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    position: relative;
    overflow: hidden;
  }

  wui-visual::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition:
      opacity var(--wui-ease-out-power-2) var(--wui-duration-lg),
      transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }

  wui-link {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-buy-in-progress-view/index.js
var __decorate10 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mBuyInProgressView = class W3mBuyInProgressView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedOnRampProvider = OnRampController.state.selectedProvider;
    this.uri = ConnectionController.state.wcUri;
    this.ready = false;
    this.showRetry = false;
    this.buffering = false;
    this.error = false;
    this.startTime = null;
    this.isMobile = false;
    this.onRetry = void 0;
    this.unsubscribe.push(...[
      OnRampController.subscribeKey("selectedProvider", (val) => {
        this.selectedOnRampProvider = val;
      })
    ]);
    this.watchTransactions();
  }
  disconnectedCallback() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
  }
  render() {
    var _a, _b;
    let label = "Continue in external window";
    if (this.error) {
      label = "Buy failed";
    } else if (this.selectedOnRampProvider) {
      label = `Buy in ${(_a = this.selectedOnRampProvider) == null ? void 0 : _a.label}`;
    }
    const subLabel = this.error ? "Buy can be declined from your side or due to and error on the provider app" : `Well notify you once your Buy is processed`;
    return html`
      <wui-flex
        data-error=${ifDefined(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-visual
            name=${ifDefined((_b = this.selectedOnRampProvider) == null ? void 0 : _b.name)}
            size="lg"
            class="provider-image"
          >
          </wui-visual>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${label}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        ${this.error ? this.tryAgainTemplate() : null}
      </wui-flex>

      <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
        <wui-link @click=${this.onCopyUri} color="fg-200">
          <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
          Copy link
        </wui-link>
      </wui-flex>
    `;
  }
  watchTransactions() {
    if (!this.selectedOnRampProvider) {
      return;
    }
    switch (this.selectedOnRampProvider.name) {
      case "coinbase":
        this.startTime = Date.now();
        this.initializeCoinbaseTransactions();
        break;
      default:
        break;
    }
  }
  async initializeCoinbaseTransactions() {
    await this.watchCoinbaseTransactions();
    this.intervalId = setInterval(() => this.watchCoinbaseTransactions(), 4e3);
  }
  async watchCoinbaseTransactions() {
    try {
      const address = AccountController.state.address;
      const projectId = OptionsController.state.projectId;
      if (!address) {
        throw new Error("No address found");
      }
      const coinbaseResponse = await BlockchainApiController.fetchTransactions({
        account: address,
        onramp: "coinbase",
        projectId
      });
      const newTransactions = coinbaseResponse.data.filter((tx) => new Date(tx.metadata.minedAt) > new Date(this.startTime) || tx.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS");
      if (newTransactions.length) {
        clearInterval(this.intervalId);
        RouterController.replace("OnRampActivity");
      } else if (this.startTime && Date.now() - this.startTime >= 18e4) {
        clearInterval(this.intervalId);
        this.error = true;
      }
    } catch (error) {
      SnackController.showError(error);
    }
  }
  onTryAgain() {
    if (!this.selectedOnRampProvider) {
      return;
    }
    this.error = false;
    CoreHelperUtil.openHref(this.selectedOnRampProvider.url, "popupWindow", "width=600,height=800,scrollbars=yes");
  }
  tryAgainTemplate() {
    var _a;
    if (!((_a = this.selectedOnRampProvider) == null ? void 0 : _a.url)) {
      return null;
    }
    return html`<wui-button size="md" variant="accent" @click=${this.onTryAgain.bind(this)}>
      <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
      Try again
    </wui-button>`;
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return html`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  onCopyUri() {
    var _a;
    if (!((_a = this.selectedOnRampProvider) == null ? void 0 : _a.url)) {
      SnackController.showError("No link found");
      RouterController.goBack();
      return;
    }
    try {
      CoreHelperUtil.copyToClopboard(this.selectedOnRampProvider.url);
      SnackController.showSuccess("Link copied");
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mBuyInProgressView.styles = styles_default5;
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "intervalId", void 0);
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "selectedOnRampProvider", void 0);
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "uri", void 0);
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "ready", void 0);
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "showRetry", void 0);
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "buffering", void 0);
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "error", void 0);
__decorate10([
  state()
], W3mBuyInProgressView.prototype, "startTime", void 0);
__decorate10([
  property({ type: Boolean })
], W3mBuyInProgressView.prototype, "isMobile", void 0);
__decorate10([
  property()
], W3mBuyInProgressView.prototype, "onRetry", void 0);
W3mBuyInProgressView = __decorate10([
  customElement("w3m-buy-in-progress-view")
], W3mBuyInProgressView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connect-view/styles.js
var styles_default6 = css`
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    scrollbar-width: none;
    overflow-y: scroll;
    overflow-x: hidden;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }

  .all-wallets {
    flex-flow: column;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connect-view/index.js
var __decorate11 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectView = class W3mConnectView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.authConnector = this.connectors.find((c5) => c5.type === "AUTH");
    this.features = OptionsController.state.features;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => {
      this.connectors = val;
      this.authConnector = this.connectors.find((c5) => c5.type === "AUTH");
    }), OptionsController.subscribeKey("features", (val) => this.features = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      <wui-flex flexDirection="column" .padding=${["3xs", "s", "s", "s"]}>
        <w3m-email-login-widget></w3m-email-login-widget>
        <w3m-social-login-widget></w3m-social-login-widget>
        ${this.walletListTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  walletListTemplate() {
    var _a, _b;
    const socials = (_a = this.features) == null ? void 0 : _a.socials;
    const emailShowWallets = (_b = this.features) == null ? void 0 : _b.emailShowWallets;
    const enableWallets = OptionsController.state.enableWallets;
    if (!enableWallets) {
      return null;
    }
    if (this.authConnector && socials) {
      if (this.authConnector && emailShowWallets) {
        return html`
          <wui-flex flexDirection="column" gap="xs" .margin=${["xs", "0", "0", "0"]}>
            <w3m-connector-list></w3m-connector-list>
            <wui-flex class="all-wallets">
              <w3m-all-wallets-widget></w3m-all-wallets-widget>
            </wui-flex>
          </wui-flex>
        `;
      }
      return html`<wui-list-button
        @click=${this.onContinueWalletClick.bind(this)}
        text="Continue with a wallet"
      ></wui-list-button>`;
    }
    return html`<w3m-wallet-login-list></w3m-wallet-login-list>`;
  }
  onContinueWalletClick() {
    RouterController.push("ConnectWallets");
  }
};
W3mConnectView.styles = styles_default6;
__decorate11([
  state()
], W3mConnectView.prototype, "connectors", void 0);
__decorate11([
  state()
], W3mConnectView.prototype, "authConnector", void 0);
__decorate11([
  state()
], W3mConnectView.prototype, "features", void 0);
W3mConnectView = __decorate11([
  customElement("w3m-connect-view")
], W3mConnectView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/w3m-connecting-widget/styles.js
var styles_default7 = css`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition-property: opacity, transform;
    transition-duration: var(--wui-duration-lg);
    transition-timing-function: var(--wui-ease-out-power-2);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/w3m-connecting-widget/index.js
var __decorate12 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWidget = class extends LitElement {
  constructor() {
    var _a, _b, _c, _d;
    super();
    this.wallet = (_a = RouterController.state.data) == null ? void 0 : _a.wallet;
    this.connector = (_b = RouterController.state.data) == null ? void 0 : _b.connector;
    this.timeout = void 0;
    this.secondaryBtnLabel = "Try again";
    this.secondaryBtnIcon = "refresh";
    this.secondaryLabel = "Accept connection request in the wallet";
    this.onConnect = void 0;
    this.onRender = void 0;
    this.onAutoConnect = void 0;
    this.isWalletConnect = true;
    this.unsubscribe = [];
    this.imageSrc = AssetUtil.getWalletImage(this.wallet) ?? AssetUtil.getConnectorImage(this.connector);
    this.name = ((_c = this.wallet) == null ? void 0 : _c.name) ?? ((_d = this.connector) == null ? void 0 : _d.name) ?? "Wallet";
    this.isRetrying = false;
    this.uri = ConnectionController.state.wcUri;
    this.error = ConnectionController.state.wcError;
    this.ready = false;
    this.showRetry = false;
    this.buffering = false;
    this.isMobile = false;
    this.onRetry = void 0;
    this.unsubscribe.push(...[
      ConnectionController.subscribeKey("wcUri", (val) => {
        var _a2;
        this.uri = val;
        if (this.isRetrying && this.onRetry) {
          this.isRetrying = false;
          (_a2 = this.onConnect) == null ? void 0 : _a2.call(this);
        }
      }),
      ConnectionController.subscribeKey("wcError", (val) => this.error = val),
      ConnectionController.subscribeKey("buffering", (val) => this.buffering = val)
    ]);
  }
  firstUpdated() {
    var _a;
    (_a = this.onAutoConnect) == null ? void 0 : _a.call(this);
    this.showRetry = !this.onAutoConnect;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    clearTimeout(this.timeout);
  }
  render() {
    var _a;
    (_a = this.onRender) == null ? void 0 : _a.call(this);
    this.onShowRetry();
    const subLabel = this.error ? "Connection can be declined if a previous request is still active" : this.secondaryLabel;
    let label = `Continue in ${this.name}`;
    if (this.buffering) {
      label = "Connecting...";
    }
    if (this.error) {
      label = "Connection declined";
    }
    return html`
      <wui-flex
        data-error=${ifDefined(this.error)}
        data-retry=${this.showRetry}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image size="lg" imageSrc=${ifDefined(this.imageSrc)}></wui-wallet-image>

          ${this.error ? null : this.loaderTemplate()}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text variant="paragraph-500" color=${this.error ? "error-100" : "fg-100"}>
            ${label}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        <wui-button
          variant="accent"
          size="md"
          ?disabled=${!this.error && this.buffering}
          @click=${this.onTryAgain.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name=${this.secondaryBtnIcon}></wui-icon>
          ${this.secondaryBtnLabel}
        </wui-button>
      </wui-flex>

      ${this.isWalletConnect ? html`
            <wui-flex .padding=${["0", "xl", "xl", "xl"]} justifyContent="center">
              <wui-link @click=${this.onCopyUri} color="fg-200">
                <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
                Copy link
              </wui-link>
            </wui-flex>
          ` : null}

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onShowRetry() {
    var _a;
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("wui-button");
      retryButton == null ? void 0 : retryButton.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onTryAgain() {
    var _a, _b;
    if (!this.buffering) {
      ConnectionController.setWcError(false);
      if (this.onRetry) {
        this.isRetrying = true;
        (_a = this.onRetry) == null ? void 0 : _a.call(this);
      } else {
        (_b = this.onConnect) == null ? void 0 : _b.call(this);
      }
    }
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return html`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  onCopyUri() {
    try {
      if (this.uri) {
        CoreHelperUtil.copyToClopboard(this.uri);
        SnackController.showSuccess("Link copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mConnectingWidget.styles = styles_default7;
__decorate12([
  state()
], W3mConnectingWidget.prototype, "uri", void 0);
__decorate12([
  state()
], W3mConnectingWidget.prototype, "error", void 0);
__decorate12([
  state()
], W3mConnectingWidget.prototype, "ready", void 0);
__decorate12([
  state()
], W3mConnectingWidget.prototype, "showRetry", void 0);
__decorate12([
  state()
], W3mConnectingWidget.prototype, "buffering", void 0);
__decorate12([
  property({ type: Boolean })
], W3mConnectingWidget.prototype, "isMobile", void 0);
__decorate12([
  property()
], W3mConnectingWidget.prototype, "onRetry", void 0);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-external-view/index.js
var __decorate13 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingExternalView = class W3mConnectingExternalView2 extends W3mConnectingWidget {
  constructor() {
    super();
    this.externalViewUnsubscribe = [];
    if (!this.connector) {
      throw new Error("w3m-connecting-view: No connector provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: {
        name: this.connector.name ?? "Unknown",
        platform: "browser"
      }
    });
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    this.isWalletConnect = false;
    this.externalViewUnsubscribe.push(ChainController.subscribeKey("activeCaipAddress", (val) => {
      if (val) {
        ModalController.close();
      }
    }));
  }
  disconnectedCallback() {
    this.externalViewUnsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  async onConnectProxy() {
    try {
      this.error = false;
      if (this.connector) {
        if (this.connector.id !== ConstantsUtil3.COINBASE_SDK_CONNECTOR_ID || !this.error) {
          await ConnectionController.connectExternal(this.connector, this.connector.chain);
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: { method: "browser", name: this.connector.name || "Unknown" }
          });
        }
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
W3mConnectingExternalView = __decorate13([
  customElement("w3m-connecting-external-view")
], W3mConnectingExternalView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-multi-chain-view/styles.js
var styles_default8 = css`
  wui-flex,
  wui-list-wallet {
    width: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-multi-chain-view/index.js
var __decorate14 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingMultiChainView = class W3mConnectingMultiChainView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.activeConnector = ChainController.state.activeConnector;
    this.unsubscribe.push(...[ChainController.subscribeKey("activeConnector", (val) => this.activeConnector = val)]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a;
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["m", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-wallet-image
            size="lg"
            imageSrc=${ifDefined(AssetUtil.getConnectorImage(this.activeConnector))}
          ></wui-wallet-image>
        </wui-flex>
        <wui-flex
          flexDirection="column"
          alignItems="center"
          gap="xs"
          .padding=${["0", "s", "0", "s"]}
        >
          <wui-text variant="paragraph-500" color="fg-100">
            Select Chain for ${(_a = this.activeConnector) == null ? void 0 : _a.name}
          </wui-text>
          <wui-text align="center" variant="small-500" color="fg-200"
            >Select which chain to connect to your multi chain wallet</wui-text
          >
        </wui-flex>
        <wui-flex
          flexGrow="1"
          flexDirection="column"
          alignItems="center"
          gap="xs"
          .padding=${["xs", "0", "xs", "0"]}
        >
          ${this.networksTemplate()}
        </wui-flex>
      </wui-flex>
    `;
  }
  networksTemplate() {
    var _a, _b;
    return (_b = (_a = this.activeConnector) == null ? void 0 : _a.connectors) == null ? void 0 : _b.map((connector) => connector.name ? html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getChainImage(connector.chain))}
              name=${ConstantsUtil.CHAIN_NAME_MAP[connector.chain]}
              @click=${() => this.onConnector(connector)}
            ></wui-list-wallet>
          ` : null);
  }
  onConnector(provider) {
    var _a, _b;
    const connector = (_b = (_a = this.activeConnector) == null ? void 0 : _a.connectors) == null ? void 0 : _b.find((p3) => p3.chain === provider.chain);
    if (!connector) {
      SnackController.showError("Failed to find connector");
      return;
    }
    if (connector.type === "WALLET_CONNECT") {
      if (CoreHelperUtil.isMobile()) {
        RouterController.push("AllWallets");
      } else {
        RouterController.push("ConnectingWalletConnect");
      }
    } else {
      RouterController.push("ConnectingExternal", {
        connector
      });
    }
  }
};
W3mConnectingMultiChainView.styles = styles_default8;
__decorate14([
  state()
], W3mConnectingMultiChainView.prototype, "activeConnector", void 0);
W3mConnectingMultiChainView = __decorate14([
  customElement("w3m-connecting-multi-chain-view")
], W3mConnectingMultiChainView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-wc-view/index.js
var __decorate15 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWcView = class W3mConnectingWcView2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.interval = void 0;
    this.lastRetry = Date.now();
    this.wallet = (_a = RouterController.state.data) == null ? void 0 : _a.wallet;
    this.platform = void 0;
    this.platforms = [];
    this.initializeConnection();
    this.interval = setInterval(this.initializeConnection.bind(this), ConstantsUtil2.TEN_SEC_MS);
  }
  disconnectedCallback() {
    clearTimeout(this.interval);
  }
  render() {
    if (!this.wallet) {
      return html`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
    }
    this.determinePlatforms();
    return html`
      ${this.headerTemplate()}
      <div>${this.platformTemplate()}</div>
    `;
  }
  async initializeConnection(retry = false) {
    try {
      const { wcPairingExpiry } = ConnectionController.state;
      if (retry || CoreHelperUtil.isPairingExpired(wcPairingExpiry)) {
        await ConnectionController.connectWalletConnect();
        this.finalizeConnection();
        if (StorageUtil.getConnectedConnector() === "AUTH" && OptionsController.state.hasMultipleAddresses) {
          RouterController.push("SelectAddresses");
        } else {
          ModalController.close();
        }
      }
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      ConnectionController.setWcError(true);
      if (CoreHelperUtil.isAllowedRetry(this.lastRetry)) {
        SnackController.showError("Declined");
        this.lastRetry = Date.now();
        this.initializeConnection(true);
      }
    }
  }
  finalizeConnection() {
    var _a;
    const { wcLinking, recentWallet } = ConnectionController.state;
    if (wcLinking) {
      StorageUtil.setWalletConnectDeepLink(wcLinking);
    }
    if (recentWallet) {
      StorageUtil.setAppKitRecent(recentWallet);
    }
    EventsController.sendEvent({
      type: "track",
      event: "CONNECT_SUCCESS",
      properties: {
        method: wcLinking ? "mobile" : "qrcode",
        name: ((_a = this.wallet) == null ? void 0 : _a.name) || "Unknown"
      }
    });
  }
  determinePlatforms() {
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-view:determinePlatforms No wallet");
    }
    if (this.platform) {
      return;
    }
    const { mobile_link, desktop_link, webapp_link, injected, rdns } = this.wallet;
    const injectedIds = injected == null ? void 0 : injected.map(({ injected_id }) => injected_id).filter(Boolean);
    const browserIds = rdns ? [rdns] : injectedIds ?? [];
    const isBrowser = OptionsController.state.isUniversalProvider ? false : browserIds.length;
    const isMobileWc = mobile_link;
    const isWebWc = webapp_link;
    const isBrowserInstalled = ConnectionController.checkInstalled(browserIds);
    const isBrowserWc = isBrowser && isBrowserInstalled;
    const isDesktopWc = desktop_link && !CoreHelperUtil.isMobile();
    if (isBrowserWc) {
      this.platforms.push("browser");
    }
    if (isMobileWc) {
      this.platforms.push(CoreHelperUtil.isMobile() ? "mobile" : "qrcode");
    }
    if (isWebWc) {
      this.platforms.push("web");
    }
    if (isDesktopWc) {
      this.platforms.push("desktop");
    }
    if (!isBrowserWc && isBrowser) {
      this.platforms.push("unsupported");
    }
    this.platform = this.platforms[0];
  }
  platformTemplate() {
    switch (this.platform) {
      case "browser":
        return html`<w3m-connecting-wc-browser></w3m-connecting-wc-browser>`;
      case "desktop":
        return html`
          <w3m-connecting-wc-desktop .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-desktop>
        `;
      case "web":
        return html`
          <w3m-connecting-wc-web .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-web>
        `;
      case "mobile":
        return html`
          <w3m-connecting-wc-mobile isMobile .onRetry=${() => this.initializeConnection(true)}>
          </w3m-connecting-wc-mobile>
        `;
      case "qrcode":
        return html`<w3m-connecting-wc-qrcode></w3m-connecting-wc-qrcode>`;
      default:
        return html`<w3m-connecting-wc-unsupported></w3m-connecting-wc-unsupported>`;
    }
  }
  headerTemplate() {
    const multiPlatform = this.platforms.length > 1;
    if (!multiPlatform) {
      return null;
    }
    return html`
      <w3m-connecting-header
        .platforms=${this.platforms}
        .onSelectPlatfrom=${this.onSelectPlatform.bind(this)}
      >
      </w3m-connecting-header>
    `;
  }
  async onSelectPlatform(platform) {
    var _a;
    const container = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("div");
    if (container) {
      await container.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.platform = platform;
      container.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
__decorate15([
  state()
], W3mConnectingWcView.prototype, "platform", void 0);
__decorate15([
  state()
], W3mConnectingWcView.prototype, "platforms", void 0);
W3mConnectingWcView = __decorate15([
  customElement("w3m-connecting-wc-view")
], W3mConnectingWcView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-choose-account-name-view/styles.js
var styles_default9 = css`
  .continue-button-container {
    width: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-choose-account-name-view/index.js
var __decorate16 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mChooseAccountNameView = class W3mChooseAccountNameView2 extends LitElement {
  constructor() {
    super(...arguments);
    this.loading = false;
  }
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="xxl"
        .padding=${["0", "0", "l", "0"]}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <wui-link
          @click=${() => {
      CoreHelperUtil.openHref(NavigationUtil.URLS.FAQ, "_blank");
    }}
        >
          Learn more about names
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-link>
      </wui-flex>
    `;
  }
  onboardingTemplate() {
    return html` <wui-flex
      flexDirection="column"
      gap="xxl"
      alignItems="center"
      .padding=${["0", "xxl", "0", "xxl"]}
    >
      <wui-flex gap="s" alignItems="center" justifyContent="center">
        <wui-icon-box
          icon="id"
          size="xl"
          iconSize="xxl"
          iconColor="fg-200"
          backgroundColor="fg-200"
        ></wui-icon-box>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="s">
        <wui-text align="center" variant="medium-600" color="fg-100">
          Choose your account name
        </wui-text>
        <wui-text align="center" variant="paragraph-400" color="fg-100">
          Finally say goodbye to 0x addresses, name your account to make it easier to exchange
          assets
        </wui-text>
      </wui-flex>
    </wui-flex>`;
  }
  buttonsTemplate() {
    return html`<wui-flex
      .padding=${["0", "2l", "0", "2l"]}
      gap="s"
      class="continue-button-container"
    >
      <wui-button
        fullWidth
        .loading=${this.loading}
        size="lg"
        borderRadius="xs"
        @click=${this.handleContinue.bind(this)}
        >Choose name
      </wui-button>
    </wui-flex>`;
  }
  handleContinue() {
    RouterController.push("RegisterAccountName");
    EventsController.sendEvent({
      type: "track",
      event: "OPEN_ENS_FLOW",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
  }
};
W3mChooseAccountNameView.styles = styles_default9;
__decorate16([
  state()
], W3mChooseAccountNameView.prototype, "loading", void 0);
W3mChooseAccountNameView = __decorate16([
  customElement("w3m-choose-account-name-view")
], W3mChooseAccountNameView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-downloads-view/index.js
var __decorate17 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mDownloadsView = class W3mDownloadsView2 extends LitElement {
  constructor() {
    var _a;
    super(...arguments);
    this.wallet = (_a = RouterController.state.data) == null ? void 0 : _a.wallet;
  }
  render() {
    if (!this.wallet) {
      throw new Error("w3m-downloads-view");
    }
    return html`
      <wui-flex gap="xs" flexDirection="column" .padding=${["s", "s", "l", "s"]}>
        ${this.chromeTemplate()} ${this.iosTemplate()} ${this.androidTemplate()}
        ${this.homepageTemplate()}
      </wui-flex>
    `;
  }
  chromeTemplate() {
    var _a;
    if (!((_a = this.wallet) == null ? void 0 : _a.chrome_store)) {
      return null;
    }
    return html`<wui-list-item
      variant="icon"
      icon="chromeStore"
      iconVariant="square"
      @click=${this.onChromeStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Chrome Extension</wui-text>
    </wui-list-item>`;
  }
  iosTemplate() {
    var _a;
    if (!((_a = this.wallet) == null ? void 0 : _a.app_store)) {
      return null;
    }
    return html`<wui-list-item
      variant="icon"
      icon="appStore"
      iconVariant="square"
      @click=${this.onAppStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">iOS App</wui-text>
    </wui-list-item>`;
  }
  androidTemplate() {
    var _a;
    if (!((_a = this.wallet) == null ? void 0 : _a.play_store)) {
      return null;
    }
    return html`<wui-list-item
      variant="icon"
      icon="playStore"
      iconVariant="square"
      @click=${this.onPlayStore.bind(this)}
      chevron
    >
      <wui-text variant="paragraph-500" color="fg-100">Android App</wui-text>
    </wui-list-item>`;
  }
  homepageTemplate() {
    var _a;
    if (!((_a = this.wallet) == null ? void 0 : _a.homepage)) {
      return null;
    }
    return html`
      <wui-list-item
        variant="icon"
        icon="browser"
        iconVariant="square-blue"
        @click=${this.onHomePage.bind(this)}
        chevron
      >
        <wui-text variant="paragraph-500" color="fg-100">Website</wui-text>
      </wui-list-item>
    `;
  }
  onChromeStore() {
    var _a;
    if ((_a = this.wallet) == null ? void 0 : _a.chrome_store) {
      CoreHelperUtil.openHref(this.wallet.chrome_store, "_blank");
    }
  }
  onAppStore() {
    var _a;
    if ((_a = this.wallet) == null ? void 0 : _a.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    var _a;
    if ((_a = this.wallet) == null ? void 0 : _a.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    var _a;
    if ((_a = this.wallet) == null ? void 0 : _a.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mDownloadsView = __decorate17([
  customElement("w3m-downloads-view")
], W3mDownloadsView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-get-wallet-view/index.js
var __decorate18 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var EXPLORER = "https://walletconnect.com/explorer";
var W3mGetWalletView = class W3mGetWalletView2 extends LitElement {
  render() {
    return html`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.recommendedWalletsTemplate()}
        <wui-list-wallet
          name="Explore all"
          showAllWallets
          walletIcon="allWallets"
          icon="externalLink"
          @click=${() => {
      CoreHelperUtil.openHref("https://walletconnect.com/explorer?type=wallet", "_blank");
    }}
        ></wui-list-wallet>
      </wui-flex>
    `;
  }
  recommendedWalletsTemplate() {
    const { recommended, featured } = ApiController.state;
    const { customWallets } = OptionsController.state;
    const wallets = [...featured, ...customWallets ?? [], ...recommended].slice(0, 4);
    return wallets.map((wallet) => html`
        <wui-list-wallet
          name=${wallet.name ?? "Unknown"}
          tagVariant="main"
          imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
          @click=${() => {
      CoreHelperUtil.openHref(wallet.homepage ?? EXPLORER, "_blank");
    }}
        ></wui-list-wallet>
      `);
  }
};
W3mGetWalletView = __decorate18([
  customElement("w3m-get-wallet-view")
], W3mGetWalletView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-register-account-name-view/styles.js
var styles_default10 = css`
  wui-flex {
    width: 100%;
  }

  .suggestion {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xs);
  }

  .suggestion:hover {
    background-color: var(--wui-color-gray-glass-005);
    cursor: pointer;
  }

  .suggested-name {
    max-width: 75%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  form {
    width: 100%;
  }

  wui-icon-link {
    position: absolute;
    right: 20px;
    transform: translateY(11px);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-register-account-name-view/index.js
var __decorate19 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mRegisterAccountNameView = class W3mRegisterAccountNameView2 extends LitElement {
  constructor() {
    super();
    this.formRef = createRef();
    this.usubscribe = [];
    this.name = "";
    this.error = "";
    this.loading = EnsController.state.loading;
    this.suggestions = EnsController.state.suggestions;
    this.registered = false;
    this.profileName = AccountController.state.profileName;
    this.onDebouncedNameInputChange = CoreHelperUtil.debounce((value) => {
      if (EnsController.validateName(value)) {
        this.error = "";
        this.name = value;
        EnsController.getSuggestions(value);
        EnsController.isNameRegistered(value).then((registered) => {
          this.registered = registered;
        });
      } else if (value.length < 4) {
        this.error = "Name must be at least 4 characters long";
      } else {
        this.error = "Can only contain letters, numbers and - characters";
      }
    });
    this.usubscribe.push(...[
      EnsController.subscribe((val) => {
        this.suggestions = val.suggestions;
        this.loading = val.loading;
      }),
      AccountController.subscribeKey("profileName", (val) => {
        this.profileName = val;
        if (val) {
          this.error = "You already own a name";
        }
      })
    ]);
  }
  firstUpdated() {
    var _a;
    (_a = this.formRef.value) == null ? void 0 : _a.addEventListener("keydown", this.onEnterKey.bind(this));
  }
  disconnectedCallback() {
    var _a;
    super.disconnectedCallback();
    this.usubscribe.forEach((unsub) => unsub());
    (_a = this.formRef.value) == null ? void 0 : _a.removeEventListener("keydown", this.onEnterKey.bind(this));
  }
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="m"
        .padding=${["0", "s", "m", "s"]}
      >
        <form ${ref2(this.formRef)} @submit=${this.onSubmitName.bind(this)}>
          <wui-ens-input
            @inputChange=${this.onNameInputChange.bind(this)}
            .errorMessage=${this.error}
            .value=${this.name}
          >
          </wui-ens-input>
          ${this.submitButtonTemplate()}
          <input type="submit" hidden />
        </form>
        ${this.templateSuggestions()}
      </wui-flex>
    `;
  }
  submitButtonTemplate() {
    const showSubmit = this.isAllowedToSubmit();
    return showSubmit ? html`
          <wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitName.bind(this)}
          >
          </wui-icon-link>
        ` : null;
  }
  onSelectSuggestion(name) {
    return () => {
      this.name = name;
      this.registered = false;
      this.requestUpdate();
    };
  }
  onNameInputChange(event) {
    this.onDebouncedNameInputChange(event.detail);
  }
  nameSuggestionTagTemplate() {
    if (this.loading) {
      return html`<wui-loading-spinner size="lg" color="fg-100"></wui-loading-spinner>`;
    }
    return this.registered ? html`<wui-tag variant="shade" size="lg">Registered</wui-tag>` : html`<wui-tag variant="success" size="lg">Available</wui-tag>`;
  }
  templateSuggestions() {
    if (!this.name || this.name.length < 4 || this.error) {
      return null;
    }
    const suggestions = this.registered ? this.suggestions.filter((s2) => s2.name !== this.name) : [];
    return html`<wui-flex flexDirection="column" gap="xxs" alignItems="center">
      <wui-flex
        data-testid="account-name-suggestion"
        .padding=${["m", "m", "m", "m"]}
        justifyContent="space-between"
        class="suggestion"
      >
        <wui-text color="fg-100" variant="paragraph-400" class="suggested-name">
          ${this.name}</wui-text
        >${this.nameSuggestionTagTemplate()}
      </wui-flex>
      ${suggestions.map((suggestion) => this.availableNameTemplate(suggestion.name))}
    </wui-flex>`;
  }
  availableNameTemplate(suggestion) {
    return html` <wui-flex
      data-testid="account-name-suggestion"
      .padding=${["m", "m", "m", "m"]}
      justifyContent="space-between"
      class="suggestion"
      @click=${this.onSelectSuggestion(suggestion)}
    >
      <wui-text color="fg-100" variant="paragraph-400" class="suggested-name">
        ${suggestion}
      </wui-text>
      <wui-tag variant="success" size="lg">Available</wui-tag>
    </wui-flex>`;
  }
  isAllowedToSubmit() {
    return !this.loading && !this.registered && !this.error && !this.profileName && EnsController.validateName(this.name);
  }
  async onSubmitName() {
    try {
      if (!this.isAllowedToSubmit()) {
        return;
      }
      const ensName = `${this.name}${ConstantsUtil.WC_NAME_SUFFIX}`;
      EventsController.sendEvent({
        type: "track",
        event: "REGISTER_NAME_INITIATED",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          ensName
        }
      });
      await EnsController.registerName(ensName);
      EventsController.sendEvent({
        type: "track",
        event: "REGISTER_NAME_SUCCESS",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          ensName
        }
      });
    } catch (error) {
      SnackController.showError(error.message);
      EventsController.sendEvent({
        type: "track",
        event: "REGISTER_NAME_ERROR",
        properties: {
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT,
          ensName: `${this.name}${ConstantsUtil.WC_NAME_SUFFIX}`,
          error: (error == null ? void 0 : error.message) || "Unknown error"
        }
      });
    }
  }
  onEnterKey(event) {
    if (event.key === "Enter" && this.isAllowedToSubmit()) {
      this.onSubmitName();
    }
  }
};
W3mRegisterAccountNameView.styles = styles_default10;
__decorate19([
  property()
], W3mRegisterAccountNameView.prototype, "errorMessage", void 0);
__decorate19([
  state()
], W3mRegisterAccountNameView.prototype, "name", void 0);
__decorate19([
  state()
], W3mRegisterAccountNameView.prototype, "error", void 0);
__decorate19([
  state()
], W3mRegisterAccountNameView.prototype, "loading", void 0);
__decorate19([
  state()
], W3mRegisterAccountNameView.prototype, "suggestions", void 0);
__decorate19([
  state()
], W3mRegisterAccountNameView.prototype, "registered", void 0);
__decorate19([
  state()
], W3mRegisterAccountNameView.prototype, "profileName", void 0);
W3mRegisterAccountNameView = __decorate19([
  customElement("w3m-register-account-name-view")
], W3mRegisterAccountNameView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-register-account-name-success-view/styles.js
var styles_default11 = css`
  .continue-button-container {
    width: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-register-account-name-success-view/index.js
var __decorate20 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mRegisterAccountNameSuccess = class W3mRegisterAccountNameSuccess2 extends LitElement {
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="xxl"
        .padding=${["0", "0", "l", "0"]}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <wui-link
          @click=${() => {
      CoreHelperUtil.openHref(NavigationUtil.URLS.FAQ, "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-link>
      </wui-flex>
    `;
  }
  onboardingTemplate() {
    return html` <wui-flex
      flexDirection="column"
      gap="xxl"
      alignItems="center"
      .padding=${["0", "xxl", "0", "xxl"]}
    >
      <wui-flex gap="s" alignItems="center" justifyContent="center">
        <wui-icon-box
          size="xl"
          iconcolor="success-100"
          backgroundcolor="success-100"
          icon="checkmark"
          background="opaque"
        ></wui-icon-box>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="s">
        <wui-text align="center" variant="medium-600" color="fg-100">
          Account name chosen successfully
        </wui-text>
        <wui-text align="center" variant="paragraph-400" color="fg-100">
          You can now fund your account and trade crypto
        </wui-text>
      </wui-flex>
    </wui-flex>`;
  }
  buttonsTemplate() {
    return html`<wui-flex
      .padding=${["0", "2l", "0", "2l"]}
      gap="s"
      class="continue-button-container"
    >
      <wui-button fullWidth size="lg" borderRadius="xs" @click=${this.redirectToAccount.bind(this)}
        >Let's Go!
      </wui-button>
    </wui-flex>`;
  }
  redirectToAccount() {
    RouterController.replace("Account");
  }
};
W3mRegisterAccountNameSuccess.styles = styles_default11;
W3mRegisterAccountNameSuccess = __decorate20([
  customElement("w3m-register-account-name-success-view")
], W3mRegisterAccountNameSuccess);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-network-switch-view/styles.js
var styles_default12 = css`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  wui-icon-box {
    position: absolute;
    right: 4px;
    bottom: 0;
    opacity: 0;
    transform: scale(0.5);
    z-index: 1;
  }

  wui-button {
    display: none;
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  wui-button[data-retry='true'] {
    display: block;
    opacity: 1;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-network-switch-view/index.js
var __decorate21 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mNetworkSwitchView = class W3mNetworkSwitchView2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.network = (_a = RouterController.state.data) == null ? void 0 : _a.network;
    this.unsubscribe = [];
    this.showRetry = false;
    this.error = false;
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    this.onSwitchNetwork();
  }
  render() {
    if (!this.network) {
      throw new Error("w3m-network-switch-view: No network provided");
    }
    this.onShowRetry();
    const label = this.getLabel();
    const subLabel = this.getSubLabel();
    return html`
      <wui-flex
        data-error=${this.error}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "3xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-network-image
            size="lg"
            imageSrc=${ifDefined(AssetUtil.getNetworkImage(this.network))}
          ></wui-network-image>

          ${this.error ? null : html`<wui-loading-hexagon></wui-loading-hexagon>`}

          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            ?border=${true}
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>

        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">${label}</wui-text>
          <wui-text align="center" variant="small-500" color="fg-200">${subLabel}</wui-text>
        </wui-flex>

        <wui-button
          data-retry=${this.showRetry}
          variant="accent"
          size="md"
          .disabled=${!this.error}
          @click=${this.onSwitchNetwork.bind(this)}
        >
          <wui-icon color="inherit" slot="iconLeft" name="refresh"></wui-icon>
          Try again
        </wui-button>
      </wui-flex>
    `;
  }
  getSubLabel() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    if (authConnector && type === "AUTH") {
      return "";
    }
    return this.error ? "Switch can be declined if chain is not supported by a wallet or previous request is still active" : "Accept connection request in your wallet";
  }
  getLabel() {
    var _a;
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    if (authConnector && type === "AUTH") {
      return `Switching to ${((_a = this.network) == null ? void 0 : _a.name) ?? "Unknown"} network...`;
    }
    return this.error ? "Switch declined" : "Approve in wallet";
  }
  onShowRetry() {
    var _a;
    if (this.error && !this.showRetry) {
      this.showRetry = true;
      const retryButton = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("wui-button");
      retryButton == null ? void 0 : retryButton.animate([{ opacity: 0 }, { opacity: 1 }], {
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  async onSwitchNetwork() {
    try {
      this.error = false;
      if (this.network) {
        await NetworkController.switchActiveNetwork(this.network);
      }
    } catch {
      this.error = true;
    }
  }
};
W3mNetworkSwitchView.styles = styles_default12;
__decorate21([
  state()
], W3mNetworkSwitchView.prototype, "showRetry", void 0);
__decorate21([
  state()
], W3mNetworkSwitchView.prototype, "error", void 0);
W3mNetworkSwitchView = __decorate21([
  customElement("w3m-network-switch-view")
], W3mNetworkSwitchView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-networks-view/styles.js
var styles_default13 = css`
  .container {
    max-height: 360px;
    overflow: auto;
  }

  .container::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-networks-view/index.js
var __decorate22 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mNetworksView = class W3mNetworksView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.network = ChainController.state.activeCaipNetwork;
    this.requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
      this.search = value;
    }, 100);
    this.unsubscribe.push(ChainController.subscribeKey("activeCaipNetwork", (val) => this.network = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      ${this.templateSearchInput()}
      <wui-flex
        class="container"
        .padding=${["0", "s", "s", "s"]}
        flexDirection="column"
        gap="xs"
      >
        ${this.networksTemplate()}
      </wui-flex>

      <wui-separator></wui-separator>

      <wui-flex padding="s" flexDirection="column" gap="m" alignItems="center">
        <wui-text variant="small-400" color="fg-300" align="center">
          Your connected wallet may not support some of the networks available for this dApp
        </wui-text>
        <wui-link @click=${this.onNetworkHelp.bind(this)}>
          <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
          What is a network
        </wui-link>
      </wui-flex>
    `;
  }
  templateSearchInput() {
    return html`
      <wui-flex gap="xs" .padding=${["0", "s", "s", "s"]}>
        <wui-input-text
          @inputChange=${this.onInputChange.bind(this)}
          class="network-search-input"
          size="md"
          placeholder="Search network"
          icon="search"
        ></wui-input-text>
      </wui-flex>
    `;
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  onNetworkHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_NETWORK_HELP" });
    RouterController.push("WhatIsANetwork");
  }
  networksTemplate() {
    var _a;
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const approvedCaipNetworkIds = NetworkController.state.approvedCaipNetworkIds;
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    if (this.search) {
      this.filteredNetworks = sortedNetworks == null ? void 0 : sortedNetworks.filter((network) => {
        var _a2;
        return (_a2 = network == null ? void 0 : network.name) == null ? void 0 : _a2.toLowerCase().includes(this.search.toLowerCase());
      });
    } else {
      this.filteredNetworks = sortedNetworks;
    }
    return (_a = this.filteredNetworks) == null ? void 0 : _a.map((network) => {
      var _a2;
      return html`
        <wui-list-network
          .selected=${((_a2 = this.network) == null ? void 0 : _a2.id) === network.id}
          imageSrc=${ifDefined(AssetUtil.getNetworkImage(network))}
          type="network"
          name=${network.name ?? network.id}
          @click=${() => this.onSwitchNetwork(network)}
          .disabled=${this.getNetworkDisabled(network)}
          data-testid=${`w3m-network-switch-${network.name ?? network.id}`}
        ></wui-list-network>
      `;
    });
  }
  getNetworkDisabled(network) {
    const networkNamespace = network.chainNamespace;
    const isNamespaceConnected = AccountController.getCaipAddress(networkNamespace);
    const approvedCaipNetworkIds = ChainController.getAllApprovedCaipNetworks();
    const supportsAllNetworks = ChainController.getNetworkProp("supportsAllNetworks", networkNamespace) !== false;
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    const isConnectedWithAuth = type === "AUTH" && authConnector;
    if (!isNamespaceConnected || supportsAllNetworks || isConnectedWithAuth) {
      return false;
    }
    return !(approvedCaipNetworkIds == null ? void 0 : approvedCaipNetworkIds.includes(network.id));
  }
  async onSwitchNetwork(network) {
    var _a;
    const isCurrentNamespaceConnected = AccountController.state.caipAddress;
    const isNamespaceConnected = AccountController.getCaipAddress(network.chainNamespace);
    const isSameNetwork = network.id === ((_a = this.network) == null ? void 0 : _a.id);
    const supportsAllNetworks = NetworkController.state.supportsAllNetworks;
    const routerData = RouterController.state.data;
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    const isConnectedWithAuth = type === "AUTH" && authConnector;
    if (isSameNetwork) {
      return;
    }
    if (isNamespaceConnected) {
      if (supportsAllNetworks || isConnectedWithAuth) {
        RouterController.push("SwitchNetwork", { ...routerData, network });
      } else {
        await NetworkController.switchActiveNetwork(network);
      }
    } else {
      if (ChainController.state.noAdapters) {
        RouterController.push("ConnectingWalletConnect");
      } else if (isConnectedWithAuth) {
        RouterController.push("SwitchNetwork", { ...routerData, network });
      } else {
        if (isCurrentNamespaceConnected) {
          RouterController.push("SwitchActiveChain", {
            switchToChain: network.chainNamespace,
            navigateTo: "Connect",
            navigateWithReplace: true,
            network
          });
        } else {
          NetworkController.setActiveCaipNetwork(network);
        }
      }
    }
  }
};
W3mNetworksView.styles = styles_default13;
__decorate22([
  state()
], W3mNetworksView.prototype, "network", void 0);
__decorate22([
  state()
], W3mNetworksView.prototype, "requestedCaipNetworks", void 0);
__decorate22([
  state()
], W3mNetworksView.prototype, "filteredNetworks", void 0);
__decorate22([
  state()
], W3mNetworksView.prototype, "search", void 0);
W3mNetworksView = __decorate22([
  customElement("w3m-networks-view")
], W3mNetworksView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-onramp-activity-view/styles.js
var styles_default14 = css`
  :host > wui-flex {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
    padding: var(--wui-spacing-m);
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: flex-start;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }

  :host > wui-flex > wui-flex {
    width: 100%;
  }

  wui-transaction-list-item-loader {
    width: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-onramp-activity-view/index.js
var __decorate23 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var LOADING_ITEM_COUNT = 7;
var W3mOnRampActivityView = class W3mOnRampActivityView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedOnRampProvider = OnRampController.state.selectedProvider;
    this.loading = false;
    this.coinbaseTransactions = TransactionsController.state.coinbaseTransactions;
    this.tokenImages = AssetController.state.tokenImages;
    this.unsubscribe.push(...[
      OnRampController.subscribeKey("selectedProvider", (val) => {
        this.selectedOnRampProvider = val;
      }),
      AssetController.subscribeKey("tokenImages", (val) => this.tokenImages = val),
      () => {
        clearTimeout(this.refetchTimeout);
      },
      TransactionsController.subscribe((val) => {
        this.coinbaseTransactions = { ...val.coinbaseTransactions };
      })
    ]);
    TransactionsController.clearCursor();
    this.fetchTransactions();
  }
  render() {
    return html`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.loading ? this.templateLoading() : this.templateTransactionsByYear()}
      </wui-flex>
    `;
  }
  templateTransactions(transactions) {
    return transactions == null ? void 0 : transactions.map((transaction) => {
      var _a, _b, _c;
      const date = DateUtil.formatDate((_a = transaction == null ? void 0 : transaction.metadata) == null ? void 0 : _a.minedAt);
      const transfer = transaction.transfers[0];
      const fungibleInfo = transfer == null ? void 0 : transfer.fungible_info;
      if (!fungibleInfo) {
        return null;
      }
      const icon = ((_b = fungibleInfo == null ? void 0 : fungibleInfo.icon) == null ? void 0 : _b.url) || ((_c = this.tokenImages) == null ? void 0 : _c[fungibleInfo.symbol || ""]);
      return html`
        <w3m-onramp-activity-item
          label="Bought"
          .completed=${transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_SUCCESS"}
          .inProgress=${transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS"}
          .failed=${transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_FAILED"}
          purchaseCurrency=${ifDefined(fungibleInfo.symbol)}
          purchaseValue=${transfer.quantity.numeric}
          date=${date}
          icon=${ifDefined(icon)}
          symbol=${ifDefined(fungibleInfo.symbol)}
        ></w3m-onramp-activity-item>
      `;
    });
  }
  templateTransactionsByYear() {
    const sortedYearKeys = Object.keys(this.coinbaseTransactions).sort().reverse();
    return sortedYearKeys.map((year) => {
      const yearInt = parseInt(year, 10);
      const sortedMonthIndexes = new Array(12).fill(null).map((_2, idx) => idx).reverse();
      return sortedMonthIndexes.map((month) => {
        var _a;
        const groupTitle = TransactionUtil.getTransactionGroupTitle(yearInt, month);
        const transactions = (_a = this.coinbaseTransactions[yearInt]) == null ? void 0 : _a[month];
        if (!transactions) {
          return null;
        }
        return html`
          <wui-flex flexDirection="column">
            <wui-flex
              alignItems="center"
              flexDirection="row"
              .padding=${["xs", "s", "s", "s"]}
            >
              <wui-text variant="paragraph-500" color="fg-200">${groupTitle}</wui-text>
            </wui-flex>
            <wui-flex flexDirection="column" gap="xs">
              ${this.templateTransactions(transactions)}
            </wui-flex>
          </wui-flex>
        `;
      });
    });
  }
  async fetchTransactions() {
    const provider = "coinbase";
    if (provider === "coinbase") {
      await this.fetchCoinbaseTransactions();
    }
  }
  async fetchCoinbaseTransactions() {
    const address = AccountController.state.address;
    const projectId = OptionsController.state.projectId;
    if (!address) {
      throw new Error("No address found");
    }
    if (!projectId) {
      throw new Error("No projectId found");
    }
    this.loading = true;
    await TransactionsController.fetchTransactions(address, "coinbase");
    this.loading = false;
    this.refetchLoadingTransactions();
  }
  refetchLoadingTransactions() {
    var _a;
    const today = /* @__PURE__ */ new Date();
    const currentMonthTxs = ((_a = this.coinbaseTransactions[today.getFullYear()]) == null ? void 0 : _a[today.getMonth()]) || [];
    const loadingTransactions = currentMonthTxs.filter((transaction) => transaction.metadata.status === "ONRAMP_TRANSACTION_STATUS_IN_PROGRESS");
    if (loadingTransactions.length === 0) {
      clearTimeout(this.refetchTimeout);
      return;
    }
    this.refetchTimeout = setTimeout(async () => {
      const address = AccountController.state.address;
      await TransactionsController.fetchTransactions(address, "coinbase");
      this.refetchLoadingTransactions();
    }, 3e3);
  }
  templateLoading() {
    return Array(LOADING_ITEM_COUNT).fill(html` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map((item) => item);
  }
};
W3mOnRampActivityView.styles = styles_default14;
__decorate23([
  state()
], W3mOnRampActivityView.prototype, "selectedOnRampProvider", void 0);
__decorate23([
  state()
], W3mOnRampActivityView.prototype, "loading", void 0);
__decorate23([
  state()
], W3mOnRampActivityView.prototype, "coinbaseTransactions", void 0);
__decorate23([
  state()
], W3mOnRampActivityView.prototype, "tokenImages", void 0);
W3mOnRampActivityView = __decorate23([
  customElement("w3m-onramp-activity-view")
], W3mOnRampActivityView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-onramp-fiat-select-view/styles.js
var styles_default15 = css`
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-onramp-fiat-select-view/index.js
var __decorate24 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mOnrampFiatSelectView = class W3mOnrampFiatSelectView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedCurrency = OnRampController.state.paymentCurrency;
    this.currencies = OnRampController.state.paymentCurrencies;
    this.currencyImages = AssetController.state.currencyImages;
    this.unsubscribe.push(...[
      OnRampController.subscribe((val) => {
        this.selectedCurrency = val.paymentCurrency;
        this.currencies = val.paymentCurrencies;
      }),
      AssetController.subscribeKey("currencyImages", (val) => this.currencyImages = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.currenciesTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  currenciesTemplate() {
    return this.currencies.map((currency) => {
      var _a;
      return html`
        <wui-list-item
          imageSrc=${ifDefined((_a = this.currencyImages) == null ? void 0 : _a[currency.id])}
          @click=${() => this.selectCurrency(currency)}
          variant="image"
        >
          <wui-text variant="paragraph-500" color="fg-100">${currency.id}</wui-text>
        </wui-list-item>
      `;
    });
  }
  selectCurrency(currency) {
    if (!currency) {
      return;
    }
    OnRampController.setPaymentCurrency(currency);
    ModalController.close();
  }
};
W3mOnrampFiatSelectView.styles = styles_default15;
__decorate24([
  state()
], W3mOnrampFiatSelectView.prototype, "selectedCurrency", void 0);
__decorate24([
  state()
], W3mOnrampFiatSelectView.prototype, "currencies", void 0);
__decorate24([
  state()
], W3mOnrampFiatSelectView.prototype, "currencyImages", void 0);
W3mOnrampFiatSelectView = __decorate24([
  customElement("w3m-onramp-fiat-select-view")
], W3mOnrampFiatSelectView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-onramp-providers-view/index.js
var __decorate25 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mOnRampProvidersView = class W3mOnRampProvidersView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.providers = OnRampController.state.providers;
    this.unsubscribe.push(...[
      OnRampController.subscribeKey("providers", (val) => {
        this.providers = val;
      })
    ]);
  }
  firstUpdated() {
    const urlPromises = this.providers.map(async (provider) => {
      if (provider.name === "coinbase") {
        return await this.getCoinbaseOnRampURL();
      }
      return Promise.resolve(provider == null ? void 0 : provider.url);
    });
    Promise.all(urlPromises).then((urls) => {
      this.providers = this.providers.map((provider, index) => ({
        ...provider,
        url: urls[index] || ""
      }));
    });
  }
  render() {
    return html`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.onRampProvidersTemplate()}
      </wui-flex>
      <w3m-onramp-providers-footer></w3m-onramp-providers-footer>
    `;
  }
  onRampProvidersTemplate() {
    return this.providers.filter((provider) => provider.supportedChains.includes(ChainController.state.activeChain ?? "eip155")).map((provider) => html`
          <w3m-onramp-provider-item
            label=${provider.label}
            name=${provider.name}
            feeRange=${provider.feeRange}
            @click=${() => {
      this.onClickProvider(provider);
    }}
            ?disabled=${!provider.url}
          ></w3m-onramp-provider-item>
        `);
  }
  onClickProvider(provider) {
    OnRampController.setSelectedProvider(provider);
    RouterController.push("BuyInProgress");
    CoreHelperUtil.openHref(provider.url, "popupWindow", "width=600,height=800,scrollbars=yes");
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_BUY_PROVIDER",
      properties: {
        provider: provider.name,
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
  }
  async getCoinbaseOnRampURL() {
    const address = AccountController.state.address;
    const network = ChainController.state.activeCaipNetwork;
    if (!address) {
      throw new Error("No address found");
    }
    if (!(network == null ? void 0 : network.name)) {
      throw new Error("No network found");
    }
    const defaultNetwork = ConstantsUtil2.WC_COINBASE_PAY_SDK_CHAIN_NAME_MAP[network.name] ?? ConstantsUtil2.WC_COINBASE_PAY_SDK_FALLBACK_CHAIN;
    const purchaseCurrency = OnRampController.state.purchaseCurrency;
    const assets = purchaseCurrency ? [purchaseCurrency.symbol] : OnRampController.state.purchaseCurrencies.map((currency) => currency.symbol);
    return await BlockchainApiController.generateOnRampURL({
      defaultNetwork,
      destinationWallets: [
        { address, blockchains: ConstantsUtil2.WC_COINBASE_PAY_SDK_CHAINS, assets }
      ],
      partnerUserId: address,
      purchaseAmount: OnRampController.state.purchaseAmount
    });
  }
};
__decorate25([
  state()
], W3mOnRampProvidersView.prototype, "providers", void 0);
W3mOnRampProvidersView = __decorate25([
  customElement("w3m-onramp-providers-view")
], W3mOnRampProvidersView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-onramp-tokens-select-view/styles.js
var styles_default16 = css`
  :host > wui-grid {
    max-height: 360px;
    overflow: auto;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-onramp-tokens-select-view/index.js
var __decorate26 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mOnrampTokensView = class W3mOnrampTokensView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.selectedCurrency = OnRampController.state.purchaseCurrencies;
    this.tokens = OnRampController.state.purchaseCurrencies;
    this.tokenImages = AssetController.state.tokenImages;
    this.unsubscribe.push(...[
      OnRampController.subscribe((val) => {
        this.selectedCurrency = val.purchaseCurrencies;
        this.tokens = val.purchaseCurrencies;
      }),
      AssetController.subscribeKey("tokenImages", (val) => this.tokenImages = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      <wui-flex flexDirection="column" .padding=${["0", "s", "s", "s"]} gap="xs">
        ${this.currenciesTemplate()}
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
  currenciesTemplate() {
    return this.tokens.map((token) => {
      var _a;
      return html`
        <wui-list-item
          imageSrc=${ifDefined((_a = this.tokenImages) == null ? void 0 : _a[token.symbol])}
          @click=${() => this.selectToken(token)}
          variant="image"
        >
          <wui-flex gap="3xs" alignItems="center">
            <wui-text variant="paragraph-500" color="fg-100">${token.name}</wui-text>
            <wui-text variant="small-400" color="fg-200">${token.symbol}</wui-text>
          </wui-flex>
        </wui-list-item>
      `;
    });
  }
  selectToken(currency) {
    if (!currency) {
      return;
    }
    OnRampController.setPurchaseCurrency(currency);
    ModalController.close();
  }
};
W3mOnrampTokensView.styles = styles_default16;
__decorate26([
  state()
], W3mOnrampTokensView.prototype, "selectedCurrency", void 0);
__decorate26([
  state()
], W3mOnrampTokensView.prototype, "tokens", void 0);
__decorate26([
  state()
], W3mOnrampTokensView.prototype, "tokenImages", void 0);
W3mOnrampTokensView = __decorate26([
  customElement("w3m-onramp-token-select-view")
], W3mOnrampTokensView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-swap-view/styles.js
var styles_default17 = css`
  :host > wui-flex:first-child {
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  .action-button {
    width: 100%;
    border-radius: var(--wui-border-radius-xs);
  }

  .action-button:disabled {
    border-color: 1px solid var(--wui-color-gray-glass-005);
  }

  .swap-inputs-container {
    position: relative;
  }

  .replace-tokens-button-container {
    display: flex;
    justify-content: center;
    align-items: center;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    gap: var(--wui-spacing-1xs);
    border-radius: var(--wui-border-radius-xs);
    background-color: var(--wui-color-modal-bg-base);
    padding: var(--wui-spacing-xxs);
  }

  .replace-tokens-button-container > button {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 40px;
    width: 40px;
    padding: var(--wui-spacing-xs);
    border: none;
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-duration-md) var(--wui-ease-out-power-1);
    will-change: background-color;
    z-index: 20;
  }

  .replace-tokens-button-container > button:hover {
    background: var(--wui-color-gray-glass-005);
  }

  .details-container > wui-flex {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    width: 100%;
  }

  .details-container > wui-flex > button {
    border: none;
    background: none;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    transition: background 0.2s linear;
  }

  .details-container > wui-flex > button:hover {
    background: var(--wui-color-gray-glass-002);
  }

  .details-content-container {
    padding: var(--wui-spacing-1xs);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .details-content-container > wui-flex {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s) var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-swap-view/index.js
var __decorate27 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSwapView = class W3mSwapView2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.unsubscribe = [];
    this.detailsOpen = false;
    this.caipNetworkId = (_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.id;
    this.initialized = SwapController.state.initialized;
    this.loadingQuote = SwapController.state.loadingQuote;
    this.loadingPrices = SwapController.state.loadingPrices;
    this.loadingTransaction = SwapController.state.loadingTransaction;
    this.sourceToken = SwapController.state.sourceToken;
    this.sourceTokenAmount = SwapController.state.sourceTokenAmount;
    this.sourceTokenPriceInUSD = SwapController.state.sourceTokenPriceInUSD;
    this.toToken = SwapController.state.toToken;
    this.toTokenAmount = SwapController.state.toTokenAmount;
    this.toTokenPriceInUSD = SwapController.state.toTokenPriceInUSD;
    this.inputError = SwapController.state.inputError;
    this.gasPriceInUSD = SwapController.state.gasPriceInUSD;
    this.fetchError = SwapController.state.fetchError;
    this.onDebouncedGetSwapCalldata = CoreHelperUtil.debounce(async () => {
      await SwapController.swapTokens();
    }, 200);
    ChainController.subscribeKey("activeCaipNetwork", (newCaipNetwork) => {
      if (this.caipNetworkId !== (newCaipNetwork == null ? void 0 : newCaipNetwork.id)) {
        this.caipNetworkId = newCaipNetwork == null ? void 0 : newCaipNetwork.id;
        SwapController.resetState();
        SwapController.initializeState();
      }
    });
    this.unsubscribe.push(...[
      ModalController.subscribeKey("open", (isOpen) => {
        if (!isOpen) {
          SwapController.resetState();
        }
      }),
      RouterController.subscribeKey("view", (newRoute) => {
        if (!newRoute.includes("Swap")) {
          SwapController.resetValues();
        }
      }),
      SwapController.subscribe((newState) => {
        this.initialized = newState.initialized;
        this.loadingQuote = newState.loadingQuote;
        this.loadingPrices = newState.loadingPrices;
        this.loadingTransaction = newState.loadingTransaction;
        this.sourceToken = newState.sourceToken;
        this.sourceTokenAmount = newState.sourceTokenAmount;
        this.sourceTokenPriceInUSD = newState.sourceTokenPriceInUSD;
        this.toToken = newState.toToken;
        this.toTokenAmount = newState.toTokenAmount;
        this.toTokenPriceInUSD = newState.toTokenPriceInUSD;
        this.inputError = newState.inputError;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.fetchError = newState.fetchError;
      })
    ]);
  }
  firstUpdated() {
    SwapController.initializeState();
    this.watchTokensAndValues();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe == null ? void 0 : unsubscribe());
    clearInterval(this.interval);
  }
  render() {
    return html`
      <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]} gap="s">
        ${this.initialized ? this.templateSwap() : this.templateLoading()}
      </wui-flex>
    `;
  }
  watchTokensAndValues() {
    this.interval = setInterval(() => {
      SwapController.getNetworkTokenPrice();
      SwapController.getMyTokensWithBalance();
      SwapController.swapTokens();
    }, 1e4);
  }
  templateSwap() {
    return html`
      <wui-flex flexDirection="column" gap="s">
        <wui-flex flexDirection="column" alignItems="center" gap="xs" class="swap-inputs-container">
          ${this.templateTokenInput("sourceToken", this.sourceToken)}
          ${this.templateTokenInput("toToken", this.toToken)} ${this.templateReplaceTokensButton()}
        </wui-flex>
        ${this.templateDetails()} ${this.templateActionButton()}
      </wui-flex>
    `;
  }
  actionButtonLabel() {
    if (this.fetchError) {
      return "Swap";
    }
    if (!this.sourceToken || !this.toToken) {
      return "Select token";
    }
    if (!this.sourceTokenAmount) {
      return "Enter amount";
    }
    if (this.inputError) {
      return this.inputError;
    }
    return "Review swap";
  }
  templateReplaceTokensButton() {
    return html`
      <wui-flex class="replace-tokens-button-container">
        <button @click=${this.onSwitchTokens.bind(this)}>
          <wui-icon name="recycleHorizontal" color="fg-250" size="lg"></wui-icon>
        </button>
      </wui-flex>
    `;
  }
  templateLoading() {
    return html`
      <wui-flex flexDirection="column" gap="l">
        <wui-flex flexDirection="column" alignItems="center" gap="xs" class="swap-inputs-container">
          <w3m-swap-input-skeleton target="sourceToken"></w3m-swap-input-skeleton>
          <w3m-swap-input-skeleton target="toToken"></w3m-swap-input-skeleton>
          ${this.templateReplaceTokensButton()}
        </wui-flex>
        ${this.templateActionButton()}
      </wui-flex>
    `;
  }
  templateTokenInput(target, token) {
    var _a, _b;
    const myToken = (_a = SwapController.state.myTokensWithBalance) == null ? void 0 : _a.find((ct3) => (ct3 == null ? void 0 : ct3.address) === (token == null ? void 0 : token.address));
    const amount = target === "toToken" ? this.toTokenAmount : this.sourceTokenAmount;
    const price = target === "toToken" ? this.toTokenPriceInUSD : this.sourceTokenPriceInUSD;
    let value = parseFloat(amount) * price;
    if (target === "toToken") {
      value -= this.gasPriceInUSD || 0;
    }
    return html`<w3m-swap-input
      .value=${target === "toToken" ? this.toTokenAmount : this.sourceTokenAmount}
      ?disabled=${this.loadingQuote && target === "toToken"}
      .onSetAmount=${this.handleChangeAmount.bind(this)}
      target=${target}
      .token=${token}
      .balance=${(_b = myToken == null ? void 0 : myToken.quantity) == null ? void 0 : _b.numeric}
      .price=${myToken == null ? void 0 : myToken.price}
      .marketValue=${value}
      .onSetMaxValue=${this.onSetMaxValue.bind(this)}
    ></w3m-swap-input>`;
  }
  onSetMaxValue(target, balance) {
    const token = target === "sourceToken" ? this.sourceToken : this.toToken;
    const isNetworkToken = (token == null ? void 0 : token.address) === NetworkController.getActiveNetworkTokenAddress();
    let value = "0";
    if (!balance) {
      value = "0";
      this.handleChangeAmount(target, value);
      return;
    }
    if (!this.gasPriceInUSD) {
      value = balance;
      this.handleChangeAmount(target, value);
      return;
    }
    const amountOfTokenGasRequires = NumberUtil.bigNumber(this.gasPriceInUSD.toFixed(5)).dividedBy(this.sourceTokenPriceInUSD);
    const maxValue = isNetworkToken ? NumberUtil.bigNumber(balance).minus(amountOfTokenGasRequires) : NumberUtil.bigNumber(balance);
    this.handleChangeAmount(target, maxValue.isGreaterThan(0) ? maxValue.toFixed(20) : "0");
  }
  templateDetails() {
    if (!this.sourceToken || !this.toToken || this.inputError) {
      return null;
    }
    return html`<w3m-swap-details .detailsOpen=${this.detailsOpen}></w3m-swap-details>`;
  }
  handleChangeAmount(target, value) {
    SwapController.clearError();
    if (target === "sourceToken") {
      SwapController.setSourceTokenAmount(value);
    } else {
      SwapController.setToTokenAmount(value);
    }
    this.onDebouncedGetSwapCalldata();
  }
  templateActionButton() {
    const haveNoTokenSelected = !this.toToken || !this.sourceToken;
    const haveNoAmount = !this.sourceTokenAmount;
    const loading = this.loadingQuote || this.loadingPrices || this.loadingTransaction;
    const disabled = loading || haveNoTokenSelected || haveNoAmount || this.inputError;
    return html` <wui-flex gap="xs">
      <wui-button
        data-testid="swap-action-button"
        class="action-button"
        fullWidth
        size="lg"
        borderRadius="xs"
        variant=${haveNoTokenSelected ? "neutral" : "main"}
        .loading=${loading}
        .disabled=${disabled}
        @click=${this.onSwapPreview.bind(this)}
      >
        ${this.actionButtonLabel()}
      </wui-button>
    </wui-flex>`;
  }
  onSwitchTokens() {
    SwapController.switchTokens();
  }
  onSwapPreview() {
    var _a, _b;
    if (this.fetchError) {
      SwapController.swapTokens();
      return;
    }
    EventsController.sendEvent({
      type: "track",
      event: "INITIATE_SWAP",
      properties: {
        network: this.caipNetworkId || "",
        swapFromToken: ((_a = this.sourceToken) == null ? void 0 : _a.symbol) || "",
        swapToToken: ((_b = this.toToken) == null ? void 0 : _b.symbol) || "",
        swapFromAmount: this.sourceTokenAmount || "",
        swapToAmount: this.toTokenAmount || "",
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("SwapPreview");
  }
};
W3mSwapView.styles = styles_default17;
__decorate27([
  state()
], W3mSwapView.prototype, "interval", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "detailsOpen", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "caipNetworkId", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "initialized", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "loadingQuote", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "loadingPrices", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "loadingTransaction", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "sourceToken", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "sourceTokenAmount", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "sourceTokenPriceInUSD", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "toToken", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "toTokenAmount", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "toTokenPriceInUSD", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "inputError", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "gasPriceInUSD", void 0);
__decorate27([
  state()
], W3mSwapView.prototype, "fetchError", void 0);
W3mSwapView = __decorate27([
  customElement("w3m-swap-view")
], W3mSwapView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-switch-active-chain-view/styles.js
var styles_default18 = css`
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }

  wui-loading-thumbnail {
    position: absolute;
  }

  wui-visual {
    width: var(--wui-wallet-image-size-lg);
    height: var(--wui-wallet-image-size-lg);
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    position: relative;
    overflow: hidden;
  }

  wui-visual::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-5xs) * 9 - var(--wui-border-radius-xxs));
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition:
      opacity var(--wui-ease-out-power-2) var(--wui-duration-lg),
      transform var(--wui-ease-out-power-2) var(--wui-duration-lg);
    will-change: opacity, transform;
  }

  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }

  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }

  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }

  [data-retry='false'] wui-link {
    display: none;
  }

  [data-retry='true'] wui-link {
    display: block;
    opacity: 1;
  }

  wui-link {
    padding: var(--wui-spacing-4xs) var(--wui-spacing-xxs);
  }

  .capitalize {
    text-transform: capitalize;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-switch-active-chain-view/index.js
var __decorate28 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSwitchActiveChainView = class W3mSwitchActiveChainView2 extends LitElement {
  constructor() {
    var _a, _b, _c, _d;
    super(...arguments);
    this.unsubscribe = [];
    this.switchToChain = (_a = RouterController.state.data) == null ? void 0 : _a.switchToChain;
    this.navigateTo = (_b = RouterController.state.data) == null ? void 0 : _b.navigateTo;
    this.navigateWithReplace = (_c = RouterController.state.data) == null ? void 0 : _c.navigateWithReplace;
    this.caipNetwork = (_d = RouterController.state.data) == null ? void 0 : _d.network;
    this.activeChain = ChainController.state.activeChain;
  }
  firstUpdated() {
    this.unsubscribe.push(ChainController.subscribeKey("activeChain", (val) => this.activeChain = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const switchedChainNameString = this.switchToChain ? ConstantsUtil.CHAIN_NAME_MAP[this.switchToChain] : "supported";
    if (!this.switchToChain) {
      return null;
    }
    const nextChainName = this.switchToChain === "eip155" ? "Ethereum" : this.switchToChain;
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" flexDirection="column" alignItems="center" gap="xl">
          <wui-visual
            name=${this.switchToChain === "eip155" ? "eth" : this.switchToChain}
          ></wui-visual>
          <wui-text
            data-testid=${`w3m-switch-active-chain-to-${nextChainName}`}
            variant="paragraph-500"
            color="fg-100"
            align="center"
            >Switch to <span class="capitalize">${nextChainName}</span></wui-text
          >
          <wui-text variant="small-400" color="fg-200" align="center">
            Connected wallet doesn't support connecting to ${switchedChainNameString} chain. You
            need to connect with a different wallet.
          </wui-text>
          <wui-button size="md" @click=${this.switchActiveChain.bind(this)}>Switch</wui-button>
        </wui-flex>
      </wui-flex>
    `;
  }
  async switchActiveChain() {
    if (!this.switchToChain) {
      return;
    }
    await NetworkController.switchActiveNetwork(this.caipNetwork);
    ModalController.close();
    ModalController.open({
      view: "Connect"
    });
  }
};
W3mSwitchActiveChainView.styles = styles_default18;
__decorate28([
  property()
], W3mSwitchActiveChainView.prototype, "activeChain", void 0);
W3mSwitchActiveChainView = __decorate28([
  customElement("w3m-switch-active-chain-view")
], W3mSwitchActiveChainView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-swap-preview-view/styles.js
var styles_default19 = css`
  :host > wui-flex:first-child {
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }

  .preview-container,
  .details-container {
    width: 100%;
  }

  .token-image {
    width: 24px;
    height: 24px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
    border-radius: 12px;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  .token-item {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-xxs);
    padding: var(--wui-spacing-xs);
    height: 40px;
    border: none;
    border-radius: 80px;
    background: var(--wui-color-gray-glass-002);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    cursor: pointer;
    transition: background 0.2s linear;
  }

  .token-item:hover {
    background: var(--wui-color-gray-glass-005);
  }

  .preview-token-details-container {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s) var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
  }

  .action-buttons-container {
    width: 100%;
    gap: var(--wui-spacing-xs);
  }

  .action-buttons-container > button {
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    height: 48px;
    border-radius: var(--wui-border-radius-xs);
    border: none;
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }

  .action-buttons-container > button:disabled {
    opacity: 0.8;
    cursor: not-allowed;
  }

  .action-button > wui-loading-spinner {
    display: inline-block;
  }

  .cancel-button:hover,
  .action-button:hover {
    cursor: pointer;
  }

  .action-buttons-container > wui-button.cancel-button {
    flex: 2;
  }

  .action-buttons-container > wui-button.action-button {
    flex: 4;
  }

  .action-buttons-container > button.action-button > wui-text {
    color: white;
  }

  .details-container > wui-flex {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    width: 100%;
  }

  .details-container > wui-flex > button {
    border: none;
    background: none;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    transition: background 0.2s linear;
  }

  .details-container > wui-flex > button:hover {
    background: var(--wui-color-gray-glass-002);
  }

  .details-content-container {
    padding: var(--wui-spacing-1xs);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .details-content-container > wui-flex {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s) var(--wui-spacing-xl);
    border-radius: var(--wui-border-radius-xxs);
    background: var(--wui-color-gray-glass-002);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-swap-preview-view/index.js
var __decorate29 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSwapPreviewView = class W3mSwapPreviewView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.detailsOpen = true;
    this.approvalTransaction = SwapController.state.approvalTransaction;
    this.swapTransaction = SwapController.state.swapTransaction;
    this.sourceToken = SwapController.state.sourceToken;
    this.sourceTokenAmount = SwapController.state.sourceTokenAmount ?? "";
    this.sourceTokenPriceInUSD = SwapController.state.sourceTokenPriceInUSD;
    this.toToken = SwapController.state.toToken;
    this.toTokenAmount = SwapController.state.toTokenAmount ?? "";
    this.toTokenPriceInUSD = SwapController.state.toTokenPriceInUSD;
    this.caipNetwork = ChainController.state.activeCaipNetwork;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.gasPriceInUSD = SwapController.state.gasPriceInUSD;
    this.inputError = SwapController.state.inputError;
    this.loadingQuote = SwapController.state.loadingQuote;
    this.loadingApprovalTransaction = SwapController.state.loadingApprovalTransaction;
    this.loadingBuildTransaction = SwapController.state.loadingBuildTransaction;
    this.loadingTransaction = SwapController.state.loadingTransaction;
    this.unsubscribe.push(...[
      AccountController.subscribeKey("balanceSymbol", (newBalanceSymbol) => {
        if (this.balanceSymbol !== newBalanceSymbol) {
          RouterController.goBack();
        }
      }),
      ChainController.subscribeKey("activeCaipNetwork", (newCaipNetwork) => {
        if (this.caipNetwork !== newCaipNetwork) {
          this.caipNetwork = newCaipNetwork;
        }
      }),
      SwapController.subscribe((newState) => {
        this.approvalTransaction = newState.approvalTransaction;
        this.swapTransaction = newState.swapTransaction;
        this.sourceToken = newState.sourceToken;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.toToken = newState.toToken;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.toTokenPriceInUSD = newState.toTokenPriceInUSD;
        this.sourceTokenAmount = newState.sourceTokenAmount ?? "";
        this.toTokenAmount = newState.toTokenAmount ?? "";
        this.inputError = newState.inputError;
        if (newState.inputError) {
          RouterController.goBack();
        }
        this.loadingQuote = newState.loadingQuote;
        this.loadingApprovalTransaction = newState.loadingApprovalTransaction;
        this.loadingBuildTransaction = newState.loadingBuildTransaction;
        this.loadingTransaction = newState.loadingTransaction;
      })
    ]);
  }
  firstUpdated() {
    SwapController.getTransaction();
    this.refreshTransaction();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe == null ? void 0 : unsubscribe());
    clearInterval(this.interval);
  }
  render() {
    return html`
      <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]} gap="s">
        ${this.templateSwap()}
      </wui-flex>
    `;
  }
  refreshTransaction() {
    this.interval = setInterval(() => {
      if (!SwapController.getApprovalLoadingState()) {
        SwapController.getTransaction();
      }
    }, 1e4);
  }
  templateSwap() {
    var _a, _b, _c, _d;
    const sourceTokenText = `${UiHelperUtil.formatNumberToLocalString(parseFloat(this.sourceTokenAmount))} ${(_a = this.sourceToken) == null ? void 0 : _a.symbol}`;
    const toTokenText = `${UiHelperUtil.formatNumberToLocalString(parseFloat(this.toTokenAmount))} ${(_b = this.toToken) == null ? void 0 : _b.symbol}`;
    const sourceTokenValue = parseFloat(this.sourceTokenAmount) * this.sourceTokenPriceInUSD;
    const toTokenValue = parseFloat(this.toTokenAmount) * this.toTokenPriceInUSD - (this.gasPriceInUSD || 0);
    const sentPrice = UiHelperUtil.formatNumberToLocalString(sourceTokenValue);
    const receivePrice = UiHelperUtil.formatNumberToLocalString(toTokenValue);
    const loading = this.loadingQuote || this.loadingBuildTransaction || this.loadingTransaction || this.loadingApprovalTransaction;
    return html`
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        <wui-flex class="preview-container" flexDirection="column" alignItems="flex-start" gap="l">
          <wui-flex
            class="preview-token-details-container"
            alignItems="center"
            justifyContent="space-between"
            gap="l"
          >
            <wui-flex flexDirection="column" alignItems="flex-start" gap="4xs">
              <wui-text variant="small-400" color="fg-150">Send</wui-text>
              <wui-text variant="paragraph-400" color="fg-100">$${sentPrice}</wui-text>
            </wui-flex>
            <wui-token-button
              flexDirection="row-reverse"
              text=${sourceTokenText}
              imageSrc=${(_c = this.sourceToken) == null ? void 0 : _c.logoUri}
            >
            </wui-token-button>
          </wui-flex>
          <wui-icon name="recycleHorizontal" color="fg-200" size="md"></wui-icon>
          <wui-flex
            class="preview-token-details-container"
            alignItems="center"
            justifyContent="space-between"
            gap="l"
          >
            <wui-flex flexDirection="column" alignItems="flex-start" gap="4xs">
              <wui-text variant="small-400" color="fg-150">Receive</wui-text>
              <wui-text variant="paragraph-400" color="fg-100">$${receivePrice}</wui-text>
            </wui-flex>
            <wui-token-button
              flexDirection="row-reverse"
              text=${toTokenText}
              imageSrc=${(_d = this.toToken) == null ? void 0 : _d.logoUri}
            >
            </wui-token-button>
          </wui-flex>
        </wui-flex>

        ${this.templateDetails()}

        <wui-flex flexDirection="row" alignItems="center" justifyContent="center" gap="xs">
          <wui-icon size="sm" color="fg-200" name="infoCircle"></wui-icon>
          <wui-text variant="small-400" color="fg-200">Review transaction carefully</wui-text>
        </wui-flex>

        <wui-flex
          class="action-buttons-container"
          flexDirection="row"
          alignItems="center"
          justifyContent="space-between"
          gap="xs"
        >
          <wui-button
            class="cancel-button"
            fullWidth
            size="lg"
            borderRadius="xs"
            variant="neutral"
            @click=${this.onCancelTransaction.bind(this)}
          >
            <wui-text variant="paragraph-600" color="fg-200">Cancel</wui-text>
          </wui-button>
          <wui-button
            class="action-button"
            fullWidth
            size="lg"
            borderRadius="xs"
            variant="main"
            ?loading=${loading}
            ?disabled=${loading}
            @click=${this.onSendTransaction.bind(this)}
          >
            <wui-text variant="paragraph-600" color="inverse-100">
              ${this.actionButtonLabel()}
            </wui-text>
          </wui-button>
        </wui-flex>
      </wui-flex>
    `;
  }
  templateDetails() {
    if (!this.sourceToken || !this.toToken || this.inputError) {
      return null;
    }
    return html`<w3m-swap-details .detailsOpen=${this.detailsOpen}></w3m-swap-details>`;
  }
  actionButtonLabel() {
    if (this.loadingApprovalTransaction) {
      return "Approving...";
    }
    if (this.approvalTransaction) {
      return "Approve";
    }
    return "Swap";
  }
  onCancelTransaction() {
    RouterController.goBack();
  }
  onSendTransaction() {
    if (this.approvalTransaction) {
      SwapController.sendTransactionForApproval(this.approvalTransaction);
    } else {
      SwapController.sendTransactionForSwap(this.swapTransaction);
    }
  }
};
W3mSwapPreviewView.styles = styles_default19;
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "interval", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "detailsOpen", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "approvalTransaction", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "swapTransaction", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "sourceToken", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "sourceTokenAmount", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "sourceTokenPriceInUSD", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "toToken", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "toTokenAmount", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "toTokenPriceInUSD", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "caipNetwork", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "balanceSymbol", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "gasPriceInUSD", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "inputError", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "loadingQuote", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "loadingApprovalTransaction", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "loadingBuildTransaction", void 0);
__decorate29([
  state()
], W3mSwapPreviewView.prototype, "loadingTransaction", void 0);
W3mSwapPreviewView = __decorate29([
  customElement("w3m-swap-preview-view")
], W3mSwapPreviewView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-swap-select-token-view/styles.js
var styles_default20 = css`
  :host {
    --tokens-scroll--top-opacity: 0;
    --tokens-scroll--bottom-opacity: 1;
    --suggested-tokens-scroll--left-opacity: 0;
    --suggested-tokens-scroll--right-opacity: 1;
  }

  :host > wui-flex:first-child {
    overflow-y: hidden;
    overflow-x: hidden;
    scrollbar-width: none;
    scrollbar-height: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }

  wui-loading-hexagon {
    position: absolute;
  }

  .suggested-tokens-container {
    overflow-x: auto;
    mask-image: linear-gradient(
      to right,
      rgba(0, 0, 0, calc(1 - var(--suggested-tokens-scroll--left-opacity))) 0px,
      rgba(200, 200, 200, calc(1 - var(--suggested-tokens-scroll--left-opacity))) 1px,
      black 50px,
      black 90px,
      black calc(100% - 90px),
      black calc(100% - 50px),
      rgba(155, 155, 155, calc(1 - var(--suggested-tokens-scroll--right-opacity))) calc(100% - 1px),
      rgba(0, 0, 0, calc(1 - var(--suggested-tokens-scroll--right-opacity))) 100%
    );
  }

  .suggested-tokens-container::-webkit-scrollbar {
    display: none;
  }

  .tokens-container {
    border-top: 1px solid var(--wui-color-gray-glass-005);
    height: 100%;
    max-height: 390px;
  }

  .tokens {
    width: 100%;
    overflow-y: auto;
    mask-image: linear-gradient(
      to bottom,
      rgba(0, 0, 0, calc(1 - var(--tokens-scroll--top-opacity))) 0px,
      rgba(200, 200, 200, calc(1 - var(--tokens-scroll--top-opacity))) 1px,
      black 50px,
      black 90px,
      black calc(100% - 90px),
      black calc(100% - 50px),
      rgba(155, 155, 155, calc(1 - var(--tokens-scroll--bottom-opacity))) calc(100% - 1px),
      rgba(0, 0, 0, calc(1 - var(--tokens-scroll--bottom-opacity))) 100%
    );
  }

  .network-search-input,
  .select-network-button {
    height: 40px;
  }

  .select-network-button {
    border: none;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
    background-color: transparent;
    border-radius: var(--wui-border-radius-xxs);
    padding: var(--wui-spacing-xs);
    align-items: center;
    transition: background-color 0.2s linear;
  }

  .select-network-button:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  .select-network-button > wui-image {
    width: 26px;
    height: 26px;
    border-radius: var(--wui-border-radius-xs);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-010);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-swap-select-token-view/index.js
var __decorate30 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSwapSelectTokenView = class W3mSwapSelectTokenView2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.unsubscribe = [];
    this.targetToken = (_a = RouterController.state.data) == null ? void 0 : _a.target;
    this.sourceToken = SwapController.state.sourceToken;
    this.sourceTokenAmount = SwapController.state.sourceTokenAmount;
    this.toToken = SwapController.state.toToken;
    this.myTokensWithBalance = SwapController.state.myTokensWithBalance;
    this.popularTokens = SwapController.state.popularTokens;
    this.searchValue = "";
    this.unsubscribe.push(...[
      SwapController.subscribe((newState) => {
        this.sourceToken = newState.sourceToken;
        this.toToken = newState.toToken;
        this.myTokensWithBalance = newState.myTokensWithBalance;
      })
    ]);
  }
  updated() {
    var _a, _b;
    const suggestedTokensContainer = (_a = this.renderRoot) == null ? void 0 : _a.querySelector(".suggested-tokens-container");
    suggestedTokensContainer == null ? void 0 : suggestedTokensContainer.addEventListener("scroll", this.handleSuggestedTokensScroll.bind(this));
    const tokensList = (_b = this.renderRoot) == null ? void 0 : _b.querySelector(".tokens");
    tokensList == null ? void 0 : tokensList.addEventListener("scroll", this.handleTokenListScroll.bind(this));
  }
  disconnectedCallback() {
    var _a, _b;
    super.disconnectedCallback();
    const suggestedTokensContainer = (_a = this.renderRoot) == null ? void 0 : _a.querySelector(".suggested-tokens-container");
    const tokensList = (_b = this.renderRoot) == null ? void 0 : _b.querySelector(".tokens");
    suggestedTokensContainer == null ? void 0 : suggestedTokensContainer.removeEventListener("scroll", this.handleSuggestedTokensScroll.bind(this));
    tokensList == null ? void 0 : tokensList.removeEventListener("scroll", this.handleTokenListScroll.bind(this));
    clearInterval(this.interval);
  }
  render() {
    return html`
      <wui-flex flexDirection="column" gap="s">
        ${this.templateSearchInput()} ${this.templateSuggestedTokens()} ${this.templateTokens()}
      </wui-flex>
    `;
  }
  onSelectToken(token) {
    if (this.targetToken === "sourceToken") {
      SwapController.setSourceToken(token);
    } else {
      SwapController.setToToken(token);
      if (this.sourceToken && this.sourceTokenAmount) {
        SwapController.swapTokens();
      }
    }
    RouterController.goBack();
  }
  templateSearchInput() {
    return html`
      <wui-flex .padding=${["3xs", "s", "0", "s"]} gap="xs">
        <wui-input-text
          data-testid="swap-select-token-search-input"
          class="network-search-input"
          size="sm"
          placeholder="Search token"
          icon="search"
          .value=${this.searchValue}
          @inputChange=${this.onSearchInputChange.bind(this)}
        ></wui-input-text>
      </wui-flex>
    `;
  }
  templateTokens() {
    const yourTokens = this.myTokensWithBalance ? Object.values(this.myTokensWithBalance) : [];
    const tokens = this.popularTokens ? this.popularTokens : [];
    const filteredYourTokens = this.filterTokensWithText(yourTokens, this.searchValue);
    const filteredTokens = this.filterTokensWithText(tokens, this.searchValue);
    return html`
      <wui-flex class="tokens-container">
        <wui-flex class="tokens" .padding=${["0", "s", "s", "s"]} flexDirection="column">
          ${(filteredYourTokens == null ? void 0 : filteredYourTokens.length) > 0 ? html`
                <wui-flex justifyContent="flex-start" padding="s">
                  <wui-text variant="paragraph-500" color="fg-200">Your tokens</wui-text>
                </wui-flex>
                ${filteredYourTokens.map((token) => {
      var _a, _b, _c;
      const selected = token.symbol === ((_a = this.sourceToken) == null ? void 0 : _a.symbol) || token.symbol === ((_b = this.toToken) == null ? void 0 : _b.symbol);
      return html`
                    <wui-token-list-item
                      data-testid="swap-select-token-item-${token.symbol}"
                      name=${token.name}
                      ?disabled=${selected}
                      symbol=${token.symbol}
                      price=${token == null ? void 0 : token.price}
                      amount=${(_c = token == null ? void 0 : token.quantity) == null ? void 0 : _c.numeric}
                      imageSrc=${token.logoUri}
                      @click=${() => {
        if (!selected) {
          this.onSelectToken(token);
        }
      }}
                    >
                    </wui-token-list-item>
                  `;
    })}
              ` : null}

          <wui-flex justifyContent="flex-start" padding="s">
            <wui-text variant="paragraph-500" color="fg-200">Tokens</wui-text>
          </wui-flex>
          ${(filteredTokens == null ? void 0 : filteredTokens.length) > 0 ? filteredTokens.map((token) => html`
                  <wui-token-list-item
                    data-testid="swap-select-token-item-${token.symbol}"
                    name=${token.name}
                    symbol=${token.symbol}
                    imageSrc=${token.logoUri}
                    @click=${() => this.onSelectToken(token)}
                  >
                  </wui-token-list-item>
                `) : null}
        </wui-flex>
      </wui-flex>
    `;
  }
  templateSuggestedTokens() {
    const tokens = SwapController.state.suggestedTokens ? SwapController.state.suggestedTokens.slice(0, 8) : null;
    if (!tokens) {
      return null;
    }
    return html`
      <wui-flex class="suggested-tokens-container" .padding=${["0", "s", "0", "s"]} gap="xs">
        ${tokens.map((token) => html`
            <wui-token-button
              text=${token.symbol}
              imageSrc=${token.logoUri}
              @click=${() => this.onSelectToken(token)}
            >
            </wui-token-button>
          `)}
      </wui-flex>
    `;
  }
  onSearchInputChange(event) {
    this.searchValue = event.detail;
  }
  handleSuggestedTokensScroll() {
    var _a;
    const container = (_a = this.renderRoot) == null ? void 0 : _a.querySelector(".suggested-tokens-container");
    if (!container) {
      return;
    }
    container.style.setProperty("--suggested-tokens-scroll--left-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollLeft).toString());
    container.style.setProperty("--suggested-tokens-scroll--right-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollWidth - container.scrollLeft - container.offsetWidth).toString());
  }
  handleTokenListScroll() {
    var _a;
    const container = (_a = this.renderRoot) == null ? void 0 : _a.querySelector(".tokens");
    if (!container) {
      return;
    }
    container.style.setProperty("--tokens-scroll--top-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollTop).toString());
    container.style.setProperty("--tokens-scroll--bottom-opacity", MathUtil.interpolate([0, 100], [0, 1], container.scrollHeight - container.scrollTop - container.offsetHeight).toString());
  }
  filterTokensWithText(tokens, text) {
    return tokens.filter((token) => `${token.symbol} ${token.name} ${token.address}`.toLowerCase().includes(text.toLowerCase()));
  }
};
W3mSwapSelectTokenView.styles = styles_default20;
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "interval", void 0);
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "targetToken", void 0);
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "sourceToken", void 0);
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "sourceTokenAmount", void 0);
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "toToken", void 0);
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "myTokensWithBalance", void 0);
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "popularTokens", void 0);
__decorate30([
  state()
], W3mSwapSelectTokenView.prototype, "searchValue", void 0);
W3mSwapSelectTokenView = __decorate30([
  customElement("w3m-swap-select-token-view")
], W3mSwapSelectTokenView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-transactions-view/styles.js
var styles_default21 = css`
  :host > wui-flex:first-child {
    height: 500px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  :host > wui-flex:first-child::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-transactions-view/index.js
var __decorate31 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mTransactionsView = class W3mTransactionsView2 extends LitElement {
  render() {
    return html`
      <wui-flex flexDirection="column" .padding=${["0", "m", "m", "m"]} gap="s">
        <w3m-activity-list page="activity"></w3m-activity-list>
      </wui-flex>
    `;
  }
};
W3mTransactionsView.styles = styles_default21;
W3mTransactionsView = __decorate31([
  customElement("w3m-transactions-view")
], W3mTransactionsView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-what-is-a-network-view/index.js
var __decorate32 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var data = [
  {
    images: ["network", "layers", "system"],
    title: "The systems nuts and bolts",
    text: "A network is what brings the blockchain to life, as this technical infrastructure allows apps to access the ledger and smart contract services."
  },
  {
    images: ["noun", "defiAlt", "dao"],
    title: "Designed for different uses",
    text: "Each network is designed differently, and may therefore suit certain apps and experiences."
  }
];
var W3mWhatIsANetworkView = class W3mWhatIsANetworkView2 extends LitElement {
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data}></w3m-help-widget>
        <wui-button
          variant="main"
          size="md"
          @click=${() => {
      CoreHelperUtil.openHref("https://ethereum.org/en/developers/docs/networks/", "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-button>
      </wui-flex>
    `;
  }
};
W3mWhatIsANetworkView = __decorate32([
  customElement("w3m-what-is-a-network-view")
], W3mWhatIsANetworkView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-what-is-a-wallet-view/index.js
var __decorate33 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var data2 = [
  {
    images: ["login", "profile", "lock"],
    title: "One login for all of web3",
    text: "Log in to any app by connecting your wallet. Say goodbye to countless passwords!"
  },
  {
    images: ["defi", "nft", "eth"],
    title: "A home for your digital assets",
    text: "A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs."
  },
  {
    images: ["browser", "noun", "dao"],
    title: "Your gateway to a new web",
    text: "With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more."
  }
];
var W3mWhatIsAWalletView = class W3mWhatIsAWalletView2 extends LitElement {
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "xl", "xl", "xl"]}
        alignItems="center"
        gap="xl"
      >
        <w3m-help-widget .data=${data2}></w3m-help-widget>
        <wui-button variant="main" size="md" @click=${this.onGetWallet.bind(this)}>
          <wui-icon color="inherit" slot="iconLeft" name="wallet"></wui-icon>
          Get a wallet
        </wui-button>
      </wui-flex>
    `;
  }
  onGetWallet() {
    EventsController.sendEvent({ type: "track", event: "CLICK_GET_WALLET" });
    RouterController.push("GetWallet");
  }
};
W3mWhatIsAWalletView = __decorate33([
  customElement("w3m-what-is-a-wallet-view")
], W3mWhatIsAWalletView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-what-is-a-buy-view/index.js
var __decorate34 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mWhatIsABuyView = class W3mWhatIsABuyView2 extends LitElement {
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        .padding=${["xxl", "3xl", "xl", "3xl"]}
        alignItems="center"
        gap="xl"
      >
        <wui-visual name="onrampCard"></wui-visual>
        <wui-flex flexDirection="column" gap="xs" alignItems="center">
          <wui-text align="center" variant="paragraph-500" color="fg-100">
            Quickly and easily buy digital assets!
          </wui-text>
          <wui-text align="center" variant="small-400" color="fg-200">
            Simply select your preferred onramp provider and add digital assets to your account
            using your credit card or bank transfer
          </wui-text>
        </wui-flex>
        <wui-button @click=${RouterController.goBack}>
          <wui-icon size="sm" color="inherit" name="add" slot="iconLeft"></wui-icon>
          Buy
        </wui-button>
      </wui-flex>
    `;
  }
};
W3mWhatIsABuyView = __decorate34([
  customElement("w3m-what-is-a-buy-view")
], W3mWhatIsABuyView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/w3m-email-otp-widget/styles.js
var styles_default22 = css`
  wui-loading-spinner {
    margin: 9px auto;
  }

  .email-display,
  .email-display wui-text {
    max-width: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/w3m-email-otp-widget/index.js
var __decorate35 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var OTP_LENGTH = 6;
var W3mEmailOtpWidget = class W3mEmailOtpWidget2 extends LitElement {
  firstUpdated() {
    this.startOTPTimeout();
  }
  disconnectedCallback() {
    clearTimeout(this.OTPTimeout);
  }
  constructor() {
    var _a;
    super();
    this.loading = false;
    this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
    this.error = "";
    this.otp = "";
    this.email = (_a = RouterController.state.data) == null ? void 0 : _a.email;
    this.authConnector = ConnectorController.getAuthConnector();
  }
  render() {
    if (!this.email) {
      throw new Error("w3m-email-otp-widget: No email provided");
    }
    const isResendDisabled = Boolean(this.timeoutTimeLeft);
    const footerLabels = this.getFooterLabels(isResendDisabled);
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["l", "0", "l", "0"]}
        gap="l"
      >
        <wui-flex
          class="email-display"
          flexDirection="column"
          alignItems="center"
          .padding=${["0", "xl", "0", "xl"]}
        >
          <wui-text variant="paragraph-400" color="fg-100" align="center">
            Enter the code we sent to
          </wui-text>
          <wui-text variant="paragraph-500" color="fg-100" lineClamp="1" align="center">
            ${this.email}
          </wui-text>
        </wui-flex>

        <wui-text variant="small-400" color="fg-200">The code expires in 20 minutes</wui-text>

        ${this.loading ? html`<wui-loading-spinner size="xl" color="accent-100"></wui-loading-spinner>` : html` <wui-flex flexDirection="column" alignItems="center" gap="xs">
              <wui-otp
                dissabled
                length="6"
                @inputChange=${this.onOtpInputChange.bind(this)}
                .otp=${this.otp}
              ></wui-otp>
              ${this.error ? html`
                    <wui-text variant="small-400" align="center" color="error-100">
                      ${this.error}. Try Again
                    </wui-text>
                  ` : null}
            </wui-flex>`}

        <wui-flex alignItems="center" gap="xs">
          <wui-text variant="small-400" color="fg-200">${footerLabels.title}</wui-text>
          <wui-link @click=${this.onResendCode.bind(this)} .disabled=${isResendDisabled}>
            ${footerLabels.action}
          </wui-link>
        </wui-flex>
      </wui-flex>
    `;
  }
  startOTPTimeout() {
    this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
    this.OTPTimeout = setInterval(() => {
      if (this.timeoutTimeLeft > 0) {
        this.timeoutTimeLeft = W3mFrameHelpers.getTimeToNextEmailLogin();
      } else {
        clearInterval(this.OTPTimeout);
      }
    }, 1e3);
  }
  async onOtpInputChange(event) {
    var _a;
    try {
      if (!this.loading) {
        this.otp = event.detail;
        if (this.authConnector && this.otp.length === OTP_LENGTH) {
          this.loading = true;
          await ((_a = this.onOtpSubmit) == null ? void 0 : _a.call(this, this.otp));
        }
      }
    } catch (error) {
      this.error = CoreHelperUtil.parseError(error);
      this.loading = false;
    }
  }
  async onResendCode() {
    try {
      if (this.onOtpResend) {
        if (!this.loading && !this.timeoutTimeLeft) {
          this.error = "";
          this.otp = "";
          const authConnector = ConnectorController.getAuthConnector();
          if (!authConnector || !this.email) {
            throw new Error("w3m-email-otp-widget: Unable to resend email");
          }
          this.loading = true;
          await this.onOtpResend(this.email);
          this.startOTPTimeout();
          SnackController.showSuccess("Code email resent");
        }
      } else if (this.onStartOver) {
        this.onStartOver();
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
  getFooterLabels(isResendDisabled) {
    if (this.onStartOver) {
      return {
        title: "Something wrong?",
        action: `Try again ${isResendDisabled ? `in ${this.timeoutTimeLeft}s` : ""}`
      };
    }
    return {
      title: `Didn't receive it?`,
      action: `Resend ${isResendDisabled ? `in ${this.timeoutTimeLeft}s` : "Code"}`
    };
  }
};
W3mEmailOtpWidget.styles = styles_default22;
__decorate35([
  state()
], W3mEmailOtpWidget.prototype, "loading", void 0);
__decorate35([
  state()
], W3mEmailOtpWidget.prototype, "timeoutTimeLeft", void 0);
__decorate35([
  state()
], W3mEmailOtpWidget.prototype, "error", void 0);
W3mEmailOtpWidget = __decorate35([
  customElement("w3m-email-otp-widget")
], W3mEmailOtpWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-email-verify-otp-view/index.js
var __decorate36 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mEmailVerifyOtpView = class W3mEmailVerifyOtpView2 extends W3mEmailOtpWidget {
  constructor() {
    super();
    this.unsubscribe = [];
    this.smartAccountDeployed = AccountController.state.smartAccountDeployed;
    this.onOtpSubmit = async (otp) => {
      try {
        if (this.authConnector) {
          const smartAccountEnabled = NetworkController.checkIfSmartAccountEnabled();
          await this.authConnector.provider.connectOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          if (ChainController.state.activeChain) {
            await ConnectionController.connectExternal(this.authConnector, ChainController.state.activeChain);
          } else {
            throw new Error("Active chain is not set on ChainControll");
          }
          EventsController.sendEvent({
            type: "track",
            event: "CONNECT_SUCCESS",
            properties: { method: "email", name: this.authConnector.name || "Unknown" }
          });
          if (AccountController.state.allAccounts.length > 1) {
            RouterController.push("SelectAddresses");
          } else if (smartAccountEnabled && !this.smartAccountDeployed) {
            RouterController.push("UpgradeToSmartAccount");
          } else if (!OptionsController.state.isSiweEnabled) {
            ModalController.close();
          }
        }
      } catch (error) {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_FAIL" });
        throw error;
      }
    };
    this.onOtpResend = async (email) => {
      if (this.authConnector) {
        await this.authConnector.provider.connectEmail({ email });
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
      }
    };
    this.unsubscribe.push(AccountController.subscribeKey("smartAccountDeployed", (val) => {
      this.smartAccountDeployed = val;
    }));
  }
};
__decorate36([
  state()
], W3mEmailVerifyOtpView.prototype, "smartAccountDeployed", void 0);
W3mEmailVerifyOtpView = __decorate36([
  customElement("w3m-email-verify-otp-view")
], W3mEmailVerifyOtpView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-email-verify-device-view/styles.js
var styles_default23 = css`
  wui-icon-box {
    height: var(--wui-icon-box-size-xl);
    width: var(--wui-icon-box-size-xl);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-email-verify-device-view/index.js
var __decorate37 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mEmailVerifyDeviceView = class W3mEmailVerifyDeviceView2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.email = (_a = RouterController.state.data) == null ? void 0 : _a.email;
    this.authConnector = ConnectorController.getAuthConnector();
    this.loading = false;
    this.listenForDeviceApproval();
  }
  render() {
    if (!this.email) {
      throw new Error("w3m-email-verify-device-view: No email provided");
    }
    if (!this.authConnector) {
      throw new Error("w3m-email-verify-device-view: No auth connector provided");
    }
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xxl", "s", "xxl", "s"]}
        gap="l"
      >
        <wui-icon-box
          size="xl"
          iconcolor="accent-100"
          backgroundcolor="accent-100"
          icon="verify"
          background="opaque"
        ></wui-icon-box>

        <wui-flex flexDirection="column" alignItems="center" gap="s">
          <wui-flex flexDirection="column" alignItems="center">
            <wui-text variant="paragraph-400" color="fg-100">
              Approve the login link we sent to
            </wui-text>
            <wui-text variant="paragraph-400" color="fg-100"><b>${this.email}</b></wui-text>
          </wui-flex>

          <wui-text variant="small-400" color="fg-200" align="center">
            The code expires in 20 minutes
          </wui-text>

          <wui-flex alignItems="center" id="w3m-resend-section" gap="xs">
            <wui-text variant="small-400" color="fg-100" align="center">
              Didn't receive it?
            </wui-text>
            <wui-link @click=${this.onResendCode.bind(this)} .disabled=${this.loading}>
              Resend email
            </wui-link>
          </wui-flex>
        </wui-flex>
      </wui-flex>
    `;
  }
  async listenForDeviceApproval() {
    if (this.authConnector) {
      try {
        await this.authConnector.provider.connectDevice();
        EventsController.sendEvent({ type: "track", event: "DEVICE_REGISTERED_FOR_EMAIL" });
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
        RouterController.replace("EmailVerifyOtp", { email: this.email });
      } catch (error) {
        RouterController.goBack();
      }
    }
  }
  async onResendCode() {
    try {
      if (!this.loading) {
        if (!this.authConnector || !this.email) {
          throw new Error("w3m-email-login-widget: Unable to resend email");
        }
        this.loading = true;
        await this.authConnector.provider.connectEmail({ email: this.email });
        this.listenForDeviceApproval();
        SnackController.showSuccess("Code email resent");
      }
    } catch (error) {
      SnackController.showError(error);
    } finally {
      this.loading = false;
    }
  }
};
W3mEmailVerifyDeviceView.styles = styles_default23;
__decorate37([
  state()
], W3mEmailVerifyDeviceView.prototype, "loading", void 0);
W3mEmailVerifyDeviceView = __decorate37([
  customElement("w3m-email-verify-device-view")
], W3mEmailVerifyDeviceView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-approve-transaction-view/styles.js
var styles_default24 = css`
  div {
    width: 100%;
    height: 400px;
  }

  [data-ready='false'] {
    transform: scale(1.05);
  }

  @media (max-width: 430px) {
    [data-ready='false'] {
      transform: translateY(-50px);
    }
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-approve-transaction-view/index.js
var __decorate38 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var PAGE_HEIGHT = 400;
var PAGE_WIDTH = 360;
var HEADER_HEIGHT = 64;
var W3mApproveTransactionView = class W3mApproveTransactionView2 extends LitElement {
  constructor() {
    super();
    this.bodyObserver = void 0;
    this.unsubscribe = [];
    this.iframe = document.getElementById("w3m-iframe");
    this.ready = false;
    this.unsubscribe.push(...[
      ModalController.subscribeKey("open", (isOpen) => {
        if (!isOpen) {
          this.onHideIframe();
          RouterController.popTransactionStack();
        }
      }),
      ModalController.subscribeKey("shake", (val) => {
        if (val) {
          this.iframe.style.animation = `w3m-shake 500ms var(--wui-ease-out-power-2)`;
        } else {
          this.iframe.style.animation = "none";
        }
      })
    ]);
  }
  disconnectedCallback() {
    var _a;
    this.onHideIframe();
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    (_a = this.bodyObserver) == null ? void 0 : _a.unobserve(window.document.body);
  }
  async firstUpdated() {
    await this.syncTheme();
    this.iframe.style.display = "block";
    this.bodyObserver = new ResizeObserver((entries) => {
      var _a, _b;
      const contentBoxSize = (_a = entries == null ? void 0 : entries[0]) == null ? void 0 : _a.contentBoxSize;
      const width = (_b = contentBoxSize == null ? void 0 : contentBoxSize[0]) == null ? void 0 : _b.inlineSize;
      this.iframe.style.height = `${PAGE_HEIGHT}px`;
      if (width && width <= 430) {
        this.iframe.style.width = "100%";
        this.iframe.style.left = "0px";
        this.iframe.style.bottom = "0px";
        this.iframe.style.top = "unset";
      } else {
        this.iframe.style.width = `${PAGE_WIDTH}px`;
        this.iframe.style.left = `calc(50% - ${PAGE_WIDTH / 2}px)`;
        this.iframe.style.top = `calc(50% - ${PAGE_HEIGHT / 2}px + ${HEADER_HEIGHT / 2}px)`;
        this.iframe.style.bottom = "unset";
      }
      this.ready = true;
      this.onShowIframe();
    });
    this.bodyObserver.observe(window.document.body);
  }
  render() {
    return html`<div data-ready=${this.ready}></div>`;
  }
  onShowIframe() {
    const isMobile = window.innerWidth <= 430;
    this.iframe.style.animation = isMobile ? "w3m-iframe-zoom-in-mobile 200ms var(--wui-ease-out-power-2)" : "w3m-iframe-zoom-in 200ms var(--wui-ease-out-power-2)";
  }
  onHideIframe() {
    this.iframe.style.display = "none";
    this.iframe.style.animation = "w3m-iframe-fade-out 200ms var(--wui-ease-out-power-2)";
  }
  async syncTheme() {
    const authConnector = ConnectorController.getAuthConnector();
    if (authConnector) {
      const themeMode = ThemeController.getSnapshot().themeMode;
      const themeVariables = ThemeController.getSnapshot().themeVariables;
      await authConnector.provider.syncTheme({
        themeVariables,
        w3mThemeVariables: getW3mThemeVariables(themeVariables, themeMode)
      });
    }
  }
};
W3mApproveTransactionView.styles = styles_default24;
__decorate38([
  state()
], W3mApproveTransactionView.prototype, "ready", void 0);
W3mApproveTransactionView = __decorate38([
  customElement("w3m-approve-transaction-view")
], W3mApproveTransactionView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-upgrade-wallet-view/index.js
var __decorate39 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mUpgradeWalletView = class W3mUpgradeWalletView2 extends LitElement {
  render() {
    return html`
      <wui-flex flexDirection="column" alignItems="center" gap="xl" padding="xl">
        <wui-text variant="paragraph-400" color="fg-100">Follow the instructions on</wui-text>
        <wui-chip
          icon="externalLink"
          variant="fill"
          href=${ConstantsUtil2.SECURE_SITE_DASHBOARD}
          imageSrc=${ConstantsUtil2.SECURE_SITE_FAVICON}
          data-testid="w3m-secure-website-button"
        >
        </wui-chip>
        <wui-text variant="small-400" color="fg-200">
          You will have to reconnect for security reasons
        </wui-text>
      </wui-flex>
    `;
  }
};
W3mUpgradeWalletView = __decorate39([
  customElement("w3m-upgrade-wallet-view")
], W3mUpgradeWalletView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-upgrade-to-smart-account-view/index.js
var __decorate40 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mUpgradeToSmartAccountView = class W3mUpgradeToSmartAccountView2 extends LitElement {
  constructor() {
    super(...arguments);
    this.authConnector = ConnectorController.getAuthConnector();
    this.loading = false;
    this.setPreferSmartAccount = async () => {
      if (this.authConnector) {
        try {
          this.loading = true;
          await ConnectionController.setPreferredAccountType(W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT);
          this.loading = false;
          RouterController.push("Account");
        } catch (e2) {
          SnackController.showError("Error upgrading to smart account");
        }
      }
    };
  }
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        gap="xxl"
        .padding=${["0", "0", "l", "0"]}
      >
        ${this.onboardingTemplate()} ${this.buttonsTemplate()}
        <wui-link
          @click=${() => {
      CoreHelperUtil.openHref(NavigationUtil.URLS.FAQ, "_blank");
    }}
        >
          Learn more
          <wui-icon color="inherit" slot="iconRight" name="externalLink"></wui-icon>
        </wui-link>
      </wui-flex>
    `;
  }
  onboardingTemplate() {
    return html` <wui-flex
      flexDirection="column"
      gap="xxl"
      alignItems="center"
      .padding=${["0", "xxl", "0", "xxl"]}
    >
      <wui-flex gap="s" alignItems="center" justifyContent="center">
        <wui-visual name="google"></wui-visual>
        <wui-visual name="pencil"></wui-visual>
        <wui-visual name="lightbulb"></wui-visual>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="s">
        <wui-text align="center" variant="medium-600" color="fg-100">
          Discover Smart Accounts
        </wui-text>
        <wui-text align="center" variant="paragraph-400" color="fg-100">
          Access advanced features such as username, social login, improved security and a smoother
          user experience!
        </wui-text>
      </wui-flex>
    </wui-flex>`;
  }
  buttonsTemplate() {
    return html`<wui-flex .padding=${["0", "2l", "0", "2l"]} gap="s">
      <wui-button
        variant="accent"
        @click=${this.redirectToAccount.bind(this)}
        size="lg"
        borderRadius="xs"
      >
        Do it later
      </wui-button>
      <wui-button
        .loading=${this.loading}
        size="lg"
        borderRadius="xs"
        @click=${this.setPreferSmartAccount.bind(this)}
        >Continue
      </wui-button>
    </wui-flex>`;
  }
  redirectToAccount() {
    RouterController.push("Account");
  }
};
__decorate40([
  state()
], W3mUpgradeToSmartAccountView.prototype, "authConnector", void 0);
__decorate40([
  state()
], W3mUpgradeToSmartAccountView.prototype, "loading", void 0);
W3mUpgradeToSmartAccountView = __decorate40([
  customElement("w3m-upgrade-to-smart-account-view")
], W3mUpgradeToSmartAccountView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-update-email-wallet-view/styles.js
var styles_default25 = css`
  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-update-email-wallet-view/index.js
var __decorate41 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mUpdateEmailWalletView = class W3mUpdateEmailWalletView2 extends LitElement {
  constructor() {
    var _a;
    super(...arguments);
    this.formRef = createRef();
    this.initialEmail = ((_a = RouterController.state.data) == null ? void 0 : _a.email) ?? "";
    this.email = "";
    this.loading = false;
  }
  firstUpdated() {
    var _a;
    (_a = this.formRef.value) == null ? void 0 : _a.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.onSubmitEmail(event);
      }
    });
  }
  render() {
    const showSubmit = !this.loading && this.email.length > 3 && this.email !== this.initialEmail;
    return html`
      <wui-flex flexDirection="column" padding="m" gap="m">
        <form ${ref2(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
          <wui-email-input
            value=${this.initialEmail}
            .disabled=${this.loading}
            @inputChange=${this.onEmailInputChange.bind(this)}
          >
          </wui-email-input>
          <input type="submit" hidden />
        </form>

        <wui-flex gap="s">
          <wui-button size="md" variant="neutral" fullWidth @click=${RouterController.goBack}>
            Cancel
          </wui-button>

          <wui-button
            size="md"
            variant="main"
            fullWidth
            @click=${this.onSubmitEmail.bind(this)}
            .disabled=${!showSubmit}
            .loading=${this.loading}
          >
            Save
          </wui-button>
        </wui-flex>
      </wui-flex>
    `;
  }
  onEmailInputChange(event) {
    this.email = event.detail;
  }
  async onSubmitEmail(event) {
    try {
      if (this.loading) {
        return;
      }
      this.loading = true;
      event.preventDefault();
      const authConnector = ConnectorController.getAuthConnector();
      if (!authConnector) {
        throw new Error("w3m-update-email-wallet: Auth connector not found");
      }
      const response = await authConnector.provider.updateEmail({ email: this.email });
      EventsController.sendEvent({ type: "track", event: "EMAIL_EDIT" });
      if (response.action === "VERIFY_SECONDARY_OTP") {
        RouterController.push("UpdateEmailSecondaryOtp", {
          email: this.initialEmail,
          newEmail: this.email
        });
      } else {
        RouterController.push("UpdateEmailPrimaryOtp", {
          email: this.initialEmail,
          newEmail: this.email
        });
      }
    } catch (error) {
      SnackController.showError(error);
      this.loading = false;
    }
  }
};
W3mUpdateEmailWalletView.styles = styles_default25;
__decorate41([
  state()
], W3mUpdateEmailWalletView.prototype, "email", void 0);
__decorate41([
  state()
], W3mUpdateEmailWalletView.prototype, "loading", void 0);
W3mUpdateEmailWalletView = __decorate41([
  customElement("w3m-update-email-wallet-view")
], W3mUpdateEmailWalletView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-update-email-primary-otp-view/index.js
var __decorate42 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mUpdateEmailPrimaryOtpView = class W3mUpdateEmailPrimaryOtpView2 extends W3mEmailOtpWidget {
  constructor() {
    var _a;
    super();
    this.email = (_a = RouterController.state.data) == null ? void 0 : _a.email;
    this.onOtpSubmit = async (otp) => {
      try {
        if (this.authConnector) {
          await this.authConnector.provider.updateEmailPrimaryOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          RouterController.replace("UpdateEmailSecondaryOtp", RouterController.state.data);
        }
      } catch (error) {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_FAIL" });
        throw error;
      }
    };
    this.onStartOver = () => {
      RouterController.replace("UpdateEmailWallet", RouterController.state.data);
    };
  }
};
W3mUpdateEmailPrimaryOtpView = __decorate42([
  customElement("w3m-update-email-primary-otp-view")
], W3mUpdateEmailPrimaryOtpView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-update-email-secondary-otp-view/index.js
var __decorate43 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mUpdateEmailSecondaryOtpView = class W3mUpdateEmailSecondaryOtpView2 extends W3mEmailOtpWidget {
  constructor() {
    var _a;
    super();
    this.email = (_a = RouterController.state.data) == null ? void 0 : _a.newEmail;
    this.onOtpSubmit = async (otp) => {
      try {
        if (this.authConnector) {
          await this.authConnector.provider.updateEmailSecondaryOtp({ otp });
          EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_PASS" });
          RouterController.reset("Account");
        }
      } catch (error) {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_FAIL" });
        throw error;
      }
    };
    this.onStartOver = () => {
      RouterController.replace("UpdateEmailWallet", RouterController.state.data);
    };
  }
};
W3mUpdateEmailSecondaryOtpView = __decorate43([
  customElement("w3m-update-email-secondary-otp-view")
], W3mUpdateEmailSecondaryOtpView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-unsupported-chain-view/styles.js
var styles_default26 = css`
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-unsupported-chain-view/index.js
var __decorate44 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mUnsupportedChainView = class W3mUnsupportedChainView2 extends LitElement {
  constructor() {
    var _a;
    super(...arguments);
    this.swapUnsupportedChain = (_a = RouterController.state.data) == null ? void 0 : _a.swapUnsupportedChain;
    this.disconecting = false;
  }
  render() {
    return html`
      <wui-flex class="container" flexDirection="column" gap="0">
        <wui-flex
          class="container"
          flexDirection="column"
          .padding=${["m", "xl", "xs", "xl"]}
          alignItems="center"
          gap="xl"
        >
          ${this.descriptionTemplate()}
        </wui-flex>

        <wui-flex flexDirection="column" padding="s" gap="xs">
          ${this.networksTemplate()}
        </wui-flex>

        <wui-separator text="or"></wui-separator>
        <wui-flex flexDirection="column" padding="s" gap="xs">
          <wui-list-item
            variant="icon"
            iconVariant="overlay"
            icon="disconnect"
            ?chevron=${false}
            .loading=${this.disconecting}
            @click=${this.onDisconnect.bind(this)}
            data-testid="disconnect-button"
          >
            <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
          </wui-list-item>
        </wui-flex>
      </wui-flex>
    `;
  }
  descriptionTemplate() {
    if (this.swapUnsupportedChain) {
      return html`
        <wui-text variant="small-400" color="fg-200" align="center">
          The swap feature doesnt support your current network. Switch to an available option to
          continue.
        </wui-text>
      `;
    }
    return html`
      <wui-text variant="small-400" color="fg-200" align="center">
        This app doesnt support your current network. Switch to an available option to continue.
      </wui-text>
    `;
  }
  networksTemplate() {
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const approvedCaipNetworkIds = NetworkController.state.approvedCaipNetworkIds;
    const sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    const filteredNetworks = this.swapUnsupportedChain ? sortedNetworks.filter((network) => ConstantsUtil2.SWAP_SUPPORTED_NETWORKS.includes(network.id)) : sortedNetworks;
    return filteredNetworks.map((network) => html`
        <wui-list-network
          imageSrc=${ifDefined(AssetUtil.getNetworkImage(network))}
          name=${network.name ?? "Unknown"}
          @click=${() => this.onSwitchNetwork(network)}
        >
        </wui-list-network>
      `);
  }
  async onDisconnect() {
    try {
      this.disconecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({
        type: "track",
        event: "DISCONNECT_SUCCESS"
      });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconecting = false;
    }
  }
  async onSwitchNetwork(network) {
    const caipAddress = AccountController.state.caipAddress;
    const approvedCaipNetworkIds = NetworkController.state.approvedCaipNetworkIds;
    const supportsAllNetworks = NetworkController.state.supportsAllNetworks;
    const caipNetwork = ChainController.state.activeCaipNetwork;
    const routerData = RouterController.state.data;
    if (caipAddress && (caipNetwork == null ? void 0 : caipNetwork.id) !== network.id) {
      if (approvedCaipNetworkIds == null ? void 0 : approvedCaipNetworkIds.includes(network.id)) {
        await NetworkController.switchActiveNetwork(network);
      } else if (supportsAllNetworks) {
        RouterController.push("SwitchNetwork", { ...routerData, network });
      }
    } else if (!caipAddress) {
      NetworkController.setActiveCaipNetwork(network);
      RouterController.push("Connect");
    }
  }
};
W3mUnsupportedChainView.styles = styles_default26;
__decorate44([
  state()
], W3mUnsupportedChainView.prototype, "disconecting", void 0);
W3mUnsupportedChainView = __decorate44([
  customElement("w3m-unsupported-chain-view")
], W3mUnsupportedChainView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-receive-view/styles.js
var styles_default27 = css`
  wui-compatible-network {
    margin-top: var(--wui-spacing-l);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-receive-view/index.js
var __decorate45 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mWalletReceiveView = class W3mWalletReceiveView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.address = AccountController.state.address;
    this.profileName = AccountController.state.profileName;
    this.network = ChainController.state.activeCaipNetwork;
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileName = val.profileName;
          this.preferredAccountType = val.preferredAccountType;
        } else {
          SnackController.showError("Account not found");
        }
      })
    ], ChainController.subscribeKey("activeCaipNetwork", (val) => {
      if (val == null ? void 0 : val.id) {
        this.network = val;
      }
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.address) {
      throw new Error("w3m-wallet-receive-view: No account provided");
    }
    const networkImage = AssetUtil.getNetworkImage(this.network);
    return html` <wui-flex
      flexDirection="column"
      .padding=${["0", "l", "l", "l"]}
      alignItems="center"
    >
      <wui-chip-button
        data-testid="receive-address-copy-button"
        @click=${this.onCopyClick.bind(this)}
        text=${UiHelperUtil.getTruncateString({
      string: this.profileName || this.address || "",
      charsStart: this.profileName ? 18 : 4,
      charsEnd: this.profileName ? 0 : 4,
      truncate: this.profileName ? "end" : "middle"
    })}
        icon="copy"
        size="sm"
        imageSrc=${networkImage ? networkImage : ""}
        variant="gray"
      ></wui-chip-button>
      <wui-flex
        flexDirection="column"
        .padding=${["l", "0", "0", "0"]}
        alignItems="center"
        gap="s"
      >
        <wui-qr-code
          size=${232}
          theme=${ThemeController.state.themeMode}
          uri=${this.address}
          ?arenaClear=${true}
          data-testid="wui-qr-code"
        ></wui-qr-code>
        <wui-text variant="paragraph-500" color="fg-100" align="center">
          Copy your address or scan this QR code
        </wui-text>
      </wui-flex>
      ${this.networkTemplate()}
    </wui-flex>`;
  }
  networkTemplate() {
    var _a;
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const isNetworkEnabledForSmartAccounts = NetworkController.checkIfSmartAccountEnabled();
    const caipNetwork = ChainController.state.activeCaipNetwork;
    if (this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT && isNetworkEnabledForSmartAccounts) {
      if (!caipNetwork) {
        return null;
      }
      return html`<wui-compatible-network
        @click=${this.onReceiveClick.bind(this)}
        text="Only receive assets on this network"
        .networkImages=${[AssetUtil.getNetworkImage(caipNetwork) ?? ""]}
      ></wui-compatible-network>`;
    }
    const slicedNetworks = (_a = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.filter((network) => network == null ? void 0 : network.imageId)) == null ? void 0 : _a.slice(0, 5);
    const imagesArray = slicedNetworks.map(AssetUtil.getNetworkImage).filter(Boolean);
    return html`<wui-compatible-network
      @click=${this.onReceiveClick.bind(this)}
      text="Only receive assets on these networks"
      .networkImages=${imagesArray}
    ></wui-compatible-network>`;
  }
  onReceiveClick() {
    RouterController.push("WalletCompatibleNetworks");
  }
  onCopyClick() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mWalletReceiveView.styles = styles_default27;
__decorate45([
  state()
], W3mWalletReceiveView.prototype, "address", void 0);
__decorate45([
  state()
], W3mWalletReceiveView.prototype, "profileName", void 0);
__decorate45([
  state()
], W3mWalletReceiveView.prototype, "network", void 0);
__decorate45([
  state()
], W3mWalletReceiveView.prototype, "preferredAccountType", void 0);
W3mWalletReceiveView = __decorate45([
  customElement("w3m-wallet-receive-view")
], W3mWalletReceiveView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-compatible-networks-view/styles.js
var styles_default28 = css`
  :host > wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }

  :host > wui-flex::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-compatible-networks-view/index.js
var __decorate46 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mWalletCompatibleNetworksView = class W3mWalletCompatibleNetworksView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.unsubscribe.push(AccountController.subscribeKey("preferredAccountType", (val) => {
      this.preferredAccountType = val;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html` <wui-flex
      flexDirection="column"
      .padding=${["xs", "s", "m", "s"]}
      gap="xs"
    >
      <wui-banner
        icon="warningCircle"
        text="You can only receive assets on these networks"
      ></wui-banner>
      ${this.networkTemplate()}
    </wui-flex>`;
  }
  networkTemplate() {
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const approvedCaipNetworkIds = NetworkController.state.approvedCaipNetworkIds;
    const caipNetwork = ChainController.state.activeCaipNetwork;
    const isNetworkEnabledForSmartAccounts = NetworkController.checkIfSmartAccountEnabled();
    let sortedNetworks = CoreHelperUtil.sortRequestedNetworks(approvedCaipNetworkIds, requestedCaipNetworks);
    if (isNetworkEnabledForSmartAccounts && this.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT) {
      if (!caipNetwork) {
        return null;
      }
      sortedNetworks = [caipNetwork];
    }
    return sortedNetworks.map((network) => html`
        <wui-list-network
          imageSrc=${ifDefined(AssetUtil.getNetworkImage(network))}
          name=${network.name ?? "Unknown"}
          ?transparent=${true}
        >
        </wui-list-network>
      `);
  }
};
W3mWalletCompatibleNetworksView.styles = styles_default28;
__decorate46([
  state()
], W3mWalletCompatibleNetworksView.prototype, "preferredAccountType", void 0);
W3mWalletCompatibleNetworksView = __decorate46([
  customElement("w3m-wallet-compatible-networks-view")
], W3mWalletCompatibleNetworksView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-send-view/styles.js
var styles_default29 = css`
  :host {
    display: block;
  }

  wui-flex {
    position: relative;
  }

  wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xs) !important;
    border: 5px solid var(--wui-color-bg-125);
    background: var(--wui-color-bg-175);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 3;
  }

  wui-button {
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }

  .inputContainer {
    height: fit-content;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-send-view/index.js
var __decorate47 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mWalletSendView = class W3mWalletSendView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.token = SendController.state.token;
    this.sendTokenAmount = SendController.state.sendTokenAmount;
    this.receiverAddress = SendController.state.receiverAddress;
    this.receiverProfileName = SendController.state.receiverProfileName;
    this.loading = SendController.state.loading;
    this.gasPriceInUSD = SendController.state.gasPriceInUSD;
    this.gasPrice = SendController.state.gasPrice;
    this.message = "Preview Send";
    this.fetchNetworkPrice();
    this.unsubscribe.push(...[
      SendController.subscribe((val) => {
        this.token = val.token;
        this.sendTokenAmount = val.sendTokenAmount;
        this.receiverAddress = val.receiverAddress;
        this.gasPriceInUSD = val.gasPriceInUSD;
        this.receiverProfileName = val.receiverProfileName;
        this.loading = val.loading;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    this.getMessage();
    return html` <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]}>
      <wui-flex class="inputContainer" gap="xs" flexDirection="column">
        <w3m-input-token
          .token=${this.token}
          .sendTokenAmount=${this.sendTokenAmount}
          .gasPriceInUSD=${this.gasPriceInUSD}
          .gasPrice=${this.gasPrice}
        ></w3m-input-token>
        <wui-icon-box
          size="inherit"
          backgroundColor="fg-300"
          iconSize="lg"
          iconColor="fg-250"
          background="opaque"
          icon="arrowBottom"
        ></wui-icon-box>
        <w3m-input-address
          .value=${this.receiverProfileName ? this.receiverProfileName : this.receiverAddress}
        ></w3m-input-address>
      </wui-flex>
      <wui-flex .margin=${["l", "0", "0", "0"]}>
        <wui-button
          @click=${this.onButtonClick.bind(this)}
          ?disabled=${!this.message.startsWith("Preview Send")}
          size="lg"
          variant="main"
          ?loading=${this.loading}
          fullWidth
        >
          ${this.message}
        </wui-button>
      </wui-flex>
    </wui-flex>`;
  }
  async fetchNetworkPrice() {
    await SwapController.getNetworkTokenPrice();
    const gas = await SwapController.getInitialGasPrice();
    if ((gas == null ? void 0 : gas.gasPrice) && (gas == null ? void 0 : gas.gasPriceInUSD)) {
      SendController.setGasPrice(gas.gasPrice);
      SendController.setGasPriceInUsd(gas.gasPriceInUSD);
    }
  }
  onButtonClick() {
    RouterController.push("WalletSendPreview");
  }
  getMessage() {
    var _a;
    this.message = "Preview Send";
    if (this.receiverAddress && !CoreHelperUtil.isAddress(this.receiverAddress, ChainController.state.activeChain)) {
      this.message = "Invalid Address";
    }
    if (!this.receiverAddress) {
      this.message = "Add Address";
    }
    if (this.sendTokenAmount && this.token && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
      this.message = "Insufficient Funds";
    }
    if (!this.sendTokenAmount) {
      this.message = "Add Amount";
    }
    if (this.sendTokenAmount && ((_a = this.token) == null ? void 0 : _a.price)) {
      const value = this.sendTokenAmount * this.token.price;
      if (!value) {
        this.message = "Incorrect Value";
      }
    }
    if (!this.token) {
      this.message = "Select Token";
    }
  }
};
W3mWalletSendView.styles = styles_default29;
__decorate47([
  state()
], W3mWalletSendView.prototype, "token", void 0);
__decorate47([
  state()
], W3mWalletSendView.prototype, "sendTokenAmount", void 0);
__decorate47([
  state()
], W3mWalletSendView.prototype, "receiverAddress", void 0);
__decorate47([
  state()
], W3mWalletSendView.prototype, "receiverProfileName", void 0);
__decorate47([
  state()
], W3mWalletSendView.prototype, "loading", void 0);
__decorate47([
  state()
], W3mWalletSendView.prototype, "gasPriceInUSD", void 0);
__decorate47([
  state()
], W3mWalletSendView.prototype, "gasPrice", void 0);
__decorate47([
  state()
], W3mWalletSendView.prototype, "message", void 0);
W3mWalletSendView = __decorate47([
  customElement("w3m-wallet-send-view")
], W3mWalletSendView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-send-select-token-view/styles.js
var styles_default30 = css`
  .contentContainer {
    height: 440px;
    overflow: scroll;
    scrollbar-width: none;
  }

  .contentContainer::-webkit-scrollbar {
    display: none;
  }

  wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-send-select-token-view/index.js
var __decorate48 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSendSelectTokenView = class W3mSendSelectTokenView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tokenBalance = AccountController.state.tokenBalance;
    this.search = "";
    this.onDebouncedSearch = CoreHelperUtil.debounce((value) => {
      this.search = value;
    });
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        this.tokenBalance = val.tokenBalance;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      <wui-flex flexDirection="column">
        ${this.templateSearchInput()} <wui-separator></wui-separator> ${this.templateTokens()}
      </wui-flex>
    `;
  }
  templateSearchInput() {
    return html`
      <wui-flex gap="xs" padding="s">
        <wui-input-text
          @inputChange=${this.onInputChange.bind(this)}
          class="network-search-input"
          size="sm"
          placeholder="Search token"
          icon="search"
        ></wui-input-text>
      </wui-flex>
    `;
  }
  templateTokens() {
    var _a, _b;
    this.tokens = (_a = this.tokenBalance) == null ? void 0 : _a.filter((token) => {
      var _a2;
      return token.chainId === ((_a2 = ChainController.state.activeCaipNetwork) == null ? void 0 : _a2.id);
    });
    if (this.search) {
      this.filteredTokens = (_b = this.tokenBalance) == null ? void 0 : _b.filter((token) => token.name.toLowerCase().includes(this.search.toLowerCase()));
    } else {
      this.filteredTokens = this.tokens;
    }
    return html`
      <wui-flex
        class="contentContainer"
        flexDirection="column"
        .padding=${["0", "s", "0", "s"]}
      >
        <wui-flex justifyContent="flex-start" .padding=${["m", "s", "s", "s"]}>
          <wui-text variant="paragraph-500" color="fg-200">Your tokens</wui-text>
        </wui-flex>
        <wui-flex flexDirection="column" gap="xs">
          ${this.filteredTokens && this.filteredTokens.length > 0 ? this.filteredTokens.map((token) => html`<wui-list-token
                    @click=${this.handleTokenClick.bind(this, token)}
                    ?clickable=${true}
                    tokenName=${token.name}
                    tokenImageUrl=${token.iconUrl}
                    tokenAmount=${token.quantity.numeric}
                    tokenValue=${token.value}
                    tokenCurrency=${token.symbol}
                  ></wui-list-token>`) : html`<wui-flex
                .padding=${["4xl", "0", "0", "0"]}
                alignItems="center"
                flexDirection="column"
                gap="l"
              >
                <wui-icon-box
                  icon="coinPlaceholder"
                  size="inherit"
                  iconColor="fg-200"
                  backgroundColor="fg-200"
                  iconSize="lg"
                ></wui-icon-box>
                <wui-flex
                  class="textContent"
                  gap="xs"
                  flexDirection="column"
                  justifyContent="center"
                  flexDirection="column"
                >
                  <wui-text variant="paragraph-500" align="center" color="fg-100"
                    >No tokens found</wui-text
                  >
                  <wui-text variant="small-400" align="center" color="fg-200"
                    >Your tokens will appear here</wui-text
                  >
                </wui-flex>
                <wui-link @click=${this.onBuyClick.bind(this)}>Buy</wui-link>
              </wui-flex>`}
        </wui-flex>
      </wui-flex>
    `;
  }
  onBuyClick() {
    RouterController.push("OnRampProviders");
  }
  onInputChange(event) {
    this.onDebouncedSearch(event.detail);
  }
  handleTokenClick(token) {
    SendController.setToken(token);
    SendController.setTokenAmount(void 0);
    RouterController.goBack();
  }
};
W3mSendSelectTokenView.styles = styles_default30;
__decorate48([
  state()
], W3mSendSelectTokenView.prototype, "tokenBalance", void 0);
__decorate48([
  state()
], W3mSendSelectTokenView.prototype, "tokens", void 0);
__decorate48([
  state()
], W3mSendSelectTokenView.prototype, "filteredTokens", void 0);
__decorate48([
  state()
], W3mSendSelectTokenView.prototype, "search", void 0);
W3mSendSelectTokenView = __decorate48([
  customElement("w3m-wallet-send-select-token-view")
], W3mSendSelectTokenView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-send-preview-view/styles.js
var styles_default31 = css`
  wui-avatar,
  wui-image {
    display: ruby;
    width: 32px;
    height: 32px;
    border-radius: var(--wui-border-radius-3xl);
  }

  .sendButton {
    width: 70%;
    --local-width: 100% !important;
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }

  .cancelButton {
    width: 30%;
    --local-width: 100% !important;
    --local-border-radius: var(--wui-border-radius-xs) !important;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-wallet-send-preview-view/index.js
var __decorate49 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mWalletSendPreviewView = class W3mWalletSendPreviewView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.token = SendController.state.token;
    this.sendTokenAmount = SendController.state.sendTokenAmount;
    this.receiverAddress = SendController.state.receiverAddress;
    this.receiverProfileName = SendController.state.receiverProfileName;
    this.receiverProfileImageUrl = SendController.state.receiverProfileImageUrl;
    this.gasPriceInUSD = SendController.state.gasPriceInUSD;
    this.caipNetwork = ChainController.state.activeCaipNetwork;
    this.unsubscribe.push(...[
      SendController.subscribe((val) => {
        this.token = val.token;
        this.sendTokenAmount = val.sendTokenAmount;
        this.receiverAddress = val.receiverAddress;
        this.gasPriceInUSD = val.gasPriceInUSD;
        this.receiverProfileName = val.receiverProfileName;
        this.receiverProfileImageUrl = val.receiverProfileImageUrl;
      }),
      ChainController.subscribeKey("activeCaipNetwork", (val) => this.caipNetwork = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a, _b;
    return html` <wui-flex flexDirection="column" .padding=${["0", "l", "l", "l"]}>
      <wui-flex gap="xs" flexDirection="column" .padding=${["0", "xs", "0", "xs"]}>
        <wui-flex alignItems="center" justifyContent="space-between">
          <wui-flex flexDirection="column" gap="4xs">
            <wui-text variant="small-400" color="fg-150">Send</wui-text>
            ${this.sendValueTemplate()}
          </wui-flex>
          <wui-preview-item
            text="${this.sendTokenAmount ? UiHelperUtil.roundNumber(this.sendTokenAmount, 6, 5) : "unknown"} ${(_a = this.token) == null ? void 0 : _a.symbol}"
            .imageSrc=${(_b = this.token) == null ? void 0 : _b.iconUrl}
          ></wui-preview-item>
        </wui-flex>
        <wui-flex>
          <wui-icon color="fg-200" size="md" name="arrowBottom"></wui-icon>
        </wui-flex>
        <wui-flex alignItems="center" justifyContent="space-between">
          <wui-text variant="small-400" color="fg-150">To</wui-text>
          <wui-preview-item
            text="${this.receiverProfileName ? UiHelperUtil.getTruncateString({
      string: this.receiverProfileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.receiverAddress ? this.receiverAddress : "",
      charsStart: 4,
      charsEnd: 4,
      truncate: "middle"
    })}"
            address=${this.receiverAddress ?? ""}
            .imageSrc=${this.receiverProfileImageUrl ?? void 0}
            .isAddress=${true}
          ></wui-preview-item>
        </wui-flex>
      </wui-flex>
      <wui-flex flexDirection="column" .padding=${["xxl", "0", "0", "0"]}>
        <w3m-wallet-send-details
          .caipNetwork=${this.caipNetwork}
          .receiverAddress=${this.receiverAddress}
          .networkFee=${this.gasPriceInUSD}
        ></w3m-wallet-send-details>
        <wui-flex justifyContent="center" gap="xxs" .padding=${["s", "0", "0", "0"]}>
          <wui-icon size="sm" color="fg-200" name="warningCircle"></wui-icon>
          <wui-text variant="small-400" color="fg-200">Review transaction carefully</wui-text>
        </wui-flex>
        <wui-flex justifyContent="center" gap="s" .padding=${["l", "0", "0", "0"]}>
          <wui-button
            class="cancelButton"
            @click=${this.onCancelClick.bind(this)}
            size="lg"
            variant="neutral"
          >
            Cancel
          </wui-button>
          <wui-button
            class="sendButton"
            @click=${this.onSendClick.bind(this)}
            size="lg"
            variant="main"
          >
            Send
          </wui-button>
        </wui-flex>
      </wui-flex></wui-flex
    >`;
  }
  sendValueTemplate() {
    if (this.token && this.sendTokenAmount) {
      const price = this.token.price;
      const totalValue = price * this.sendTokenAmount;
      return html`<wui-text variant="paragraph-400" color="fg-100"
        >$${totalValue.toFixed(2)}</wui-text
      >`;
    }
    return null;
  }
  onSendClick() {
    SendController.sendToken();
  }
  onCancelClick() {
    RouterController.goBack();
  }
};
W3mWalletSendPreviewView.styles = styles_default31;
__decorate49([
  state()
], W3mWalletSendPreviewView.prototype, "token", void 0);
__decorate49([
  state()
], W3mWalletSendPreviewView.prototype, "sendTokenAmount", void 0);
__decorate49([
  state()
], W3mWalletSendPreviewView.prototype, "receiverAddress", void 0);
__decorate49([
  state()
], W3mWalletSendPreviewView.prototype, "receiverProfileName", void 0);
__decorate49([
  state()
], W3mWalletSendPreviewView.prototype, "receiverProfileImageUrl", void 0);
__decorate49([
  state()
], W3mWalletSendPreviewView.prototype, "gasPriceInUSD", void 0);
__decorate49([
  state()
], W3mWalletSendPreviewView.prototype, "caipNetwork", void 0);
W3mWalletSendPreviewView = __decorate49([
  customElement("w3m-wallet-send-preview-view")
], W3mWalletSendPreviewView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connect-wallets-view/styles.js
var styles_default32 = css`
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }
  wui-flex::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connect-wallets-view/index.js
var __decorate50 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectWalletsView = class W3mConnectWalletsView2 extends LitElement {
  render() {
    return html`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        <w3m-wallet-login-list></w3m-wallet-login-list>
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
};
W3mConnectWalletsView.styles = styles_default32;
W3mConnectWalletsView = __decorate50([
  customElement("w3m-connect-wallets-view")
], W3mConnectWalletsView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connect-socials-view/styles.js
var styles_default33 = css`
  wui-flex {
    max-height: clamp(360px, 540px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
  }
  wui-flex::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connect-socials-view/index.js
var __decorate51 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectSocialsView = class W3mConnectSocialsView2 extends LitElement {
  render() {
    return html`
      <wui-flex flexDirection="column" padding="s" gap="xs">
        <w3m-social-login-list></w3m-social-login-list>
      </wui-flex>
      <w3m-legal-footer></w3m-legal-footer>
    `;
  }
};
W3mConnectSocialsView.styles = styles_default33;
W3mConnectSocialsView = __decorate51([
  customElement("w3m-connect-socials-view")
], W3mConnectSocialsView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-social-view/styles.js
var styles_default34 = css`
  wui-logo {
    width: 80px;
    height: 80px;
    border-radius: var(--wui-border-radius-m);
  }
  @keyframes shake {
    0% {
      transform: translateX(0);
    }
    25% {
      transform: translateX(3px);
    }
    50% {
      transform: translateX(-3px);
    }
    75% {
      transform: translateX(3px);
    }
    100% {
      transform: translateX(0);
    }
  }
  wui-flex:first-child:not(:only-child) {
    position: relative;
  }
  wui-loading-thumbnail {
    position: absolute;
  }
  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }
  wui-text[align='center'] {
    width: 100%;
    padding: 0px var(--wui-spacing-l);
  }
  [data-error='true'] wui-icon-box {
    opacity: 1;
    transform: scale(1);
  }
  [data-error='true'] > wui-flex:first-child {
    animation: shake 250ms cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
  }
  .capitalize {
    text-transform: capitalize;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-social-view/index.js
var __decorate52 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingSocialView = class W3mConnectingSocialView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.socialProvider = AccountController.state.socialProvider;
    this.socialWindow = AccountController.state.socialWindow;
    this.error = false;
    this.connecting = false;
    this.message = "Connect in the provider window";
    this.authConnector = ConnectorController.getAuthConnector();
    this.handleSocialConnection = async (event) => {
      var _a;
      if ((_a = event.data) == null ? void 0 : _a.resultUri) {
        if (event.origin === ConstantsUtil4.SECURE_SITE_ORIGIN) {
          window.removeEventListener("message", this.handleSocialConnection, false);
          try {
            if (this.authConnector && !this.connecting) {
              if (this.socialWindow) {
                this.socialWindow.close();
                AccountController.setSocialWindow(void 0, ChainController.state.activeChain);
              }
              this.connecting = true;
              this.updateMessage();
              const uri = event.data.resultUri;
              await this.authConnector.provider.connectSocial(uri);
              if (this.socialProvider) {
                StorageUtil.setConnectedSocialProvider(this.socialProvider);
                await ConnectionController.connectExternal(this.authConnector, this.authConnector.chain);
                EventsController.sendEvent({
                  type: "track",
                  event: "SOCIAL_LOGIN_SUCCESS",
                  properties: { provider: this.socialProvider }
                });
              }
            }
          } catch (error) {
            this.error = true;
            this.updateMessage();
            if (this.socialProvider) {
              EventsController.sendEvent({
                type: "track",
                event: "SOCIAL_LOGIN_ERROR",
                properties: { provider: this.socialProvider }
              });
            }
          }
        } else {
          RouterController.goBack();
          SnackController.showError("Untrusted Origin");
          if (this.socialProvider) {
            EventsController.sendEvent({
              type: "track",
              event: "SOCIAL_LOGIN_ERROR",
              properties: { provider: this.socialProvider }
            });
          }
        }
      }
    };
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.socialProvider) {
          this.socialProvider = val.socialProvider;
        }
        if (val.socialWindow) {
          this.socialWindow = val.socialWindow;
        }
        if (val.address) {
          if (ModalController.state.open) {
            ModalController.close();
          }
        }
      })
    ]);
    if (this.authConnector) {
      this.connectSocial();
    }
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    window.removeEventListener("message", this.handleSocialConnection, false);
  }
  render() {
    return html`
      <wui-flex
        data-error=${ifDefined(this.error)}
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-logo logo=${ifDefined(this.socialProvider)}></wui-logo>
          ${this.error ? null : this.loaderTemplate()}
          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100"
            >Log in with
            <span class="capitalize">${this.socialProvider ?? "Social"}</span></wui-text
          >
          <wui-text align="center" variant="small-400" color=${this.error ? "error-100" : "fg-200"}
            >${this.message}</wui-text
          ></wui-flex
        >
      </wui-flex>
    `;
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return html`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  connectSocial() {
    const interval = setInterval(() => {
      var _a;
      if ((_a = this.socialWindow) == null ? void 0 : _a.closed) {
        if (!this.connecting && RouterController.state.view === "ConnectingSocial") {
          RouterController.goBack();
        }
        clearInterval(interval);
      }
    }, 1e3);
    window.addEventListener("message", this.handleSocialConnection, false);
  }
  updateMessage() {
    if (this.error) {
      this.message = "Something went wrong";
    } else if (this.connecting) {
      this.message = "Retrieving user data";
    } else {
      this.message = "Connect in the provider window";
    }
  }
};
W3mConnectingSocialView.styles = styles_default34;
__decorate52([
  state()
], W3mConnectingSocialView.prototype, "socialProvider", void 0);
__decorate52([
  state()
], W3mConnectingSocialView.prototype, "socialWindow", void 0);
__decorate52([
  state()
], W3mConnectingSocialView.prototype, "error", void 0);
__decorate52([
  state()
], W3mConnectingSocialView.prototype, "connecting", void 0);
__decorate52([
  state()
], W3mConnectingSocialView.prototype, "message", void 0);
W3mConnectingSocialView = __decorate52([
  customElement("w3m-connecting-social-view")
], W3mConnectingSocialView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-profile-view/styles.js
var styles_default35 = css`
  wui-flex {
    width: 100%;
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  .account-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .account-links wui-flex {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    background: red;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 10px;
    flex: 1 0 0;

    border-radius: var(--XS, 16px);
    border: 1px solid var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    background: var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  .account-links wui-flex:hover {
    background: var(--dark-accent-glass-015, rgba(71, 161, 255, 0.15));
  }

  .account-links wui-flex wui-icon {
    width: var(--S, 20px);
    height: var(--S, 20px);
  }

  .account-links wui-flex wui-icon svg path {
    stroke: #47a1ff;
  }

  .account-settings-button {
    padding: calc(var(--wui-spacing-m) - 1px) var(--wui-spacing-2l);
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
    border: 1px solid var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    cursor: pointer;
  }

  .account-settings-button:hover {
    background: var(--wui-color-gray-glass-005);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-profile-view/index.js
var __decorate53 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mProfileView = class W3mProfileView2 extends LitElement {
  constructor() {
    super();
    this.usubscribe = [];
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.accounts = AccountController.state.allAccounts;
    this.usubscribe.push(AccountController.subscribeKey("address", (address) => {
      if (address) {
        this.address = address;
      } else {
        ModalController.close();
      }
    }));
    this.usubscribe.push(AccountController.subscribeKey("profileImage", (profileImage) => {
      this.profileImage = profileImage;
    }));
    this.usubscribe.push(AccountController.subscribeKey("profileName", (profileName) => {
      this.profileName = profileName;
    }));
  }
  disconnectedCallback() {
    this.usubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.address) {
      throw new Error("w3m-profile-view: No account provided");
    }
    return html`
      <wui-flex flexDirection="column" gap="l" .padding=${["0", "xl", "m", "xl"]}>
        <wui-flex flexDirection="column" alignItems="center" gap="l">
          <wui-avatar
            alt=${this.address}
            address=${this.address}
            imageSrc=${ifDefined(this.profileImage)}
            size="2lg"
          ></wui-avatar>
          <wui-flex flexDirection="column" alignItems="center">
            <wui-flex gap="3xs" alignItems="center" justifyContent="center">
              <wui-text variant="title-6-600" color="fg-100" data-testid="account-settings-address">
                ${this.profileName ? UiHelperUtil.getTruncateString({
      string: this.profileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}
              </wui-text>
              <wui-icon-link
                size="md"
                icon="copy"
                iconColor="fg-200"
                @click=${this.onCopyAddress}
              ></wui-icon-link>
            </wui-flex>
          </wui-flex>
        </wui-flex>
        <wui-flex
          data-testid="account-settings-button"
          justifyContent="center"
          alignItems="center"
          class="account-settings-button"
          @click=${() => RouterController.push("AccountSettings")}
        >
          <wui-text variant="paragraph-500" color="fg-100">Account Settings</wui-text>
        </wui-flex>
        ${this.accountsTemplate()}
      </wui-flex>
    `;
  }
  accountsTemplate() {
    return html`<wui-flex flexDirection="column">
      <wui-flex .padding=${["3xs", "m", "s", "s"]}>
        <wui-text color="fg-200" variant="paragraph-400">Your accounts</wui-text>
      </wui-flex>
      <wui-flex flexDirection="column" gap="xxs">
        ${this.accounts.map((account) => this.accountTemplate(account))}
      </wui-flex>
    </wui-flex>`;
  }
  async onSwitchAccount(account) {
    AccountController.setShouldUpdateToAddress(account.address, ChainController.state.activeChain);
    const emailConnector = ConnectorController.getAuthConnector();
    if (!emailConnector) {
      return;
    }
    await emailConnector.provider.setPreferredAccount(account.type);
    await emailConnector.provider.connect();
  }
  accountTemplate(account) {
    return html`<wui-list-account accountAddress=${account.address} accountType=${account.type}>
      ${account.address === this.address ? "" : html`<wui-button
            slot="action"
            textVariant="small-600"
            size="sm"
            variant="accent"
            @click=${() => this.onSwitchAccount(account)}
            >Switch</wui-button
          >`}
    </wui-list-account>`;
  }
  onCopyAddress() {
    try {
      if (this.profileName) {
        CoreHelperUtil.copyToClopboard(this.profileName);
        SnackController.showSuccess("Name copied");
      } else if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mProfileView.styles = styles_default35;
__decorate53([
  state()
], W3mProfileView.prototype, "address", void 0);
__decorate53([
  state()
], W3mProfileView.prototype, "profileImage", void 0);
__decorate53([
  state()
], W3mProfileView.prototype, "profileName", void 0);
__decorate53([
  state()
], W3mProfileView.prototype, "accounts", void 0);
W3mProfileView = __decorate53([
  customElement("w3m-profile-view")
], W3mProfileView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-select-addresses-view/styles.js
var styles_default36 = css`
  input[type='checkbox'] {
    all: revert;
    width: var(--wui-spacing-xl);
    height: var(--wui-spacing-xl);
    accent-color: var(--wui-color-accent-100);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-select-addresses-view/index.js
var __decorate54 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSelectAddressesView = class W3mSelectAddressesView2 extends LitElement {
  constructor() {
    super();
    this.metadata = OptionsController.state.metadata;
    this.allAccounts = AccountController.state.allAccounts;
    this.selectedAccounts = AccountController.state.allAccounts;
    this.selectAll = true;
    this.approved = false;
    this.isApproving = false;
    this.getAddressTemplate = (account) => {
      const checked = this.selectedAccounts.some((_account) => _account.address === account.address);
      return html`<wui-list-account accountAddress="${account.address}" accountType="${account.type}">
      <input
        id="${account.address}"
        slot="action"
        type="checkbox"
        .checked="${checked}"
        @change="${this.handleClick(account)}"
      />
    </wui-list-account>`;
    };
    this.onSelectAll = (event) => {
      const checked = event.target.checked;
      this.selectAll = this.selectedAccounts.length === this.allAccounts.length;
      this.allAccounts.forEach((account) => {
        this.onSelect(account, checked);
      });
    };
    this.onSelect = (account, add) => {
      if (add) {
        this.selectedAccounts.push(account);
      } else {
        this.selectedAccounts = this.selectedAccounts.filter((a4) => a4.address !== account.address);
      }
      if (this.selectedAccounts.length > 0) {
        this.selectAll = this.selectedAccounts.length === this.allAccounts.length;
      }
    };
    AccountController.subscribeKey("allAccounts", (allAccounts) => {
      this.allAccounts = allAccounts;
    });
  }
  render() {
    var _a, _b;
    return html`
    <wui-flex justifyContent="center" .padding=${["xl", "0", "xl", "0"]}>
      <wui-banner-img imageSrc="${ifDefined((_a = this.metadata) == null ? void 0 : _a.icons[0])}" text="${ifDefined((_b = this.metadata) == null ? void 0 : _b.url)}" size="sm"></wui-banner>
    </wui-flex>
    <wui-flex .padding=${["0", "xl", "0", "xl"]} flexDirection="row" justifyContent="space-between">
        <wui-text variant="paragraph-400" color="fg-200">Select all</wui-text>
        <input type="checkbox" .checked=${this.selectAll}  @click=${this.onSelectAll.bind(this)} />
    </wui-flex>
      <wui-flex flexDirection="column" .padding=${["l", "xl", "xl", "xl"]}>
        ${this.allAccounts.map((account) => this.getAddressTemplate(account))}
      </wui-flex>
      <wui-flex .padding=${["l", "xl", "xl", "xl"]} gap="s" justifyContent="space-between">
        <wui-button
          size="md"
          ?fullwidth=${true}
          variant="neutral"
          @click=${this.onCancel.bind(this)}
          data-testid="w3m-connecting-siwe-cancel"
        >
          Cancel
        </wui-button>
        <wui-button
          size="md"
          ?fullwidth=${true}
          variant="main"
          .disabled=${this.selectedAccounts.length === 0}
          @click=${this.onContinue.bind(this)}
          ?loading=${this.isApproving}
        >
          ${this.isApproving ? "Signing..." : "Continue"}
        </wui-button>
      </wui-flex>
    `;
  }
  handleClick(account) {
    return (event) => {
      var _a;
      const target = event.target;
      (_a = this.onSelect) == null ? void 0 : _a.call(this, { ...account }, target == null ? void 0 : target.checked);
    };
  }
  onContinue() {
    var _a;
    if (this.selectedAccounts.length > 0) {
      this.isApproving = true;
      AccountController.setAllAccounts(this.selectedAccounts, ChainController.state.activeChain);
      AccountController.setShouldUpdateToAddress(((_a = this.selectedAccounts[0]) == null ? void 0 : _a.address) ?? "", ChainController.state.activeChain);
      this.approved = true;
      this.isApproving = false;
      ModalController.close();
    } else {
      this.onCancel();
    }
  }
  async onCancel() {
    const { activeCaipAddress } = ChainController.state;
    if (activeCaipAddress) {
      await ConnectionController.disconnect();
      ModalController.close();
    } else {
      RouterController.push("Connect");
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (!this.approved) {
      this.onCancel();
    }
  }
};
W3mSelectAddressesView.styles = styles_default36;
__decorate54([
  state()
], W3mSelectAddressesView.prototype, "allAccounts", void 0);
__decorate54([
  state()
], W3mSelectAddressesView.prototype, "selectedAccounts", void 0);
__decorate54([
  state()
], W3mSelectAddressesView.prototype, "selectAll", void 0);
__decorate54([
  state()
], W3mSelectAddressesView.prototype, "approved", void 0);
__decorate54([
  state()
], W3mSelectAddressesView.prototype, "isApproving", void 0);
W3mSelectAddressesView = __decorate54([
  customElement("w3m-select-addresses-view")
], W3mSelectAddressesView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-switch-address-view/styles.js
var styles_default37 = css`
  wui-avatar {
    width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    box-shadow: 0 0 0 0;
  }

  wui-icon-box {
    position: relative;
    right: 15px;
    top: 15px;
    border: 2px solid var(--wui-color-bg-150);
    background-color: var(--wui-color-bg-125);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-switch-address-view/index.js
var __decorate55 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSwitchAddressView = class W3mSwitchAddressView2 extends LitElement {
  constructor() {
    super();
    this.metadata = OptionsController.state.metadata;
    this.allAccounts = AccountController.state.allAccounts || [];
    this.balances = {};
    this.labels = AccountController.state.addressLabels;
    this.currentAddress = AccountController.state.address || "";
    this.connectedConnector = StorageUtil.getConnectedConnector();
    this.shouldShowIcon = this.connectedConnector === "AUTH";
    this.caipNetwork = ChainController.state.activeCaipNetwork;
    AccountController.subscribeKey("allAccounts", (allAccounts) => {
      this.allAccounts = allAccounts;
    });
  }
  connectedCallback() {
    super.connectedCallback();
    this.allAccounts.forEach((account) => {
      var _a;
      BlockchainApiController.getBalance(account.address, (_a = this.caipNetwork) == null ? void 0 : _a.id).then((response) => {
        let total = this.balances[account.address] || 0;
        if (response.balances.length > 0) {
          total = response.balances.reduce((acc, balance) => acc + ((balance == null ? void 0 : balance.value) || 0), 0);
        }
        this.balances[account.address] = total;
        this.requestUpdate();
      });
    });
  }
  getAddressIcon(type) {
    if (type === "smartAccount") {
      return "lightbulb";
    }
    return "mail";
  }
  render() {
    var _a, _b;
    return html`
      <wui-flex justifyContent="center" .padding=${["xl", "0", "xl", "0"]}>
        <wui-banner-img
          imageSrc=${ifDefined((_a = this.metadata) == null ? void 0 : _a.icons[0])}
          text=${ifDefined((_b = this.metadata) == null ? void 0 : _b.url)}
          size="sm"
        ></wui-banner-img>
      </wui-flex>
      <wui-flex flexDirection="column" gap="xxl" .padding=${["l", "xl", "xl", "xl"]}>
        ${this.allAccounts.map((account, index) => this.getAddressTemplate(account, index))}
      </wui-flex>
    `;
  }
  getAddressTemplate(account, index) {
    var _a, _b, _c, _d;
    const label = (_a = this.labels) == null ? void 0 : _a.get(account.address);
    return html`
      <wui-flex
        flexDirection="row"
        justifyContent="space-between"
        data-testid="switch-address-item"
      >
        <wui-flex alignItems="center">
          <wui-avatar address=${account.address}></wui-avatar>
          ${this.shouldShowIcon ? html`<wui-icon-box
                size="sm"
                iconcolor="fg-200"
                backgroundcolor="glass-002"
                background="gray"
                icon="${this.getAddressIcon(account.type)}"
                ?border=${true}
              ></wui-icon-box>` : html`<wui-flex .padding="${["0", "0", "0", "s"]}"></wui-flex>`}
          <wui-flex flexDirection="column">
            <wui-text class="address" variant="paragraph-500" color="fg-100"
              >${label ? label : UiHelperUtil.getTruncateString({
      string: account.address,
      charsStart: 4,
      charsEnd: 6,
      truncate: "middle"
    })}</wui-text
            >
            <wui-text class="address-description" variant="small-400">
              ${typeof this.balances[account.address] === "number" ? `$${(_b = this.balances[account.address]) == null ? void 0 : _b.toFixed(2)}` : html`<wui-loading-spinner size="sm" color="accent-100"></wui-loading-spinner>`}
            </wui-text>
          </wui-flex>
        </wui-flex>
        <wui-flex gap="s" alignItems="center">
          ${((_c = account.address) == null ? void 0 : _c.toLowerCase()) === ((_d = this.currentAddress) == null ? void 0 : _d.toLowerCase()) ? "" : html`
                <wui-button
                  data-testid=${`w3m-switch-address-button-${index}`}
                  textVariant="small-600"
                  size="md"
                  variant="accent"
                  @click=${() => this.onSwitchAddress(account.address)}
                  >Switch to</wui-button
                >
              `}
        </wui-flex>
      </wui-flex>
    `;
  }
  onSwitchAddress(address) {
    const caipNetwork = ChainController.state.activeCaipNetwork;
    const activeChainNamespace = caipNetwork == null ? void 0 : caipNetwork.chainNamespace;
    const caipAddress = `${activeChainNamespace}:${caipNetwork == null ? void 0 : caipNetwork.chainId}:${address}`;
    AccountController.setCaipAddress(caipAddress, activeChainNamespace);
    ModalController.close();
  }
};
W3mSwitchAddressView.styles = styles_default37;
__decorate55([
  state()
], W3mSwitchAddressView.prototype, "allAccounts", void 0);
__decorate55([
  state()
], W3mSwitchAddressView.prototype, "balances", void 0);
W3mSwitchAddressView = __decorate55([
  customElement("w3m-switch-address-view")
], W3mSwitchAddressView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-farcaster-view/styles.js
var styles_default38 = css`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }

  wui-logo {
    width: 80px;
    height: 80px;
    border-radius: var(--wui-border-radius-m);
  }

  wui-flex:first-child:not(:only-child) {
    position: relative;
  }
  wui-loading-thumbnail {
    position: absolute;
  }
  wui-icon-box {
    position: absolute;
    right: calc(var(--wui-spacing-3xs) * -1);
    bottom: calc(var(--wui-spacing-3xs) * -1);
    opacity: 0;
    transform: scale(0.5);
    transition: all var(--wui-ease-out-power-2) var(--wui-duration-lg);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/views/w3m-connecting-farcaster-view/index.js
var __decorate56 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingFarcasterView = class W3mConnectingFarcasterView2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.timeout = void 0;
    this.socialProvider = AccountController.state.socialProvider;
    this.uri = AccountController.state.farcasterUrl;
    this.ready = false;
    this.loading = false;
    this.authConnector = ConnectorController.getAuthConnector();
    this.forceUpdate = () => {
      this.requestUpdate();
    };
    this.unsubscribe.push(...[
      AccountController.subscribeKey("farcasterUrl", (val) => {
        if (val) {
          this.uri = val;
          this.connectFarcaster();
        }
      }),
      AccountController.subscribeKey("socialProvider", (val) => {
        if (val) {
          this.socialProvider = val;
        }
      })
    ]);
    window.addEventListener("resize", this.forceUpdate);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    clearTimeout(this.timeout);
    window.removeEventListener("resize", this.forceUpdate);
  }
  render() {
    this.onRenderProxy();
    return html`${this.platformTemplate()}`;
  }
  platformTemplate() {
    if (CoreHelperUtil.isMobile()) {
      return html`${this.mobileTemplate()}`;
    }
    return html`${this.desktopTemplate()}`;
  }
  desktopTemplate() {
    if (this.loading) {
      return html`${this.loadingTemplate()}`;
    }
    return html`${this.qrTemplate()}`;
  }
  qrTemplate() {
    return html` <wui-flex
      flexDirection="column"
      alignItems="center"
      .padding=${["0", "xl", "xl", "xl"]}
      gap="xl"
    >
      <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

      <wui-text variant="paragraph-500" color="fg-100">
        Scan this QR Code with your phone
      </wui-text>
      ${this.copyTemplate()}
    </wui-flex>`;
  }
  loadingTemplate() {
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-flex justifyContent="center" alignItems="center">
          <wui-logo logo="farcaster"></wui-logo>
          ${this.loaderTemplate()}
          <wui-icon-box
            backgroundColor="error-100"
            background="opaque"
            iconColor="error-100"
            icon="close"
            size="sm"
            border
            borderColor="wui-color-bg-125"
          ></wui-icon-box>
        </wui-flex>
        <wui-flex flexDirection="column" alignItems="center" gap="xs">
          <wui-text align="center" variant="paragraph-500" color="fg-100">
            Loading user data
          </wui-text>
          <wui-text align="center" variant="small-400" color="fg-200">
            Please wait a moment while we load your data.
          </wui-text>
        </wui-flex>
      </wui-flex>
    `;
  }
  mobileTemplate() {
    return html` <wui-flex
      flexDirection="column"
      alignItems="center"
      .padding=${["3xl", "xl", "xl", "xl"]}
      gap="xl"
    >
      <wui-flex justifyContent="center" alignItems="center">
        <wui-logo logo="farcaster"></wui-logo>
        ${this.loaderTemplate()}
        <wui-icon-box
          backgroundColor="error-100"
          background="opaque"
          iconColor="error-100"
          icon="close"
          size="sm"
          border
          borderColor="wui-color-bg-125"
        ></wui-icon-box>
      </wui-flex>
      <wui-flex flexDirection="column" alignItems="center" gap="xs">
        <wui-text align="center" variant="paragraph-500" color="fg-100"
          >Continue in Farcaster</span></wui-text
        >
        <wui-text align="center" variant="small-400" color="fg-200"
          >Accept connection request in the app</wui-text
        ></wui-flex
      >
      ${this.mobileLinkTemplate()}
    </wui-flex>`;
  }
  loaderTemplate() {
    const borderRadiusMaster = ThemeController.state.themeVariables["--w3m-border-radius-master"];
    const radius = borderRadiusMaster ? parseInt(borderRadiusMaster.replace("px", ""), 10) : 4;
    return html`<wui-loading-thumbnail radius=${radius * 9}></wui-loading-thumbnail>`;
  }
  async connectFarcaster() {
    var _a;
    if (this.authConnector) {
      try {
        await ((_a = this.authConnector) == null ? void 0 : _a.provider.connectFarcaster());
        if (this.socialProvider) {
          StorageUtil.setConnectedSocialProvider(this.socialProvider);
        }
        this.loading = true;
        await ConnectionController.connectExternal(this.authConnector, this.authConnector.chain);
        this.loading = false;
        ModalController.close();
      } catch (error) {
        RouterController.goBack();
        SnackController.showError(error);
      }
    }
  }
  mobileLinkTemplate() {
    return html`<wui-button
      size="md"
      ?loading=${this.loading}
      ?disabled=${!this.uri || this.loading}
      @click=${() => {
      if (this.uri) {
        CoreHelperUtil.openHref(this.uri, "_blank");
      }
    }}
    >
      Open farcaster</wui-button
    >`;
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.timeout = setTimeout(() => {
        this.ready = true;
      }, 0);
    }
  }
  qrCodeTemplate() {
    if (!this.uri || !this.ready) {
      return null;
    }
    const size = this.getBoundingClientRect().width - 40;
    return html` <wui-qr-code
      size=${size}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      ?farcaster=${true}
      data-testid="wui-qr-code"
    ></wui-qr-code>`;
  }
  copyTemplate() {
    const inactive = !this.uri || !this.ready;
    return html`<wui-link
      .disabled=${inactive}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
      Copy link
    </wui-link>`;
  }
  onCopyUri() {
    try {
      if (this.uri) {
        CoreHelperUtil.copyToClopboard(this.uri);
        SnackController.showSuccess("Link copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
};
W3mConnectingFarcasterView.styles = styles_default38;
__decorate56([
  state()
], W3mConnectingFarcasterView.prototype, "socialProvider", void 0);
__decorate56([
  state()
], W3mConnectingFarcasterView.prototype, "uri", void 0);
__decorate56([
  state()
], W3mConnectingFarcasterView.prototype, "ready", void 0);
__decorate56([
  state()
], W3mConnectingFarcasterView.prototype, "loading", void 0);
W3mConnectingFarcasterView = __decorate56([
  customElement("w3m-connecting-farcaster-view")
], W3mConnectingFarcasterView);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list/styles.js
var styles_default39 = css`
  wui-grid {
    max-height: clamp(360px, 400px, 80vh);
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
    grid-template-columns: repeat(auto-fill, 76px);
  }

  @media (max-width: 435px) {
    wui-grid {
      grid-template-columns: repeat(auto-fill, 77px);
    }
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    padding-top: var(--wui-spacing-l);
    padding-bottom: var(--wui-spacing-l);
    justify-content: center;
    grid-column: 1 / span 4;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/markWalletsAsInstalled.js
function markWalletsAsInstalled(wallets) {
  const { connectors } = ConnectorController.state;
  const installedConnectors = connectors.filter((c5) => c5.type === "ANNOUNCED").reduce((acum, val) => {
    var _a;
    if (!((_a = val.info) == null ? void 0 : _a.rdns)) {
      return acum;
    }
    acum[val.info.rdns] = true;
    return acum;
  }, {});
  const walletsWithInstalled = wallets.map((wallet) => ({
    ...wallet,
    installed: Boolean(wallet.rdns) && Boolean(installedConnectors[wallet.rdns ?? ""])
  }));
  const sortedWallets = walletsWithInstalled.sort((a4, b3) => Number(b3.installed) - Number(a4.installed));
  return sortedWallets;
}

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list/index.js
var __decorate57 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var PAGINATOR_ID = "local-paginator";
var W3mAllWalletsList = class W3mAllWalletsList2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.initial = !ApiController.state.wallets.length;
    this.wallets = ApiController.state.wallets;
    this.recommended = ApiController.state.recommended;
    this.featured = ApiController.state.featured;
    this.unsubscribe.push(...[
      ApiController.subscribeKey("wallets", (val) => this.wallets = val),
      ApiController.subscribeKey("recommended", (val) => this.recommended = val),
      ApiController.subscribeKey("featured", (val) => this.featured = val)
    ]);
  }
  firstUpdated() {
    this.initialFetch();
    this.createPaginationObserver();
  }
  disconnectedCallback() {
    var _a;
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    (_a = this.paginationObserver) == null ? void 0 : _a.disconnect();
  }
  render() {
    return html`
      <wui-grid
        data-scroll=${!this.initial}
        .padding=${["0", "s", "s", "s"]}
        columnGap="xxs"
        rowGap="l"
        justifyContent="space-between"
      >
        ${this.initial ? this.shimmerTemplate(16) : this.walletsTemplate()}
        ${this.paginationLoaderTemplate()}
      </wui-grid>
    `;
  }
  async initialFetch() {
    var _a;
    const gridEl = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("wui-grid");
    if (this.initial && gridEl) {
      await ApiController.fetchWallets({ page: 1 });
      await gridEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.initial = false;
      gridEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  shimmerTemplate(items, id) {
    return [...Array(items)].map(() => html`
        <wui-card-select-loader type="wallet" id=${ifDefined(id)}></wui-card-select-loader>
      `);
  }
  walletsTemplate() {
    const wallets = [...this.featured, ...this.recommended, ...this.wallets];
    const walletsWithInstalled = markWalletsAsInstalled(wallets);
    return walletsWithInstalled.map((wallet) => html`
        <w3m-all-wallets-list-item
          @click=${() => this.onConnectWallet(wallet)}
          .wallet=${wallet}
        ></w3m-all-wallets-list-item>
      `);
  }
  paginationLoaderTemplate() {
    const { wallets, recommended, featured, count } = ApiController.state;
    const columns = window.innerWidth < 352 ? 3 : 4;
    const currentWallets = wallets.length + recommended.length;
    const minimumRows = Math.ceil(currentWallets / columns);
    let shimmerCount = minimumRows * columns - currentWallets + columns;
    shimmerCount -= wallets.length ? featured.length % columns : 0;
    if (count === 0 && featured.length > 0) {
      return null;
    }
    if (count === 0 || [...featured, ...wallets, ...recommended].length < count) {
      return this.shimmerTemplate(shimmerCount, PAGINATOR_ID);
    }
    return null;
  }
  createPaginationObserver() {
    var _a;
    const loaderEl = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector(`#${PAGINATOR_ID}`);
    if (loaderEl) {
      this.paginationObserver = new IntersectionObserver(([element]) => {
        if ((element == null ? void 0 : element.isIntersecting) && !this.initial) {
          const { page, count, wallets } = ApiController.state;
          if (wallets.length < count) {
            ApiController.fetchWallets({ page: page + 1 });
          }
        }
      });
      this.paginationObserver.observe(loaderEl);
    }
  }
  onConnectWallet(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mAllWalletsList.styles = styles_default39;
__decorate57([
  state()
], W3mAllWalletsList.prototype, "initial", void 0);
__decorate57([
  state()
], W3mAllWalletsList.prototype, "wallets", void 0);
__decorate57([
  state()
], W3mAllWalletsList.prototype, "recommended", void 0);
__decorate57([
  state()
], W3mAllWalletsList.prototype, "featured", void 0);
W3mAllWalletsList = __decorate57([
  customElement("w3m-all-wallets-list")
], W3mAllWalletsList);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list-item/styles.js
var styles_default40 = css`
  button {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    width: 76px;
    row-gap: var(--wui-spacing-xs);
    padding: var(--wui-spacing-xs) var(--wui-spacing-0);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: clamp(0px, var(--wui-border-radius-xs), 20px);
    will-change: background-color, color;
    outline: none;
    border: none;
  }

  button > wui-text {
    color: var(--wui-color-fg-100);
    max-width: var(--wui-icon-box-size-xl);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    justify-content: center;
  }

  button:hover:enabled {
    background-color: var(--wui-color-gray-glass-005);
  }

  button:disabled > wui-text {
    color: var(--wui-color-gray-glass-015);
  }

  [data-selected='true'] {
    background-color: var(--wui-color-accent-glass-020);
  }

  @media (hover: hover) and (pointer: fine) {
    [data-selected='true']:hover:enabled {
      background-color: var(--wui-color-accent-glass-015);
    }
  }

  [data-selected='true']:active:enabled {
    background-color: var(--wui-color-accent-glass-010);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-list-item/index.js
var __decorate58 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAllWalletsListItem = class W3mAllWalletsListItem2 extends LitElement {
  constructor() {
    super();
    this.observer = new IntersectionObserver(() => void 0);
    this.visible = false;
    this.imageSrc = void 0;
    this.imageLoading = false;
    this.wallet = void 0;
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.visible = true;
          this.fetchImageSrc();
        } else {
          this.visible = false;
        }
      });
    }, { threshold: 0.01 });
  }
  firstUpdated() {
    this.observer.observe(this);
  }
  disconnectedCallback() {
    this.observer.disconnect();
  }
  render() {
    var _a;
    return html`
      <button ontouchstart>
        ${this.imageTemplate()}
        <wui-text variant="tiny-500" color="inherit">${(_a = this.wallet) == null ? void 0 : _a.name}</wui-text>
      </button>
    `;
  }
  imageTemplate() {
    var _a, _b;
    if (!this.visible && !this.imageSrc || this.imageLoading) {
      return this.shimmerTemplate();
    }
    return html`
      <wui-wallet-image
        size="md"
        imageSrc=${ifDefined(this.imageSrc)}
        name=${(_a = this.wallet) == null ? void 0 : _a.name}
        .installed=${(_b = this.wallet) == null ? void 0 : _b.installed}
        badgeSize="sm"
      >
      </wui-wallet-image>
    `;
  }
  shimmerTemplate() {
    return html`<wui-shimmer width="56px" height="56px" borderRadius="xs"></wui-shimmer>`;
  }
  async fetchImageSrc() {
    if (!this.wallet) {
      return;
    }
    this.imageSrc = AssetUtil.getWalletImage(this.wallet);
    if (this.imageSrc) {
      return;
    }
    this.imageLoading = true;
    this.imageSrc = await AssetUtil.fetchWalletImage(this.wallet.image_id);
    this.imageLoading = false;
  }
};
W3mAllWalletsListItem.styles = styles_default40;
__decorate58([
  state()
], W3mAllWalletsListItem.prototype, "visible", void 0);
__decorate58([
  state()
], W3mAllWalletsListItem.prototype, "imageSrc", void 0);
__decorate58([
  state()
], W3mAllWalletsListItem.prototype, "imageLoading", void 0);
__decorate58([
  property()
], W3mAllWalletsListItem.prototype, "wallet", void 0);
W3mAllWalletsListItem = __decorate58([
  customElement("w3m-all-wallets-list-item")
], W3mAllWalletsListItem);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-search/styles.js
var styles_default41 = css`
  wui-grid,
  wui-loading-spinner,
  wui-flex {
    height: 360px;
  }

  wui-grid {
    overflow: scroll;
    scrollbar-width: none;
    grid-auto-rows: min-content;
  }

  wui-grid[data-scroll='false'] {
    overflow: hidden;
  }

  wui-grid::-webkit-scrollbar {
    display: none;
  }

  wui-loading-spinner {
    justify-content: center;
    align-items: center;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-search/index.js
var __decorate59 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAllWalletsSearch = class W3mAllWalletsSearch2 extends LitElement {
  constructor() {
    super(...arguments);
    this.prevQuery = "";
    this.loading = true;
    this.query = "";
  }
  render() {
    this.onSearch();
    return this.loading ? html`<wui-loading-spinner color="accent-100"></wui-loading-spinner>` : this.walletsTemplate();
  }
  async onSearch() {
    if (this.query.trim() !== this.prevQuery.trim()) {
      this.prevQuery = this.query;
      this.loading = true;
      await ApiController.searchWallet({ search: this.query });
      this.loading = false;
    }
  }
  walletsTemplate() {
    const { search } = ApiController.state;
    const wallets = markWalletsAsInstalled(search);
    if (!search.length) {
      return html`
        <wui-flex justifyContent="center" alignItems="center" gap="s" flexDirection="column">
          <wui-icon-box
            size="lg"
            iconColor="fg-200"
            backgroundColor="fg-300"
            icon="wallet"
            background="transparent"
          ></wui-icon-box>
          <wui-text color="fg-200" variant="paragraph-500">No Wallet found</wui-text>
        </wui-flex>
      `;
    }
    return html`
      <wui-grid
        .padding=${["0", "s", "s", "s"]}
        gridTemplateColumns="repeat(4, 1fr)"
        rowGap="l"
        columnGap="xs"
      >
        ${wallets.map((wallet) => html`
            <w3m-all-wallets-list-item
              @click=${() => this.onConnectWallet(wallet)}
              .wallet=${wallet}
            ></w3m-all-wallets-list-item>
          `)}
      </wui-grid>
    `;
  }
  onConnectWallet(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mAllWalletsSearch.styles = styles_default41;
__decorate59([
  state()
], W3mAllWalletsSearch.prototype, "loading", void 0);
__decorate59([
  property()
], W3mAllWalletsSearch.prototype, "query", void 0);
W3mAllWalletsSearch = __decorate59([
  customElement("w3m-all-wallets-search")
], W3mAllWalletsSearch);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-header/index.js
var __decorate60 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingHeader = class W3mConnectingHeader2 extends LitElement {
  constructor() {
    super();
    this.platformTabs = [];
    this.unsubscribe = [];
    this.platforms = [];
    this.onSelectPlatfrom = void 0;
    this.buffering = false;
    this.unsubscribe.push(ConnectionController.subscribeKey("buffering", (val) => this.buffering = val));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const tabs = this.generateTabs();
    return html`
      <wui-flex justifyContent="center" .padding=${["0", "0", "l", "0"]}>
        <wui-tabs
          ?disabled=${this.buffering}
          .tabs=${tabs}
          .onTabChange=${this.onTabChange.bind(this)}
        ></wui-tabs>
      </wui-flex>
    `;
  }
  generateTabs() {
    const tabs = this.platforms.map((platform) => {
      if (platform === "browser") {
        return { label: "Browser", icon: "extension", platform: "browser" };
      } else if (platform === "mobile") {
        return { label: "Mobile", icon: "mobile", platform: "mobile" };
      } else if (platform === "qrcode") {
        return { label: "Mobile", icon: "mobile", platform: "qrcode" };
      } else if (platform === "web") {
        return { label: "Webapp", icon: "browser", platform: "web" };
      } else if (platform === "desktop") {
        return { label: "Desktop", icon: "desktop", platform: "desktop" };
      }
      return { label: "Browser", icon: "extension", platform: "unsupported" };
    });
    this.platformTabs = tabs.map(({ platform }) => platform);
    return tabs;
  }
  onTabChange(index) {
    var _a;
    const tab = this.platformTabs[index];
    if (tab) {
      (_a = this.onSelectPlatfrom) == null ? void 0 : _a.call(this, tab);
    }
  }
};
__decorate60([
  property({ type: Array })
], W3mConnectingHeader.prototype, "platforms", void 0);
__decorate60([
  property()
], W3mConnectingHeader.prototype, "onSelectPlatfrom", void 0);
__decorate60([
  state()
], W3mConnectingHeader.prototype, "buffering", void 0);
W3mConnectingHeader = __decorate60([
  customElement("w3m-connecting-header")
], W3mConnectingHeader);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-browser/index.js
var __decorate61 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWcBrowser = class W3mConnectingWcBrowser2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-browser: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onAutoConnect = this.onConnectProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  async onConnectProxy() {
    var _a;
    try {
      this.error = false;
      const { connectors } = ConnectorController.state;
      const announcedConnector = connectors.find((c5) => {
        var _a2, _b;
        return c5.type === "ANNOUNCED" && ((_a2 = c5.info) == null ? void 0 : _a2.rdns) === ((_b = this.wallet) == null ? void 0 : _b.rdns);
      });
      const injectedConnector = connectors.find((c5) => c5.type === "INJECTED");
      if (announcedConnector) {
        await ConnectionController.connectExternal(announcedConnector, announcedConnector.chain);
      } else if (injectedConnector) {
        await ConnectionController.connectExternal(injectedConnector, injectedConnector.chain);
      }
      ModalController.close();
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_SUCCESS",
        properties: { method: "browser", name: ((_a = this.wallet) == null ? void 0 : _a.name) || "Unknown" }
      });
    } catch (error) {
      EventsController.sendEvent({
        type: "track",
        event: "CONNECT_ERROR",
        properties: { message: (error == null ? void 0 : error.message) ?? "Unknown" }
      });
      this.error = true;
    }
  }
};
W3mConnectingWcBrowser = __decorate61([
  customElement("w3m-connecting-wc-browser")
], W3mConnectingWcBrowser);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-desktop/index.js
var __decorate62 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWcDesktop = class W3mConnectingWcDesktop2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-desktop: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onRender = this.onRenderProxy.bind(this);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "desktop" }
    });
  }
  onRenderProxy() {
    var _a;
    if (!this.ready && this.uri) {
      this.ready = true;
      (_a = this.onConnect) == null ? void 0 : _a.call(this);
    }
  }
  onConnectProxy() {
    var _a;
    if (((_a = this.wallet) == null ? void 0 : _a.desktop_link) && this.uri) {
      try {
        this.error = false;
        const { desktop_link, name } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatNativeUrl(desktop_link, this.uri);
        ConnectionController.setWcLinking({ name, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_blank");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcDesktop = __decorate62([
  customElement("w3m-connecting-wc-desktop")
], W3mConnectingWcDesktop);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-mobile/index.js
var __decorate63 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWcMobile = class W3mConnectingWcMobile2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-mobile: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.onRender = this.onRenderProxy.bind(this);
    document.addEventListener("visibilitychange", this.onBuffering.bind(this));
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "mobile" }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("visibilitychange", this.onBuffering.bind(this));
  }
  onRenderProxy() {
    var _a;
    if (!this.ready && this.uri) {
      this.ready = true;
      (_a = this.onConnect) == null ? void 0 : _a.call(this);
    }
  }
  onConnectProxy() {
    var _a;
    if (((_a = this.wallet) == null ? void 0 : _a.mobile_link) && this.uri) {
      try {
        this.error = false;
        const { mobile_link, name } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatNativeUrl(mobile_link, this.uri);
        ConnectionController.setWcLinking({ name, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_self");
      } catch {
        this.error = true;
      }
    }
  }
  onBuffering() {
    const isIos = CoreHelperUtil.isIos();
    if ((document == null ? void 0 : document.visibilityState) === "visible" && !this.error && isIos) {
      ConnectionController.setBuffering(true);
      setTimeout(() => {
        ConnectionController.setBuffering(false);
      }, 5e3);
    }
  }
};
W3mConnectingWcMobile = __decorate63([
  customElement("w3m-connecting-wc-mobile")
], W3mConnectingWcMobile);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-qrcode/styles.js
var styles_default42 = css`
  @keyframes fadein {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  wui-shimmer {
    width: 100%;
    aspect-ratio: 1 / 1;
    border-radius: clamp(0px, var(--wui-border-radius-l), 40px) !important;
  }

  wui-qr-code {
    opacity: 0;
    animation-duration: 200ms;
    animation-timing-function: ease;
    animation-name: fadein;
    animation-fill-mode: forwards;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-qrcode/index.js
var __decorate64 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWcQrcode = class W3mConnectingWcQrcode2 extends W3mConnectingWidget {
  constructor() {
    var _a;
    super();
    this.forceUpdate = () => {
      this.requestUpdate();
    };
    window.addEventListener("resize", this.forceUpdate);
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: ((_a = this.wallet) == null ? void 0 : _a.name) ?? "WalletConnect", platform: "qrcode" }
    });
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("resize", this.forceUpdate);
  }
  render() {
    this.onRenderProxy();
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["0", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-shimmer borderRadius="l" width="100%"> ${this.qrCodeTemplate()} </wui-shimmer>

        <wui-text variant="paragraph-500" color="fg-100">
          Scan this QR Code with your phone
        </wui-text>
        ${this.copyTemplate()}
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
  onRenderProxy() {
    if (!this.ready && this.uri) {
      this.timeout = setTimeout(() => {
        this.ready = true;
      }, 200);
    }
  }
  qrCodeTemplate() {
    if (!this.uri || !this.ready) {
      return null;
    }
    const size = this.getBoundingClientRect().width - 40;
    const alt = this.wallet ? this.wallet.name : void 0;
    ConnectionController.setWcLinking(void 0);
    ConnectionController.setRecentWallet(this.wallet);
    return html` <wui-qr-code
      size=${size}
      theme=${ThemeController.state.themeMode}
      uri=${this.uri}
      imageSrc=${ifDefined(AssetUtil.getWalletImage(this.wallet))}
      alt=${ifDefined(alt)}
      data-testid="wui-qr-code"
    ></wui-qr-code>`;
  }
  copyTemplate() {
    const inactive = !this.uri || !this.ready;
    return html`<wui-link
      .disabled=${inactive}
      @click=${this.onCopyUri}
      color="fg-200"
      data-testid="copy-wc2-uri"
    >
      <wui-icon size="xs" color="fg-200" slot="iconLeft" name="copy"></wui-icon>
      Copy link
    </wui-link>`;
  }
};
W3mConnectingWcQrcode.styles = styles_default42;
W3mConnectingWcQrcode = __decorate64([
  customElement("w3m-connecting-wc-qrcode")
], W3mConnectingWcQrcode);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-unsupported/index.js
var __decorate65 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWcUnsupported = class W3mConnectingWcUnsupported2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.wallet = (_a = RouterController.state.data) == null ? void 0 : _a.wallet;
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-unsupported: No wallet provided");
    }
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "browser" }
    });
  }
  render() {
    return html`
      <wui-flex
        flexDirection="column"
        alignItems="center"
        .padding=${["3xl", "xl", "xl", "xl"]}
        gap="xl"
      >
        <wui-wallet-image
          size="lg"
          imageSrc=${ifDefined(AssetUtil.getWalletImage(this.wallet))}
        ></wui-wallet-image>

        <wui-text variant="paragraph-500" color="fg-100">Not Detected</wui-text>
      </wui-flex>

      <w3m-mobile-download-links .wallet=${this.wallet}></w3m-mobile-download-links>
    `;
  }
};
W3mConnectingWcUnsupported = __decorate65([
  customElement("w3m-connecting-wc-unsupported")
], W3mConnectingWcUnsupported);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connecting-wc-web/index.js
var __decorate66 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectingWcWeb = class W3mConnectingWcWeb2 extends W3mConnectingWidget {
  constructor() {
    super();
    if (!this.wallet) {
      throw new Error("w3m-connecting-wc-web: No wallet provided");
    }
    this.onConnect = this.onConnectProxy.bind(this);
    this.secondaryBtnLabel = "Open";
    this.secondaryLabel = "Open and continue in a new browser tab";
    this.secondaryBtnIcon = "externalLink";
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WALLET",
      properties: { name: this.wallet.name, platform: "web" }
    });
  }
  onConnectProxy() {
    var _a;
    if (((_a = this.wallet) == null ? void 0 : _a.webapp_link) && this.uri) {
      try {
        this.error = false;
        const { webapp_link, name } = this.wallet;
        const { redirect, href } = CoreHelperUtil.formatUniversalUrl(webapp_link, this.uri);
        ConnectionController.setWcLinking({ name, href });
        ConnectionController.setRecentWallet(this.wallet);
        CoreHelperUtil.openHref(redirect, "_blank");
      } catch {
        this.error = true;
      }
    }
  }
};
W3mConnectingWcWeb = __decorate66([
  customElement("w3m-connecting-wc-web")
], W3mConnectingWcWeb);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-swap-details/styles.js
var styles_default43 = css`
  :host {
    width: 100%;
  }

  .details-container > wui-flex {
    background: var(--wui-color-gray-glass-002);
    border-radius: var(--wui-border-radius-xxs);
    width: 100%;
  }

  .details-container > wui-flex > button {
    border: none;
    background: none;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    cursor: pointer;
  }

  .details-content-container {
    padding: var(--wui-spacing-1xs);
    padding-top: 0px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .details-content-container > wui-flex {
    width: 100%;
  }

  .details-row {
    width: 100%;
    padding: var(--wui-spacing-s);
    padding-left: var(--wui-spacing-s);
    padding-right: var(--wui-spacing-1xs);
    border-radius: calc(var(--wui-border-radius-5xs) + var(--wui-border-radius-4xs));
    background: var(--wui-color-gray-glass-002);
  }

  .details-row-title {
    white-space: nowrap;
  }

  .details-row.provider-free-row {
    padding-right: var(--wui-spacing-xs);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-swap-details/index.js
var __decorate67 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var slippageRate = ConstantsUtil2.CONVERT_SLIPPAGE_TOLERANCE;
var WuiSwapDetails = class WuiSwapDetails2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.unsubscribe = [];
    this.networkName = (_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.name;
    this.detailsOpen = false;
    this.sourceToken = SwapController.state.sourceToken;
    this.toToken = SwapController.state.toToken;
    this.toTokenAmount = SwapController.state.toTokenAmount;
    this.sourceTokenPriceInUSD = SwapController.state.sourceTokenPriceInUSD;
    this.toTokenPriceInUSD = SwapController.state.toTokenPriceInUSD;
    this.gasPriceInUSD = SwapController.state.gasPriceInUSD;
    this.priceImpact = SwapController.state.priceImpact;
    this.maxSlippage = SwapController.state.maxSlippage;
    this.networkTokenSymbol = SwapController.state.networkTokenSymbol;
    this.inputError = SwapController.state.inputError;
    this.unsubscribe.push(...[
      SwapController.subscribe((newState) => {
        this.sourceToken = newState.sourceToken;
        this.toToken = newState.toToken;
        this.toTokenAmount = newState.toTokenAmount;
        this.gasPriceInUSD = newState.gasPriceInUSD;
        this.priceImpact = newState.priceImpact;
        this.maxSlippage = newState.maxSlippage;
        this.sourceTokenPriceInUSD = newState.sourceTokenPriceInUSD;
        this.toTokenPriceInUSD = newState.toTokenPriceInUSD;
        this.inputError = newState.inputError;
      })
    ]);
  }
  render() {
    const minReceivedAmount = this.toTokenAmount && this.maxSlippage ? NumberUtil.bigNumber(this.toTokenAmount).minus(this.maxSlippage).toString() : null;
    if (!this.sourceToken || !this.toToken || this.inputError) {
      return null;
    }
    const toTokenSwappedAmount = this.sourceTokenPriceInUSD && this.toTokenPriceInUSD ? 1 / this.toTokenPriceInUSD * this.sourceTokenPriceInUSD : 0;
    return html`
      <wui-flex flexDirection="column" alignItems="center" gap="1xs" class="details-container">
        <wui-flex flexDirection="column">
          <button @click=${this.toggleDetails.bind(this)}>
            <wui-flex justifyContent="space-between" .padding=${["0", "xs", "0", "xs"]}>
              <wui-flex justifyContent="flex-start" flexGrow="1" gap="xs">
                <wui-text variant="small-400" color="fg-100">
                  1 ${this.sourceToken.symbol} =
                  ${UiHelperUtil.formatNumberToLocalString(toTokenSwappedAmount, 3)}
                  ${this.toToken.symbol}
                </wui-text>
                <wui-text variant="small-400" color="fg-200">
                  $${UiHelperUtil.formatNumberToLocalString(this.sourceTokenPriceInUSD)}
                </wui-text>
              </wui-flex>
              <wui-icon name="chevronBottom"></wui-icon>
            </wui-flex>
          </button>
          ${this.detailsOpen ? html`
                <wui-flex flexDirection="column" gap="xs" class="details-content-container">
                  <wui-flex flexDirection="column" gap="xs">
                    <wui-flex
                      justifyContent="space-between"
                      alignItems="center"
                      class="details-row"
                    >
                      <wui-flex alignItems="center" gap="xs">
                        <wui-text class="details-row-title" variant="small-400" color="fg-150">
                          Network cost
                        </wui-text>
                        <w3m-tooltip-trigger
                          text=${`Network cost is paid in ${this.networkTokenSymbol} on the ${this.networkName} network in order to execute transaction.`}
                        >
                          <wui-icon size="xs" color="fg-250" name="infoCircle"></wui-icon>
                        </w3m-tooltip-trigger>
                      </wui-flex>
                      <wui-text variant="small-400" color="fg-100">
                        $${UiHelperUtil.formatNumberToLocalString(this.gasPriceInUSD, 3)}
                      </wui-text>
                    </wui-flex>
                  </wui-flex>
                  ${this.priceImpact ? html` <wui-flex flexDirection="column" gap="xs">
                        <wui-flex
                          justifyContent="space-between"
                          alignItems="center"
                          class="details-row"
                        >
                          <wui-flex alignItems="center" gap="xs">
                            <wui-text class="details-row-title" variant="small-400" color="fg-150">
                              Price impact
                            </wui-text>
                            <w3m-tooltip-trigger
                              text="Price impact reflects the change in market price due to your trade"
                            >
                              <wui-icon size="xs" color="fg-250" name="infoCircle"></wui-icon>
                            </w3m-tooltip-trigger>
                          </wui-flex>
                          <wui-flex>
                            <wui-text variant="small-400" color="fg-200">
                              ${UiHelperUtil.formatNumberToLocalString(this.priceImpact, 3)}%
                            </wui-text>
                          </wui-flex>
                        </wui-flex>
                      </wui-flex>` : null}
                  ${this.maxSlippage && this.sourceToken.symbol ? html`<wui-flex flexDirection="column" gap="xs">
                        <wui-flex
                          justifyContent="space-between"
                          alignItems="center"
                          class="details-row"
                        >
                          <wui-flex alignItems="center" gap="xs">
                            <wui-text class="details-row-title" variant="small-400" color="fg-150">
                              Max. slippage
                            </wui-text>
                            <w3m-tooltip-trigger
                              text=${`Max slippage sets the minimum amount you must receive for the transaction to proceed. ${minReceivedAmount ? `Transaction will be reversed if you receive less than ${UiHelperUtil.formatNumberToLocalString(minReceivedAmount, 6)} ${this.toToken.symbol} due to price changes.` : ""}`}
                            >
                              <wui-icon size="xs" color="fg-250" name="infoCircle"></wui-icon>
                            </w3m-tooltip-trigger>
                          </wui-flex>
                          <wui-flex>
                            <wui-text variant="small-400" color="fg-200">
                              ${UiHelperUtil.formatNumberToLocalString(this.maxSlippage, 6)}
                              ${this.toToken.symbol} ${slippageRate}%
                            </wui-text>
                          </wui-flex>
                        </wui-flex>
                      </wui-flex>` : null}
                  <wui-flex flexDirection="column" gap="xs">
                    <wui-flex
                      justifyContent="space-between"
                      alignItems="center"
                      class="details-row provider-free-row"
                    >
                      <wui-flex alignItems="center" gap="xs">
                        <wui-text class="details-row-title" variant="small-400" color="fg-150">
                          Provider fee
                        </wui-text>
                      </wui-flex>
                      <wui-flex>
                        <wui-text variant="small-400" color="fg-200">0.85%</wui-text>
                      </wui-flex>
                    </wui-flex>
                  </wui-flex>
                </wui-flex>
              ` : null}
        </wui-flex>
      </wui-flex>
    `;
  }
  toggleDetails() {
    this.detailsOpen = !this.detailsOpen;
  }
};
WuiSwapDetails.styles = [styles_default43];
__decorate67([
  state()
], WuiSwapDetails.prototype, "networkName", void 0);
__decorate67([
  property()
], WuiSwapDetails.prototype, "detailsOpen", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "sourceToken", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "toToken", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "toTokenAmount", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "sourceTokenPriceInUSD", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "toTokenPriceInUSD", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "gasPriceInUSD", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "priceImpact", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "maxSlippage", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "networkTokenSymbol", void 0);
__decorate67([
  state()
], WuiSwapDetails.prototype, "inputError", void 0);
WuiSwapDetails = __decorate67([
  customElement("w3m-swap-details")
], WuiSwapDetails);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-swap-input/styles.js
var styles_default44 = css`
  :host > wui-flex {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    border-radius: var(--wui-border-radius-s);
    background-color: var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-xl);
    padding-right: var(--wui-spacing-s);
    width: 100%;
    height: 100px;
    box-sizing: border-box;
    box-shadow: inset 0px 0px 0px 1px var(--wui-color-gray-glass-002);
    position: relative;
    transition: box-shadow var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  :host wui-flex.focus {
    box-shadow: inset 0px 0px 0px 1px var(--wui-color-gray-glass-005);
  }

  :host > wui-flex .swap-input,
  :host > wui-flex .swap-token-button {
    z-index: 10;
  }

  :host > wui-flex .swap-input {
    -webkit-mask-image: linear-gradient(
      270deg,
      transparent 0px,
      transparent 8px,
      black 24px,
      black 25px,
      black 32px,
      black 100%
    );
    mask-image: linear-gradient(
      270deg,
      transparent 0px,
      transparent 8px,
      black 24px,
      black 25px,
      black 32px,
      black 100%
    );
  }

  :host > wui-flex .swap-input input {
    background: none;
    border: none;
    height: 42px;
    width: 100%;
    font-size: 32px;
    font-style: normal;
    font-weight: 400;
    line-height: 130%;
    letter-spacing: -1.28px;
    outline: none;
    caret-color: var(--wui-color-accent-100);
    color: var(--wui-color-fg-100);
    padding: 0px;
  }

  :host > wui-flex .swap-input input:focus-visible {
    outline: none;
  }

  :host > wui-flex .swap-input input::-webkit-outer-spin-button,
  :host > wui-flex .swap-input input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  .max-value-button {
    background-color: transparent;
    border: none;
    cursor: pointer;
    color: var(--wui-color-gray-glass-020);
    padding-left: 0px;
  }

  .market-value {
    min-height: 18px;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-swap-input/index.js
var __decorate68 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var MINIMUM_USD_VALUE_TO_CONVERT = 5e-5;
var W3mSwapInput = class W3mSwapInput2 extends LitElement {
  constructor() {
    super(...arguments);
    this.focused = false;
    this.price = 0;
    this.target = "sourceToken";
    this.onSetAmount = null;
    this.onSetMaxValue = null;
  }
  render() {
    const marketValue = this.marketValue || "0";
    const isMarketValueGreaterThanZero = NumberUtil.bigNumber(marketValue).isGreaterThan("0");
    return html`
      <wui-flex class="${this.focused ? "focus" : ""}" justifyContent="space-between">
        <wui-flex
          flex="1"
          flexDirection="column"
          alignItems="flex-start"
          justifyContent="center"
          class="swap-input"
        >
          <input
            data-testid="swap-input-${this.target}"
            @focusin=${() => this.onFocusChange(true)}
            @focusout=${() => this.onFocusChange(false)}
            ?disabled=${this.disabled}
            .value=${this.value}
            @input=${this.dispatchInputChangeEvent}
            @keydown=${this.handleKeydown}
            placeholder="0"
            type="text"
            inputmode="decimal"
          />
          <wui-text class="market-value" variant="small-400" color="fg-200">
            ${isMarketValueGreaterThanZero ? `$${UiHelperUtil.formatNumberToLocalString(this.marketValue, 3)}` : null}
          </wui-text>
        </wui-flex>
        ${this.templateTokenSelectButton()}
      </wui-flex>
    `;
  }
  handleKeydown(event) {
    return InputUtil.numericInputKeyDown(event, this.value, (value) => {
      var _a;
      return (_a = this.onSetAmount) == null ? void 0 : _a.call(this, this.target, value);
    });
  }
  dispatchInputChangeEvent(event) {
    if (!this.onSetAmount) {
      return;
    }
    const value = event.target.value.replace(/[^0-9.]/gu, "");
    if (value === "," || value === ".") {
      this.onSetAmount(this.target, "0.");
    } else if (value.endsWith(",")) {
      this.onSetAmount(this.target, value.replace(",", "."));
    } else {
      this.onSetAmount(this.target, value);
    }
  }
  setMaxValueToInput() {
    var _a;
    (_a = this.onSetMaxValue) == null ? void 0 : _a.call(this, this.target, this.balance);
  }
  templateTokenSelectButton() {
    if (!this.token) {
      return html` <wui-button
        data-testid="swap-select-token-button-${this.target}"
        class="swap-token-button"
        size="md"
        variant="accent"
        @click=${this.onSelectToken.bind(this)}
      >
        Select token
      </wui-button>`;
    }
    return html`
      <wui-flex
        class="swap-token-button"
        flexDirection="column"
        alignItems="flex-end"
        justifyContent="center"
        gap="xxs"
      >
        <wui-token-button
          data-testid="swap-input-token-${this.target}"
          text=${this.token.symbol}
          imageSrc=${this.token.logoUri}
          @click=${this.onSelectToken.bind(this)}
        >
        </wui-token-button>
        <wui-flex alignItems="center" gap="xxs"> ${this.tokenBalanceTemplate()} </wui-flex>
      </wui-flex>
    `;
  }
  tokenBalanceTemplate() {
    const balanceValueInUSD = NumberUtil.multiply(this.balance, this.price);
    const haveBalance = balanceValueInUSD ? balanceValueInUSD == null ? void 0 : balanceValueInUSD.isGreaterThan(MINIMUM_USD_VALUE_TO_CONVERT) : false;
    return html`
      ${haveBalance ? html`<wui-text variant="small-400" color="fg-200">
            ${UiHelperUtil.formatNumberToLocalString(this.balance, 3)}
          </wui-text>` : null}
      ${this.target === "sourceToken" ? this.tokenActionButtonTemplate(haveBalance) : null}
    `;
  }
  tokenActionButtonTemplate(haveBalance) {
    if (haveBalance) {
      return html` <button class="max-value-button" @click=${this.setMaxValueToInput.bind(this)}>
        <wui-text color="accent-100" variant="small-600">Max</wui-text>
      </button>`;
    }
    return html` <button class="max-value-button" @click=${this.onBuyToken.bind(this)}>
      <wui-text color="accent-100" variant="small-600">Buy</wui-text>
    </button>`;
  }
  onFocusChange(state3) {
    this.focused = state3;
  }
  onSelectToken() {
    EventsController.sendEvent({ type: "track", event: "CLICK_SELECT_TOKEN_TO_SWAP" });
    RouterController.push("SwapSelectToken", {
      target: this.target
    });
  }
  onBuyToken() {
    RouterController.push("OnRampProviders");
  }
};
W3mSwapInput.styles = [styles_default44];
__decorate68([
  property()
], W3mSwapInput.prototype, "focused", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "balance", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "value", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "price", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "marketValue", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "disabled", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "target", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "token", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "onSetAmount", void 0);
__decorate68([
  property()
], W3mSwapInput.prototype, "onSetMaxValue", void 0);
W3mSwapInput = __decorate68([
  customElement("w3m-swap-input")
], W3mSwapInput);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-swap-input-skeleton/styles.js
var styles_default45 = css`
  :host {
    width: 100%;
  }

  :host > wui-flex {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    border-radius: var(--wui-border-radius-s);
    padding: var(--wui-spacing-xl);
    padding-right: var(--wui-spacing-s);
    background-color: var(--wui-color-gray-glass-002);
    box-shadow: inset 0px 0px 0px 1px var(--wui-color-gray-glass-002);
    width: 100%;
    height: 100px;
    box-sizing: border-box;
    position: relative;
  }

  wui-shimmer.market-value {
    opacity: 0;
  }

  :host > wui-flex > svg.input_mask {
    position: absolute;
    inset: 0;
    z-index: 5;
  }

  :host wui-flex .input_mask__border,
  :host wui-flex .input_mask__background {
    transition: fill var(--wui-duration-md) var(--wui-ease-out-power-1);
    will-change: fill;
  }

  :host wui-flex .input_mask__border {
    fill: var(--wui-color-gray-glass-020);
  }

  :host wui-flex .input_mask__background {
    fill: var(--wui-color-gray-glass-002);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-swap-input-skeleton/index.js
var __decorate69 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSwapInputSkeleton = class W3mSwapInputSkeleton2 extends LitElement {
  constructor() {
    super(...arguments);
    this.target = "sourceToken";
  }
  render() {
    return html`
      <wui-flex class justifyContent="space-between">
        <wui-flex
          flex="1"
          flexDirection="column"
          alignItems="flex-start"
          justifyContent="center"
          class="swap-input"
          gap="xxs"
        >
          <wui-shimmer width="80px" height="40px" borderRadius="xxs" variant="light"></wui-shimmer>
        </wui-flex>
        ${this.templateTokenSelectButton()}
      </wui-flex>
    `;
  }
  templateTokenSelectButton() {
    return html`
      <wui-flex
        class="swap-token-button"
        flexDirection="column"
        alignItems="flex-end"
        justifyContent="center"
        gap="xxs"
      >
        <wui-shimmer width="80px" height="40px" borderRadius="3xl" variant="light"></wui-shimmer>
      </wui-flex>
    `;
  }
};
W3mSwapInputSkeleton.styles = [styles_default45];
__decorate69([
  property()
], W3mSwapInputSkeleton.prototype, "target", void 0);
W3mSwapInputSkeleton = __decorate69([
  customElement("w3m-swap-input-skeleton")
], W3mSwapInputSkeleton);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-header/styles.js
var styles_default46 = css`
  :host {
    height: 64px;
  }

  wui-text {
    text-transform: capitalize;
  }

  wui-flex.w3m-header-title {
    transform: translateY(0);
    opacity: 1;
  }

  wui-flex.w3m-header-title[view-direction='prev'] {
    animation:
      slide-down-out 120ms forwards var(--wui-ease-out-power-2),
      slide-down-in 120ms forwards var(--wui-ease-out-power-2);
    animation-delay: 0ms, 200ms;
  }

  wui-flex.w3m-header-title[view-direction='next'] {
    animation:
      slide-up-out 120ms forwards var(--wui-ease-out-power-2),
      slide-up-in 120ms forwards var(--wui-ease-out-power-2);
    animation-delay: 0ms, 200ms;
  }

  wui-icon-link[data-hidden='true'] {
    opacity: 0 !important;
    pointer-events: none;
  }

  @keyframes slide-up-out {
    from {
      transform: translateY(0px);
      opacity: 1;
    }
    to {
      transform: translateY(3px);
      opacity: 0;
    }
  }

  @keyframes slide-up-in {
    from {
      transform: translateY(-3px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }

  @keyframes slide-down-out {
    from {
      transform: translateY(0px);
      opacity: 1;
    }
    to {
      transform: translateY(-3px);
      opacity: 0;
    }
  }

  @keyframes slide-down-in {
    from {
      transform: translateY(3px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-header/index.js
var __decorate70 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var BETA_SCREENS = ["Swap", "SwapSelectToken", "SwapPreview"];
function headings() {
  var _a, _b, _c, _d, _e4, _f, _g;
  const connectorName = (_b = (_a = RouterController.state.data) == null ? void 0 : _a.connector) == null ? void 0 : _b.name;
  const walletName = (_d = (_c = RouterController.state.data) == null ? void 0 : _c.wallet) == null ? void 0 : _d.name;
  const networkName = (_f = (_e4 = RouterController.state.data) == null ? void 0 : _e4.network) == null ? void 0 : _f.name;
  const name = walletName ?? connectorName;
  const connectors = ConnectorController.getConnectors();
  const isEmail = connectors.length === 1 && ((_g = connectors[0]) == null ? void 0 : _g.id) === "w3m-email";
  return {
    Connect: `Connect ${isEmail ? "Email" : ""} Wallet`,
    ChooseAccountName: void 0,
    Account: void 0,
    AccountSettings: void 0,
    AllWallets: "All Wallets",
    ApproveTransaction: "Approve Transaction",
    BuyInProgress: "Buy",
    ConnectingExternal: name ?? "Connect Wallet",
    ConnectingWalletConnect: name ?? "WalletConnect",
    ConnectingSiwe: "Sign In",
    Convert: "Convert",
    ConvertSelectToken: "Select token",
    ConvertPreview: "Preview convert",
    Downloads: name ? `Get ${name}` : "Downloads",
    EmailVerifyOtp: "Confirm Email",
    EmailVerifyDevice: "Register Device",
    GetWallet: "Get a wallet",
    Networks: "Choose Network",
    OnRampProviders: "Choose Provider",
    OnRampActivity: "Activity",
    OnRampTokenSelect: "Select Token",
    OnRampFiatSelect: "Select Currency",
    Profile: void 0,
    SelectAddresses: "Select accounts",
    SwitchNetwork: networkName ?? "Switch Network",
    SwitchAddress: "Switch Address",
    Transactions: "Activity",
    UnsupportedChain: "Switch Network",
    UpgradeEmailWallet: "Upgrade your Wallet",
    UpgradeToSmartAccount: void 0,
    UpdateEmailWallet: "Edit Email",
    UpdateEmailPrimaryOtp: "Confirm Current Email",
    UpdateEmailSecondaryOtp: "Confirm New Email",
    WhatIsABuy: "What is Buy?",
    RegisterAccountName: "Choose name",
    RegisterAccountNameSuccess: "",
    WalletReceive: "Receive",
    WalletCompatibleNetworks: "Compatible Networks",
    Swap: "Swap",
    SwapSelectToken: "Select token",
    SwapPreview: "Preview swap",
    WalletSend: "Send",
    WalletSendPreview: "Review send",
    WalletSendSelectToken: "Select Token",
    WhatIsANetwork: "What is a network?",
    WhatIsAWallet: "What is a wallet?",
    ConnectWallets: "Connect wallet",
    ConnectSocials: "All socials",
    ConnectingSocial: AccountController.state.socialProvider ? AccountController.state.socialProvider : "Connect Social",
    ConnectingMultiChain: "Select chain",
    ConnectingFarcaster: "Farcaster",
    SwitchActiveChain: "Switch chain"
  };
}
var W3mHeader = class W3mHeader2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.heading = headings()[RouterController.state.view];
    this.network = ChainController.state.activeCaipNetwork;
    this.buffering = false;
    this.showBack = false;
    this.isSiweEnabled = OptionsController.state.isSiweEnabled;
    this.prevHistoryLength = 1;
    this.view = RouterController.state.view;
    this.viewDirection = "";
    this.headerText = headings()[RouterController.state.view];
    this.unsubscribe.push(RouterController.subscribeKey("view", (val) => {
      setTimeout(() => {
        this.view = val;
        this.headerText = headings()[val];
      }, ConstantsUtil4.ANIMATION_DURATIONS.HeaderText);
      this.onViewChange();
      this.onHistoryChange();
    }), ConnectionController.subscribeKey("buffering", (val) => this.buffering = val), ChainController.subscribeKey("activeCaipNetwork", (val) => this.network = val));
  }
  disconnectCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`
      <wui-flex .padding=${this.getPadding()} justifyContent="space-between" alignItems="center">
        ${this.dynamicButtonTemplate()} ${this.titleTemplate()} ${this.closeButtonTemplate()}
      </wui-flex>
    `;
  }
  onWalletHelp() {
    EventsController.sendEvent({ type: "track", event: "CLICK_WALLET_HELP" });
    RouterController.push("WhatIsAWallet");
  }
  async onClose() {
    if (this.isSiweEnabled) {
      const { SIWEController } = await import("./exports-S4LPZMO3.js");
      const isApproveSignScreen = RouterController.state.view === "ApproveTransaction";
      const isUnauthenticated = SIWEController.state.status !== "success";
      if (isUnauthenticated && isApproveSignScreen) {
        RouterController.popTransactionStack(true);
      } else {
        ModalController.close();
      }
    } else {
      ModalController.close();
    }
  }
  closeButtonTemplate() {
    const isSiweSignScreen = RouterController.state.view === "ConnectingSiwe";
    if (this.isSiweEnabled && isSiweSignScreen) {
      return html`<div style="width:40px" />`;
    }
    return html`
      <wui-icon-link
        ?disabled=${this.buffering}
        icon="close"
        @click=${this.onClose.bind(this)}
        data-testid="w3m-header-close"
      ></wui-icon-link>
    `;
  }
  titleTemplate() {
    const isBeta = BETA_SCREENS.includes(this.view);
    return html`
      <wui-flex
        view-direction="${this.viewDirection}"
        class="w3m-header-title"
        alignItems="center"
        gap="xs"
      >
        <wui-text variant="paragraph-700" color="fg-100">${this.headerText}</wui-text>
        ${isBeta ? html`<wui-tag variant="main">Beta</wui-tag>` : null}
      </wui-flex>
    `;
  }
  dynamicButtonTemplate() {
    var _a;
    const { view } = RouterController.state;
    const isConnectHelp = view === "Connect";
    const isApproveTransaction = view === "ApproveTransaction";
    const isUpgradeToSmartAccounts = view === "UpgradeToSmartAccount";
    const isConnectingSIWEView = view === "ConnectingSiwe";
    const isAccountView = view === "Account";
    const shouldHideBack = isApproveTransaction || isUpgradeToSmartAccounts || isConnectingSIWEView;
    if (isAccountView) {
      return html`<wui-select
        id="dynamic"
        data-testid="w3m-account-select-network"
        active-network=${(_a = this.network) == null ? void 0 : _a.name}
        @click=${this.onNetworks.bind(this)}
        imageSrc=${ifDefined(AssetUtil.getNetworkImage(this.network))}
      ></wui-select>`;
    }
    if (this.showBack && !shouldHideBack) {
      return html`<wui-icon-link
        id="dynamic"
        icon="chevronLeft"
        ?disabled=${this.buffering}
        @click=${this.onGoBack.bind(this)}
      ></wui-icon-link>`;
    }
    return html`<wui-icon-link
      data-hidden=${!isConnectHelp}
      id="dynamic"
      icon="helpCircle"
      @click=${this.onWalletHelp.bind(this)}
    ></wui-icon-link>`;
  }
  onNetworks() {
    if (this.isAllowedNetworkSwitch()) {
      EventsController.sendEvent({ type: "track", event: "CLICK_NETWORKS" });
      RouterController.push("Networks");
    }
  }
  isAllowedNetworkSwitch() {
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const isMultiNetwork = requestedCaipNetworks ? requestedCaipNetworks.length > 1 : false;
    const isValidNetwork = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.find(({ id }) => {
      var _a;
      return id === ((_a = this.network) == null ? void 0 : _a.id);
    });
    return isMultiNetwork || !isValidNetwork;
  }
  getPadding() {
    if (this.heading) {
      return ["l", "2l", "l", "2l"];
    }
    return ["0", "2l", "0", "2l"];
  }
  onViewChange() {
    const { history } = RouterController.state;
    let direction = ConstantsUtil4.VIEW_DIRECTION.Next;
    if (history.length < this.prevHistoryLength) {
      direction = ConstantsUtil4.VIEW_DIRECTION.Prev;
    }
    this.prevHistoryLength = history.length;
    this.viewDirection = direction;
  }
  async onHistoryChange() {
    var _a;
    const { history } = RouterController.state;
    const buttonEl = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector("#dynamic");
    if (history.length > 1 && !this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = true;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    } else if (history.length <= 1 && this.showBack && buttonEl) {
      await buttonEl.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      }).finished;
      this.showBack = false;
      buttonEl.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: 200,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
  onGoBack() {
    RouterController.goBack();
  }
};
W3mHeader.styles = styles_default46;
__decorate70([
  state()
], W3mHeader.prototype, "heading", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "network", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "buffering", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "showBack", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "isSiweEnabled", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "prevHistoryLength", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "view", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "viewDirection", void 0);
__decorate70([
  state()
], W3mHeader.prototype, "headerText", void 0);
W3mHeader = __decorate70([
  customElement("w3m-header")
], W3mHeader);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-help-widget/index.js
var __decorate71 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mHelpWidget = class W3mHelpWidget2 extends LitElement {
  constructor() {
    super(...arguments);
    this.data = [];
  }
  render() {
    return html`
      <wui-flex flexDirection="column" alignItems="center" gap="l">
        ${this.data.map((item) => html`
            <wui-flex flexDirection="column" alignItems="center" gap="xl">
              <wui-flex flexDirection="row" justifyContent="center" gap="1xs">
                ${item.images.map((image) => html`<wui-visual name=${image}></wui-visual>`)}
              </wui-flex>
            </wui-flex>
            <wui-flex flexDirection="column" alignItems="center" gap="xxs">
              <wui-text variant="paragraph-500" color="fg-100" align="center">
                ${item.title}
              </wui-text>
              <wui-text variant="small-500" color="fg-200" align="center">${item.text}</wui-text>
            </wui-flex>
          `)}
      </wui-flex>
    `;
  }
};
__decorate71([
  property({ type: Array })
], W3mHelpWidget.prototype, "data", void 0);
W3mHelpWidget = __decorate71([
  customElement("w3m-help-widget")
], W3mHelpWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-activity-item/styles.js
var styles_default47 = css`
  :host {
    width: 100%;
  }

  :host > wui-flex {
    width: 100%;
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xs);
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--wui-spacing-s);
  }

  :host > wui-flex:hover {
    background-color: var(--wui-color-gray-glass-002);
  }

  .purchase-image-container {
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    width: var(--wui-icon-box-size-lg);
    height: var(--wui-icon-box-size-lg);
  }

  .purchase-image-container wui-image {
    width: 100%;
    height: 100%;
    position: relative;
    border-radius: calc(var(--wui-icon-box-size-lg) / 2);
  }

  .purchase-image-container wui-image::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-icon-box-size-lg) / 2);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  .purchase-image-container wui-icon-box {
    position: absolute;
    right: 0;
    bottom: 0;
    transform: translate(20%, 20%);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-activity-item/index.js
var __decorate72 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mOnRampActivityItem = class W3mOnRampActivityItem2 extends LitElement {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.color = "inherit";
    this.label = "Bought";
    this.purchaseValue = "";
    this.purchaseCurrency = "";
    this.date = "";
    this.completed = false;
    this.inProgress = false;
    this.failed = false;
    this.onClick = null;
    this.symbol = "";
  }
  firstUpdated() {
    if (!this.icon) {
      this.fetchTokenImage();
    }
  }
  render() {
    return html`
      <wui-flex>
        ${this.imageTemplate()}
        <wui-flex flexDirection="column" gap="4xs" flexGrow="1">
          <wui-flex gap="xxs" alignItems="center" justifyContent="flex-start">
            ${this.statusIconTemplate()}
            <wui-text variant="paragraph-500" color="fg-100"> ${this.label}</wui-text>
          </wui-flex>
          <wui-text variant="small-400" color="fg-200">
            + ${this.purchaseValue} ${this.purchaseCurrency}
          </wui-text>
        </wui-flex>
        ${this.inProgress ? html`<wui-loading-spinner color="fg-200" size="md"></wui-loading-spinner>` : html`<wui-text variant="micro-700" color="fg-300"><span>${this.date}</span></wui-text>`}
      </wui-flex>
    `;
  }
  async fetchTokenImage() {
    await ApiController._fetchTokenImage(this.purchaseCurrency);
  }
  statusIconTemplate() {
    if (this.inProgress) {
      return null;
    }
    return this.completed ? this.boughtIconTemplate() : this.errorIconTemplate();
  }
  errorIconTemplate() {
    return html`<wui-icon-box
      size="xxs"
      iconColor="error-100"
      backgroundColor="error-100"
      background="opaque"
      icon="close"
      borderColor="wui-color-bg-125"
    ></wui-icon-box>`;
  }
  imageTemplate() {
    const icon = this.icon || `https://avatar.vercel.sh/andrew.svg?size=50&text=${this.symbol}`;
    return html`<wui-flex class="purchase-image-container">
      <wui-image src=${icon}></wui-image>
    </wui-flex>`;
  }
  boughtIconTemplate() {
    return html`<wui-icon-box
      size="xxs"
      iconColor="success-100"
      backgroundColor="success-100"
      background="opaque"
      icon="arrowBottom"
      borderColor="wui-color-bg-125"
    ></wui-icon-box>`;
  }
};
W3mOnRampActivityItem.styles = [styles_default47];
__decorate72([
  property({ type: Boolean })
], W3mOnRampActivityItem.prototype, "disabled", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "color", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "label", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "purchaseValue", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "purchaseCurrency", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "date", void 0);
__decorate72([
  property({ type: Boolean })
], W3mOnRampActivityItem.prototype, "completed", void 0);
__decorate72([
  property({ type: Boolean })
], W3mOnRampActivityItem.prototype, "inProgress", void 0);
__decorate72([
  property({ type: Boolean })
], W3mOnRampActivityItem.prototype, "failed", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "onClick", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "symbol", void 0);
__decorate72([
  property()
], W3mOnRampActivityItem.prototype, "icon", void 0);
W3mOnRampActivityItem = __decorate72([
  customElement("w3m-onramp-activity-item")
], W3mOnRampActivityItem);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-input/styles.js
var styles_default48 = css`
  :host {
    width: 100%;
  }

  wui-loading-spinner {
    position: absolute;
    top: 50%;
    right: 20px;
    transform: translateY(-50%);
  }

  .currency-container {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    right: var(--wui-spacing-1xs);
    height: 40px;
    padding: var(--wui-spacing-xs) var(--wui-spacing-1xs) var(--wui-spacing-xs)
      var(--wui-spacing-xs);
    min-width: 95px;
    border-radius: var(--FULL, 1000px);
    border: 1px solid var(--wui-color-gray-glass-002);
    background: var(--wui-color-gray-glass-002);
    cursor: pointer;
  }

  .currency-container > wui-image {
    height: 24px;
    width: 24px;
    border-radius: 50%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-input/index.js
var __decorate73 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mInputCurrency = class W3mInputCurrency2 extends LitElement {
  constructor() {
    var _a;
    super();
    this.unsubscribe = [];
    this.type = "Token";
    this.value = 0;
    this.currencies = [];
    this.selectedCurrency = (_a = this.currencies) == null ? void 0 : _a[0];
    this.currencyImages = AssetController.state.currencyImages;
    this.tokenImages = AssetController.state.tokenImages;
    this.unsubscribe.push(OnRampController.subscribeKey("purchaseCurrency", (val) => {
      if (!val || this.type === "Fiat") {
        return;
      }
      this.selectedCurrency = this.formatPurchaseCurrency(val);
    }), OnRampController.subscribeKey("paymentCurrency", (val) => {
      if (!val || this.type === "Token") {
        return;
      }
      this.selectedCurrency = this.formatPaymentCurrency(val);
    }), OnRampController.subscribe((val) => {
      if (this.type === "Fiat") {
        this.currencies = val.purchaseCurrencies.map(this.formatPurchaseCurrency);
      } else {
        this.currencies = val.paymentCurrencies.map(this.formatPaymentCurrency);
      }
    }), AssetController.subscribe((val) => {
      this.currencyImages = { ...val.currencyImages };
      this.tokenImages = { ...val.tokenImages };
    }));
  }
  firstUpdated() {
    OnRampController.getAvailableCurrencies();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a;
    const symbol = ((_a = this.selectedCurrency) == null ? void 0 : _a.symbol) || "";
    const image = this.currencyImages[symbol] || this.tokenImages[symbol];
    return html`<wui-input-text type="number" size="lg" value=${this.value}>
      ${this.selectedCurrency ? html` <wui-flex
            class="currency-container"
            justifyContent="space-between"
            alignItems="center"
            gap="xxs"
            @click=${() => ModalController.open({ view: `OnRamp${this.type}Select` })}
          >
            <wui-image src=${ifDefined(image)}></wui-image>
            <wui-text color="fg-100">${this.selectedCurrency.symbol}</wui-text>
          </wui-flex>` : html`<wui-loading-spinner></wui-loading-spinner>`}
    </wui-input-text>`;
  }
  formatPaymentCurrency(currency) {
    return {
      name: currency.id,
      symbol: currency.id
    };
  }
  formatPurchaseCurrency(currency) {
    return {
      name: currency.name,
      symbol: currency.symbol
    };
  }
};
W3mInputCurrency.styles = styles_default48;
__decorate73([
  property({ type: String })
], W3mInputCurrency.prototype, "type", void 0);
__decorate73([
  property({ type: Number })
], W3mInputCurrency.prototype, "value", void 0);
__decorate73([
  state()
], W3mInputCurrency.prototype, "currencies", void 0);
__decorate73([
  state()
], W3mInputCurrency.prototype, "selectedCurrency", void 0);
__decorate73([
  state()
], W3mInputCurrency.prototype, "currencyImages", void 0);
__decorate73([
  state()
], W3mInputCurrency.prototype, "tokenImages", void 0);
W3mInputCurrency = __decorate73([
  customElement("w3m-onramp-input")
], W3mInputCurrency);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-provider-item/styles.js
var styles_default49 = css`
  button {
    padding: var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xs);
    border: none;
    outline: none;
    background-color: var(--wui-color-gray-glass-002);
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: var(--wui-spacing-s);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color;
  }

  button:hover {
    background-color: var(--wui-color-gray-glass-005);
  }

  .provider-image {
    width: var(--wui-spacing-3xl);
    min-width: var(--wui-spacing-3xl);
    height: var(--wui-spacing-3xl);
    border-radius: calc(var(--wui-border-radius-xs) - calc(var(--wui-spacing-s) / 2));
    position: relative;
    overflow: hidden;
  }

  .provider-image::after {
    content: '';
    display: block;
    width: 100%;
    height: 100%;
    position: absolute;
    inset: 0;
    border-radius: calc(var(--wui-border-radius-xs) - calc(var(--wui-spacing-s) / 2));
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-005);
  }

  .network-icon {
    width: var(--wui-spacing-m);
    height: var(--wui-spacing-m);
    border-radius: calc(var(--wui-spacing-m) / 2);
    overflow: hidden;
    box-shadow:
      0 0 0 3px var(--wui-color-gray-glass-002),
      0 0 0 3px var(--wui-color-modal-bg);
    transition: box-shadow var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: box-shadow;
  }

  button:hover .network-icon {
    box-shadow:
      0 0 0 3px var(--wui-color-gray-glass-005),
      0 0 0 3px var(--wui-color-modal-bg);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-provider-item/index.js
var __decorate74 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mOnRampProviderItem = class W3mOnRampProviderItem2 extends LitElement {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.color = "inherit";
    this.label = "";
    this.feeRange = "";
    this.loading = false;
    this.onClick = null;
  }
  render() {
    return html`
      <button ?disabled=${this.disabled} ontouchstart>
        <wui-visual name=${ifDefined(this.name)} class="provider-image"></wui-visual>
        <wui-flex flexDirection="column" gap="4xs">
          <wui-text variant="paragraph-500" color="fg-100">${this.label}</wui-text>
          <wui-flex alignItems="center" justifyContent="flex-start" gap="l">
            <wui-text variant="tiny-500" color="fg-100">
              <wui-text variant="tiny-400" color="fg-200">Fees</wui-text>
              ${this.feeRange}
            </wui-text>
            <wui-flex gap="xxs">
              <wui-icon name="bank" size="xs" color="fg-150"></wui-icon>
              <wui-icon name="card" size="xs" color="fg-150"></wui-icon>
            </wui-flex>
            ${this.networksTemplate()}
          </wui-flex>
        </wui-flex>
        ${this.loading ? html`<wui-loading-spinner color="fg-200" size="md"></wui-loading-spinner>` : html`<wui-icon name="chevronRight" color="fg-200" size="sm"></wui-icon>`}
      </button>
    `;
  }
  networksTemplate() {
    var _a;
    const requestedCaipNetworks = NetworkController.getRequestedCaipNetworks();
    const slicedNetworks = (_a = requestedCaipNetworks == null ? void 0 : requestedCaipNetworks.filter((network) => network == null ? void 0 : network.imageId)) == null ? void 0 : _a.slice(0, 5);
    return html`
      <wui-flex class="networks">
        ${slicedNetworks == null ? void 0 : slicedNetworks.map((network) => html`
            <wui-flex class="network-icon">
              <wui-image src=${ifDefined(AssetUtil.getNetworkImage(network))}></wui-image>
            </wui-flex>
          `)}
      </wui-flex>
    `;
  }
};
W3mOnRampProviderItem.styles = [styles_default49];
__decorate74([
  property({ type: Boolean })
], W3mOnRampProviderItem.prototype, "disabled", void 0);
__decorate74([
  property()
], W3mOnRampProviderItem.prototype, "color", void 0);
__decorate74([
  property()
], W3mOnRampProviderItem.prototype, "name", void 0);
__decorate74([
  property()
], W3mOnRampProviderItem.prototype, "label", void 0);
__decorate74([
  property()
], W3mOnRampProviderItem.prototype, "feeRange", void 0);
__decorate74([
  property({ type: Boolean })
], W3mOnRampProviderItem.prototype, "loading", void 0);
__decorate74([
  property()
], W3mOnRampProviderItem.prototype, "onClick", void 0);
W3mOnRampProviderItem = __decorate74([
  customElement("w3m-onramp-provider-item")
], W3mOnRampProviderItem);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-legal-footer/styles.js
var styles_default50 = css`
  wui-flex {
    background-color: var(--wui-color-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-legal-footer/index.js
var __decorate75 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mLegalFooter = class W3mLegalFooter2 extends LitElement {
  render() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    if (!termsConditionsUrl && !privacyPolicyUrl) {
      return null;
    }
    return html`
      <wui-flex .padding=${["m", "s", "s", "s"]} justifyContent="center">
        <wui-text color="fg-250" variant="small-400" align="center">
          By connecting your wallet, you agree to our <br />
          ${this.termsTemplate()} ${this.andTemplate()} ${this.privacyTemplate()}
        </wui-text>
      </wui-flex>
    `;
  }
  andTemplate() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    return termsConditionsUrl && privacyPolicyUrl ? "and" : "";
  }
  termsTemplate() {
    const { termsConditionsUrl } = OptionsController.state;
    if (!termsConditionsUrl) {
      return null;
    }
    return html`<a href=${termsConditionsUrl}>Terms of Service</a>`;
  }
  privacyTemplate() {
    const { privacyPolicyUrl } = OptionsController.state;
    if (!privacyPolicyUrl) {
      return null;
    }
    return html`<a href=${privacyPolicyUrl}>Privacy Policy</a>`;
  }
};
W3mLegalFooter.styles = [styles_default50];
W3mLegalFooter = __decorate75([
  customElement("w3m-legal-footer")
], W3mLegalFooter);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-mobile-download-links/styles.js
var styles_default51 = css`
  :host {
    display: block;
    padding: 0 var(--wui-spacing-xl) var(--wui-spacing-xl);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-mobile-download-links/index.js
var __decorate76 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mMobileDownloadLinks = class W3mMobileDownloadLinks2 extends LitElement {
  constructor() {
    super(...arguments);
    this.wallet = void 0;
  }
  render() {
    if (!this.wallet) {
      this.style.display = "none";
      return null;
    }
    const { name, app_store, play_store, chrome_store, homepage } = this.wallet;
    const isMobile = CoreHelperUtil.isMobile();
    const isIos = CoreHelperUtil.isIos();
    const isAndroid = CoreHelperUtil.isAndroid();
    const isMultiple = [app_store, play_store, homepage, chrome_store].filter(Boolean).length > 1;
    const shortName = UiHelperUtil.getTruncateString({
      string: name,
      charsStart: 12,
      charsEnd: 0,
      truncate: "end"
    });
    if (isMultiple && !isMobile) {
      return html`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${() => RouterController.push("Downloads", { wallet: this.wallet })}
        ></wui-cta-button>
      `;
    }
    if (!isMultiple && homepage) {
      return html`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onHomePage.bind(this)}
        ></wui-cta-button>
      `;
    }
    if (app_store && isIos) {
      return html`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onAppStore.bind(this)}
        ></wui-cta-button>
      `;
    }
    if (play_store && isAndroid) {
      return html`
        <wui-cta-button
          label=${`Don't have ${shortName}?`}
          buttonLabel="Get"
          @click=${this.onPlayStore.bind(this)}
        ></wui-cta-button>
      `;
    }
    this.style.display = "none";
    return null;
  }
  onAppStore() {
    var _a;
    if ((_a = this.wallet) == null ? void 0 : _a.app_store) {
      CoreHelperUtil.openHref(this.wallet.app_store, "_blank");
    }
  }
  onPlayStore() {
    var _a;
    if ((_a = this.wallet) == null ? void 0 : _a.play_store) {
      CoreHelperUtil.openHref(this.wallet.play_store, "_blank");
    }
  }
  onHomePage() {
    var _a;
    if ((_a = this.wallet) == null ? void 0 : _a.homepage) {
      CoreHelperUtil.openHref(this.wallet.homepage, "_blank");
    }
  }
};
W3mMobileDownloadLinks.styles = [styles_default51];
__decorate76([
  property({ type: Object })
], W3mMobileDownloadLinks.prototype, "wallet", void 0);
W3mMobileDownloadLinks = __decorate76([
  customElement("w3m-mobile-download-links")
], W3mMobileDownloadLinks);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-providers-footer/styles.js
var styles_default52 = css`
  wui-flex {
    border-top: 1px solid var(--wui-color-gray-glass-005);
  }

  a {
    text-decoration: none;
    color: var(--wui-color-fg-175);
    font-weight: 500;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-3xs);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-onramp-providers-footer/index.js
var __decorate77 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mOnRampProvidersFooter = class W3mOnRampProvidersFooter2 extends LitElement {
  render() {
    const { termsConditionsUrl, privacyPolicyUrl } = OptionsController.state;
    if (!termsConditionsUrl && !privacyPolicyUrl) {
      return null;
    }
    return html`
      <wui-flex
        .padding=${["m", "s", "s", "s"]}
        flexDirection="column"
        alignItems="center"
        justifyContent="center"
        gap="s"
      >
        <wui-text color="fg-250" variant="small-400" align="center">
          We work with the best providers to give you the lowest fees and best support. More options
          coming soon!
        </wui-text>

        ${this.howDoesItWorkTemplate()}
      </wui-flex>
    `;
  }
  howDoesItWorkTemplate() {
    return html` <wui-link @click=${this.onWhatIsBuy.bind(this)}>
      <wui-icon size="xs" color="accent-100" slot="iconLeft" name="helpCircle"></wui-icon>
      How does it work?
    </wui-link>`;
  }
  onWhatIsBuy() {
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_WHAT_IS_A_BUY",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("WhatIsABuy");
  }
};
W3mOnRampProvidersFooter.styles = [styles_default52];
W3mOnRampProvidersFooter = __decorate77([
  customElement("w3m-onramp-providers-footer")
], W3mOnRampProvidersFooter);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-snackbar/styles.js
var styles_default53 = css`
  :host {
    display: block;
    position: absolute;
    opacity: 0;
    pointer-events: none;
    top: 11px;
    left: 50%;
    width: max-content;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-snackbar/index.js
var __decorate78 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var presets = {
  loading: void 0,
  success: {
    backgroundColor: "success-100",
    iconColor: "success-100",
    icon: "checkmark"
  },
  error: {
    backgroundColor: "error-100",
    iconColor: "error-100",
    icon: "close"
  }
};
var W3mSnackBar = class W3mSnackBar2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.timeout = void 0;
    this.open = SnackController.state.open;
    this.unsubscribe.push(SnackController.subscribeKey("open", (val) => {
      this.open = val;
      this.onOpen();
    }));
  }
  disconnectedCallback() {
    clearTimeout(this.timeout);
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { message, variant } = SnackController.state;
    const preset = presets[variant];
    return html`
      <wui-snackbar
        message=${message}
        backgroundColor=${preset == null ? void 0 : preset.backgroundColor}
        iconColor=${preset == null ? void 0 : preset.iconColor}
        icon=${preset == null ? void 0 : preset.icon}
        .loading=${variant === "loading"}
      ></wui-snackbar>
    `;
  }
  onOpen() {
    clearTimeout(this.timeout);
    if (this.open) {
      this.animate([
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" },
        { opacity: 1, transform: "translateX(-50%) scale(1)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
      this.timeout = setTimeout(() => SnackController.hide(), 2500);
    } else {
      this.animate([
        { opacity: 1, transform: "translateX(-50%) scale(1)" },
        { opacity: 0, transform: "translateX(-50%) scale(0.85)" }
      ], {
        duration: 150,
        fill: "forwards",
        easing: "ease"
      });
    }
  }
};
W3mSnackBar.styles = styles_default53;
__decorate78([
  state()
], W3mSnackBar.prototype, "open", void 0);
W3mSnackBar = __decorate78([
  customElement("w3m-snackbar")
], W3mSnackBar);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-email-login-widget/styles.js
var styles_default54 = css`
  wui-separator {
    margin: var(--wui-spacing-s) calc(var(--wui-spacing-s) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }

  wui-email-input {
    width: 100%;
  }

  form {
    width: 100%;
    display: block;
    position: relative;
  }

  wui-icon-link,
  wui-loading-spinner {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
  }

  wui-icon-link {
    right: var(--wui-spacing-xs);
  }

  wui-loading-spinner {
    right: var(--wui-spacing-m);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-email-login-widget/index.js
var __decorate79 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mEmailLoginWidget = class W3mEmailLoginWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.formRef = createRef();
    this.connectors = ConnectorController.state.connectors;
    this.authConnector = this.connectors.find((c5) => c5.type === "AUTH");
    this.email = "";
    this.loading = false;
    this.error = "";
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => {
      this.connectors = val;
      this.authConnector = val.find((c5) => c5.type === "AUTH");
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  firstUpdated() {
    var _a;
    (_a = this.formRef.value) == null ? void 0 : _a.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.onSubmitEmail(event);
      }
    });
  }
  render() {
    var _a, _b;
    const socials = (_a = OptionsController.state.features) == null ? void 0 : _a.socials;
    const email = (_b = OptionsController.state.features) == null ? void 0 : _b.email;
    const multipleConnectors = this.connectors.length > 1;
    const enableWallets = OptionsController.state.enableWallets;
    if (!this.authConnector || !email) {
      return null;
    }
    return html`
      <form ${ref2(this.formRef)} @submit=${this.onSubmitEmail.bind(this)}>
        <wui-email-input
          @focus=${this.onFocusEvent.bind(this)}
          .disabled=${this.loading}
          @inputChange=${this.onEmailInputChange.bind(this)}
          .errorMessage=${this.error}
        >
        </wui-email-input>

        ${this.submitButtonTemplate()}${this.loadingTemplate()}
        <input type="submit" hidden />
      </form>

      ${socials || !multipleConnectors || !enableWallets ? null : html`<wui-flex .padding=${["xxs", "0", "0", "0"]}>
            <wui-separator text="or"></wui-separator>
          </wui-flex>`}
    `;
  }
  submitButtonTemplate() {
    const showSubmit = !this.loading && this.email.length > 3;
    return showSubmit ? html`
          <wui-icon-link
            size="sm"
            icon="chevronRight"
            iconcolor="accent-100"
            @click=${this.onSubmitEmail.bind(this)}
          >
          </wui-icon-link>
        ` : null;
  }
  loadingTemplate() {
    return this.loading ? html`<wui-loading-spinner size="md" color="accent-100"></wui-loading-spinner>` : null;
  }
  onEmailInputChange(event) {
    this.email = event.detail.trim();
    this.error = "";
  }
  async onSubmitEmail(event) {
    const availableChains = [ConstantsUtil.CHAIN.EVM, ConstantsUtil.CHAIN.SOLANA];
    const isAvailableChain = availableChains.find((chain) => chain === ChainController.state.activeChain);
    if (!isAvailableChain) {
      RouterController.push("SwitchActiveChain", {
        switchToChain: ConstantsUtil.CHAIN.EVM
      });
      return;
    }
    try {
      if (this.loading) {
        return;
      }
      this.loading = true;
      event.preventDefault();
      const authConnector = ConnectorController.getAuthConnector();
      if (!authConnector) {
        throw new Error("w3m-email-login-widget: Auth connector not found");
      }
      const { action } = await authConnector.provider.connectEmail({ email: this.email });
      EventsController.sendEvent({ type: "track", event: "EMAIL_SUBMITTED" });
      if (action === "VERIFY_OTP") {
        EventsController.sendEvent({ type: "track", event: "EMAIL_VERIFICATION_CODE_SENT" });
        RouterController.push("EmailVerifyOtp", { email: this.email });
      } else if (action === "VERIFY_DEVICE") {
        RouterController.push("EmailVerifyDevice", { email: this.email });
      }
    } catch (error) {
      const parsedError = CoreHelperUtil.parseError(error);
      if (parsedError == null ? void 0 : parsedError.includes("Invalid email")) {
        this.error = "Invalid email. Try again.";
      } else {
        SnackController.showError(error);
      }
    } finally {
      this.loading = false;
    }
  }
  onFocusEvent() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_LOGIN_SELECTED" });
  }
};
W3mEmailLoginWidget.styles = styles_default54;
__decorate79([
  state()
], W3mEmailLoginWidget.prototype, "connectors", void 0);
__decorate79([
  state()
], W3mEmailLoginWidget.prototype, "authConnector", void 0);
__decorate79([
  state()
], W3mEmailLoginWidget.prototype, "email", void 0);
__decorate79([
  state()
], W3mEmailLoginWidget.prototype, "loading", void 0);
__decorate79([
  state()
], W3mEmailLoginWidget.prototype, "error", void 0);
W3mEmailLoginWidget = __decorate79([
  customElement("w3m-email-login-widget")
], W3mEmailLoginWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-default-widget/styles.js
var styles_default55 = css`
  wui-flex {
    width: 100%;
  }

  :host > wui-flex:first-child {
    transform: translateY(calc(var(--wui-spacing-xxs) * -1));
  }

  wui-icon-link {
    margin-right: calc(var(--wui-icon-box-size-md) * -1);
  }

  wui-notice-card {
    margin-bottom: var(--wui-spacing-3xs);
  }

  wui-list-item > wui-text {
    flex: 1;
  }

  w3m-transactions-view {
    max-height: 200px;
  }

  .tab-content-container {
    height: 300px;
    overflow-y: auto;
    overflow-x: hidden;
    scrollbar-width: none;
  }

  .tab-content-container::-webkit-scrollbar {
    display: none;
  }

  .account-button {
    width: auto;
    border: none;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--wui-spacing-s);
    height: 48px;
    padding: var(--wui-spacing-xs);
    padding-right: var(--wui-spacing-s);
    box-shadow: inset 0 0 0 1px var(--wui-color-gray-glass-002);
    background-color: var(--wui-color-gray-glass-002);
    border-radius: 24px;
    transition: background-color 0.2s linear;
  }

  .account-button:hover {
    background-color: var(--wui-color-gray-glass-005);
  }

  .avatar-container {
    position: relative;
  }

  wui-avatar.avatar {
    width: 32px;
    height: 32px;
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  wui-avatar.network-avatar {
    width: 16px;
    height: 16px;
    position: absolute;
    left: 100%;
    top: 100%;
    transform: translate(-75%, -75%);
    box-shadow: 0 0 0 2px var(--wui-color-gray-glass-005);
  }

  .account-links {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .account-links wui-flex {
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    background: red;
    align-items: center;
    justify-content: center;
    height: 48px;
    padding: 10px;
    flex: 1 0 0;
    border-radius: var(--XS, 16px);
    border: 1px solid var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    background: var(--dark-accent-glass-010, rgba(71, 161, 255, 0.1));
    transition:
      background-color var(--wui-ease-out-power-1) var(--wui-duration-md),
      opacity var(--wui-ease-out-power-1) var(--wui-duration-md);
    will-change: background-color, opacity;
  }

  .account-links wui-flex:hover {
    background: var(--dark-accent-glass-015, rgba(71, 161, 255, 0.15));
  }

  .account-links wui-flex wui-icon {
    width: var(--S, 20px);
    height: var(--S, 20px);
  }

  .account-links wui-flex wui-icon svg path {
    stroke: #667dff;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-default-widget/index.js
var __decorate80 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountDefaultWidget = class W3mAccountDefaultWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.caipAddress = AccountController.state.caipAddress;
    this.address = CoreHelperUtil.getPlainAddress(AccountController.state.caipAddress);
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.disconnecting = false;
    this.balance = AccountController.state.balance;
    this.balanceSymbol = AccountController.state.balanceSymbol;
    this.features = OptionsController.state.features;
    this.unsubscribe.push(...[
      AccountController.subscribeKey("caipAddress", (val) => {
        this.address = CoreHelperUtil.getPlainAddress(val);
        this.caipAddress = val;
      }),
      AccountController.subscribeKey("balance", (val) => this.balance = val),
      AccountController.subscribeKey("balanceSymbol", (val) => this.balanceSymbol = val),
      AccountController.subscribeKey("profileName", (val) => this.profileName = val),
      AccountController.subscribeKey("profileImage", (val) => this.profileImage = val),
      OptionsController.subscribeKey("features", (val) => this.features = val)
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (!this.caipAddress) {
      throw new Error("w3m-account-view: No account provided");
    }
    return html`<wui-flex
        flexDirection="column"
        .padding=${["0", "xl", "m", "xl"]}
        alignItems="center"
        gap="l"
      >
        ${ChainController.state.activeChain === ConstantsUtil.CHAIN.EVM ? this.multiAccountTemplate() : this.singleAccountTemplate()}
        <wui-flex flexDirection="column" alignItems="center">
          <wui-text variant="paragraph-500" color="fg-200">
            ${CoreHelperUtil.formatBalance(this.balance, this.balanceSymbol)}
          </wui-text>
        </wui-flex>
        ${this.explorerBtnTemplate()}
      </wui-flex>

      <wui-flex flexDirection="column" gap="xs" .padding=${["0", "s", "s", "s"]}>
        ${this.authCardTemplate()} <w3m-account-auth-button></w3m-account-auth-button>
        ${this.onrampTemplate()} ${this.swapsTemplate()} ${this.activityTemplate()}
        <wui-list-item
          variant="icon"
          iconVariant="overlay"
          icon="disconnect"
          ?chevron=${false}
          .loading=${this.disconnecting}
          @click=${this.onDisconnect.bind(this)}
          data-testid="disconnect-button"
        >
          <wui-text variant="paragraph-500" color="fg-200">Disconnect</wui-text>
        </wui-list-item>
      </wui-flex>`;
  }
  onrampTemplate() {
    var _a;
    const onramp = (_a = this.features) == null ? void 0 : _a.onramp;
    if (!onramp) {
      return null;
    }
    return html`
      <wui-list-item
        data-testid="w3m-account-default-onramp-button"
        iconVariant="blue"
        icon="card"
        ?chevron=${true}
        @click=${this.handleClickPay.bind(this)}
      >
        <wui-text variant="paragraph-500" color="fg-100">Buy crypto</wui-text>
      </wui-list-item>
    `;
  }
  activityTemplate() {
    const isSolana = ChainController.state.activeChain === ConstantsUtil.CHAIN.SOLANA;
    return html` <wui-list-item
      iconVariant="blue"
      icon="clock"
      iconSize="sm"
      ?chevron=${!isSolana}
      ?disabled=${isSolana}
      @click=${this.onTransactions.bind(this)}
    >
      <wui-text variant="paragraph-500" color="fg-100" ?disabled=${isSolana}> Activity </wui-text>
      ${isSolana ? html`<wui-tag variant="main">Coming soon</wui-tag>` : ""}
    </wui-list-item>`;
  }
  swapsTemplate() {
    var _a;
    const swaps = (_a = this.features) == null ? void 0 : _a.swaps;
    const isSolana = ChainController.state.activeChain === ConstantsUtil.CHAIN.SOLANA;
    if (!swaps || isSolana) {
      return null;
    }
    return html`
      <wui-list-item
        iconVariant="blue"
        icon="recycleHorizontal"
        ?chevron=${true}
        @click=${this.handleClickSwap.bind(this)}
      >
        <wui-text variant="paragraph-500" color="fg-100">Swap</wui-text>
      </wui-list-item>
    `;
  }
  authCardTemplate() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    const { origin } = location;
    if (!authConnector || type !== "AUTH" || origin.includes(ConstantsUtil2.SECURE_SITE)) {
      return null;
    }
    return html`
      <wui-notice-card
        @click=${this.onGoToUpgradeView.bind(this)}
        label="Upgrade your wallet"
        description="Transition to a self-custodial wallet"
        icon="wallet"
        data-testid="w3m-wallet-upgrade-card"
      ></wui-notice-card>
    `;
  }
  handleSwitchAccountsView() {
    RouterController.push("SwitchAddress");
  }
  handleClickPay() {
    RouterController.push("OnRampProviders");
  }
  handleClickSwap() {
    RouterController.push("Swap");
  }
  explorerBtnTemplate() {
    const addressExplorerUrl = AccountController.state.addressExplorerUrl;
    if (!addressExplorerUrl) {
      return null;
    }
    return html`
      <wui-button size="md" variant="neutral" @click=${this.onExplorer.bind(this)}>
        <wui-icon size="sm" color="inherit" slot="iconLeft" name="compass"></wui-icon>
        Block Explorer
        <wui-icon size="sm" color="inherit" slot="iconRight" name="externalLink"></wui-icon>
      </wui-button>
    `;
  }
  singleAccountTemplate() {
    return html`
      <wui-avatar
        alt=${ifDefined(this.caipAddress)}
        address=${ifDefined(CoreHelperUtil.getPlainAddress(this.caipAddress))}
        imageSrc=${ifDefined(this.profileImage === null ? void 0 : this.profileImage)}
      ></wui-avatar>
      <wui-flex flexDirection="column" alignItems="center">
        <wui-flex gap="3xs" alignItems="center" justifyContent="center">
          <wui-text variant="large-600" color="fg-100">
            ${this.profileName ? UiHelperUtil.getTruncateString({
      string: this.profileName,
      charsStart: 20,
      charsEnd: 0,
      truncate: "end"
    }) : UiHelperUtil.getTruncateString({
      string: this.address || "",
      charsStart: 4,
      charsEnd: 4,
      truncate: "middle"
    })}
          </wui-text>
          <wui-icon-link
            size="md"
            icon="copy"
            iconColor="fg-200"
            @click=${this.onCopyAddress}
          ></wui-icon-link> </wui-flex
      ></wui-flex>
    `;
  }
  multiAccountTemplate() {
    var _a;
    if (!this.address) {
      throw new Error("w3m-account-view: No account provided");
    }
    const account = (_a = AccountController.state.allAccounts) == null ? void 0 : _a.find((acc) => acc.address === this.address);
    const label = AccountController.state.addressLabels.get(this.address);
    return html`
      <wui-profile-button-v2
        .onProfileClick=${this.handleSwitchAccountsView.bind(this)}
        address=${ifDefined(this.address)}
        icon="${(account == null ? void 0 : account.type) === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT && ChainController.state.activeChain === ConstantsUtil.CHAIN.EVM ? "lightbulb" : "mail"}"
        avatarSrc=${ifDefined(this.profileImage ? this.profileImage : void 0)}
        profileName=${ifDefined(label ? label : this.profileName)}
        .onCopyClick=${this.onCopyAddress.bind(this)}
      ></wui-profile-button-v2>
    `;
  }
  onCopyAddress() {
    try {
      if (this.address) {
        CoreHelperUtil.copyToClopboard(this.address);
        SnackController.showSuccess("Address copied");
      }
    } catch {
      SnackController.showError("Failed to copy");
    }
  }
  onTransactions() {
    EventsController.sendEvent({
      type: "track",
      event: "CLICK_TRANSACTIONS",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("Transactions");
  }
  async onDisconnect() {
    try {
      this.disconnecting = true;
      await ConnectionController.disconnect();
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_SUCCESS" });
      ModalController.close();
    } catch {
      EventsController.sendEvent({ type: "track", event: "DISCONNECT_ERROR" });
      SnackController.showError("Failed to disconnect");
    } finally {
      this.disconnecting = false;
    }
  }
  onExplorer() {
    const addressExplorerUrl = AccountController.state.addressExplorerUrl;
    if (addressExplorerUrl) {
      CoreHelperUtil.openHref(addressExplorerUrl, "_blank");
    }
  }
  onGoToUpgradeView() {
    EventsController.sendEvent({ type: "track", event: "EMAIL_UPGRADE_FROM_MODAL" });
    RouterController.push("UpgradeEmailWallet");
  }
};
W3mAccountDefaultWidget.styles = styles_default55;
__decorate80([
  state()
], W3mAccountDefaultWidget.prototype, "caipAddress", void 0);
__decorate80([
  state()
], W3mAccountDefaultWidget.prototype, "address", void 0);
__decorate80([
  state()
], W3mAccountDefaultWidget.prototype, "profileImage", void 0);
__decorate80([
  state()
], W3mAccountDefaultWidget.prototype, "profileName", void 0);
__decorate80([
  state()
], W3mAccountDefaultWidget.prototype, "disconnecting", void 0);
__decorate80([
  state()
], W3mAccountDefaultWidget.prototype, "balance", void 0);
__decorate80([
  state()
], W3mAccountDefaultWidget.prototype, "balanceSymbol", void 0);
__decorate80([
  state()
], W3mAccountDefaultWidget.prototype, "features", void 0);
W3mAccountDefaultWidget = __decorate80([
  customElement("w3m-account-default-widget")
], W3mAccountDefaultWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-wallet-features-widget/styles.js
var styles_default56 = css`
  wui-flex {
    width: 100%;
  }

  wui-promo {
    position: absolute;
    top: -32px;
  }

  wui-profile-button {
    margin-top: calc(-1 * var(--wui-spacing-2l));
  }

  wui-promo + wui-profile-button {
    margin-top: var(--wui-spacing-2l);
  }

  wui-tabs {
    width: 100%;
  }

  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-wallet-features-widget/index.js
var __decorate81 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var TABS = 3;
var TABS_PADDING = 48;
var MODAL_MOBILE_VIEW_PX = 430;
var W3mAccountWalletFeaturesWidget = class W3mAccountWalletFeaturesWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.address = AccountController.state.address;
    this.profileImage = AccountController.state.profileImage;
    this.profileName = AccountController.state.profileName;
    this.smartAccountDeployed = AccountController.state.smartAccountDeployed;
    this.network = ChainController.state.activeCaipNetwork;
    this.currentTab = AccountController.state.currentTab;
    this.tokenBalance = AccountController.state.tokenBalance;
    this.preferredAccountType = AccountController.state.preferredAccountType;
    this.features = OptionsController.state.features;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        if (val.address) {
          this.address = val.address;
          this.profileImage = val.profileImage;
          this.profileName = val.profileName;
          this.currentTab = val.currentTab;
          this.tokenBalance = val.tokenBalance;
          this.smartAccountDeployed = val.smartAccountDeployed;
          this.preferredAccountType = val.preferredAccountType;
        } else {
          ModalController.close();
        }
      })
    ], ChainController.subscribeKey("activeCaipNetwork", (val) => this.network = val), OptionsController.subscribeKey("features", (val) => this.features = val));
    this.watchSwapValues();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    clearInterval(this.watchTokenBalance);
  }
  firstUpdated() {
    AccountController.fetchTokenBalance();
  }
  render() {
    if (!this.address) {
      throw new Error("w3m-account-view: No account provided");
    }
    const networkImage = AssetUtil.getNetworkImage(this.network);
    return html`<wui-flex
      flexDirection="column"
      .padding=${["0", "xl", "m", "xl"]}
      alignItems="center"
      gap="m"
    >
      ${this.network && html`<wui-network-icon .network=${this.network}></wui-network-icon>`}
      ${this.activateAccountTemplate()}
      <wui-profile-button
        @click=${this.onProfileButtonClick.bind(this)}
        address=${ifDefined(this.address)}
        networkSrc=${ifDefined(networkImage)}
        icon="chevronBottom"
        avatarSrc=${ifDefined(this.profileImage ? this.profileImage : void 0)}
        profileName=${this.profileName}
        data-testid="w3m-profile-button"
      ></wui-profile-button>
      ${this.tokenBalanceTemplate()}
      <wui-flex gap="s">
        <w3m-tooltip-trigger text="Buy">
          <wui-icon-button
            data-testid="wallet-features-onramp-button"
            @click=${this.onBuyClick.bind(this)}
            icon="card"
          ></wui-icon-button>
        </w3m-tooltip-trigger>
        ${this.swapsTemplate()}
        <w3m-tooltip-trigger text="Receive">
          <wui-icon-button
            data-testid="wallet-features-receive-button"
            @click=${this.onReceiveClick.bind(this)}
            icon="arrowBottomCircle"
          >
          </wui-icon-button>
        </w3m-tooltip-trigger>
        <w3m-tooltip-trigger text="Send">
          <wui-icon-button
            data-testid="wallet-features-send-button"
            @click=${this.onSendClick.bind(this)}
            icon="send"
          ></wui-icon-button>
        </w3m-tooltip-trigger>
      </wui-flex>

      <wui-tabs
        .onTabChange=${this.onTabChange.bind(this)}
        .activeTab=${this.currentTab}
        localTabWidth=${CoreHelperUtil.isMobile() && window.innerWidth < MODAL_MOBILE_VIEW_PX ? `${(window.innerWidth - TABS_PADDING) / TABS}px` : "104px"}
        .tabs=${ConstantsUtil4.ACCOUNT_TABS}
      ></wui-tabs>
      ${this.listContentTemplate()}
    </wui-flex>`;
  }
  swapsTemplate() {
    var _a;
    const swaps = (_a = this.features) == null ? void 0 : _a.swaps;
    if (!swaps) {
      return null;
    }
    return html`
      <w3m-tooltip-trigger text="Swap">
        <wui-icon-button
          data-testid="wallet-features-swap-button"
          @click=${this.onSwapClick.bind(this)}
          icon="recycleHorizontal"
        >
        </wui-icon-button>
      </w3m-tooltip-trigger>
    `;
  }
  watchSwapValues() {
    this.watchTokenBalance = setInterval(() => AccountController.fetchTokenBalance(), 1e4);
  }
  listContentTemplate() {
    if (this.currentTab === 0) {
      return html`<w3m-account-tokens-widget></w3m-account-tokens-widget>`;
    }
    if (this.currentTab === 1) {
      return html`<w3m-account-nfts-widget></w3m-account-nfts-widget>`;
    }
    if (this.currentTab === 2) {
      return html`<w3m-account-activity-widget></w3m-account-activity-widget>`;
    }
    return html`<w3m-account-tokens-widget></w3m-account-tokens-widget>`;
  }
  tokenBalanceTemplate() {
    var _a;
    if (this.tokenBalance && ((_a = this.tokenBalance) == null ? void 0 : _a.length) >= 0) {
      const value = CoreHelperUtil.calculateBalance(this.tokenBalance);
      const { dollars = "0", pennies = "00" } = CoreHelperUtil.formatTokenBalance(value);
      return html`<wui-balance dollars=${dollars} pennies=${pennies}></wui-balance>`;
    }
    return html`<wui-balance dollars="0" pennies="00"></wui-balance>`;
  }
  activateAccountTemplate() {
    const smartAccountEnabled = NetworkController.checkIfSmartAccountEnabled();
    if (!smartAccountEnabled || this.preferredAccountType !== W3mFrameRpcConstants.ACCOUNT_TYPES.EOA || this.smartAccountDeployed) {
      return null;
    }
    return html` <wui-promo
      text=${"Activate your account"}
      @click=${this.onUpdateToSmartAccount.bind(this)}
      data-testid="activate-smart-account-promo"
    ></wui-promo>`;
  }
  onTabChange(index) {
    AccountController.setCurrentTab(index);
  }
  onProfileButtonClick() {
    RouterController.push("Profile");
  }
  onBuyClick() {
    RouterController.push("OnRampProviders");
  }
  onSwapClick() {
    var _a, _b, _c;
    if (((_a = this.network) == null ? void 0 : _a.id) && !ConstantsUtil2.SWAP_SUPPORTED_NETWORKS.includes((_b = this.network) == null ? void 0 : _b.id)) {
      RouterController.push("UnsupportedChain", {
        swapUnsupportedChain: true
      });
    } else {
      EventsController.sendEvent({
        type: "track",
        event: "OPEN_SWAP",
        properties: {
          network: ((_c = this.network) == null ? void 0 : _c.id) || "",
          isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
        }
      });
      RouterController.push("Swap");
    }
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
  onSendClick() {
    var _a;
    EventsController.sendEvent({
      type: "track",
      event: "OPEN_SEND",
      properties: {
        network: ((_a = this.network) == null ? void 0 : _a.id) || "",
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("WalletSend");
  }
  onUpdateToSmartAccount() {
    RouterController.push("UpgradeToSmartAccount");
  }
};
W3mAccountWalletFeaturesWidget.styles = styles_default56;
__decorate81([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "watchTokenBalance", void 0);
__decorate81([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "address", void 0);
__decorate81([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "profileImage", void 0);
__decorate81([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "profileName", void 0);
__decorate81([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "smartAccountDeployed", void 0);
__decorate81([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "network", void 0);
__decorate81([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "currentTab", void 0);
__decorate81([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "tokenBalance", void 0);
__decorate81([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "preferredAccountType", void 0);
__decorate81([
  state()
], W3mAccountWalletFeaturesWidget.prototype, "features", void 0);
W3mAccountWalletFeaturesWidget = __decorate81([
  customElement("w3m-account-wallet-features-widget")
], W3mAccountWalletFeaturesWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-activity-widget/styles.js
var styles_default57 = css`
  :host {
    width: 100%;
    max-height: 280px;
    overflow: scroll;
    scrollbar-width: none;
  }

  :host::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-activity-widget/index.js
var __decorate82 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountActivityWidget = class W3mAccountActivityWidget2 extends LitElement {
  render() {
    return html`<w3m-activity-list page="account"></w3m-activity-list>`;
  }
};
W3mAccountActivityWidget.styles = styles_default57;
W3mAccountActivityWidget = __decorate82([
  customElement("w3m-account-activity-widget")
], W3mAccountActivityWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-nfts-widget/styles.js
var styles_default58 = css`
  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-nfts-widget/index.js
var __decorate83 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountNftsWidget = class W3mAccountNftsWidget2 extends LitElement {
  render() {
    return html`${this.nftTemplate()}`;
  }
  nftTemplate() {
    return html` <wui-flex
      class="contentContainer"
      alignItems="center"
      justifyContent="center"
      flexDirection="column"
      gap="l"
    >
      <wui-icon-box
        icon="wallet"
        size="inherit"
        iconColor="fg-200"
        backgroundColor="fg-200"
        iconSize="lg"
      ></wui-icon-box>
      <wui-flex
        class="textContent"
        gap="xs"
        flexDirection="column"
        justifyContent="center"
        flexDirection="column"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100">Coming soon</wui-text>
        <wui-text variant="small-400" align="center" color="fg-200"
          >Stay tuned for our upcoming NFT feature</wui-text
        >
      </wui-flex>
      <wui-link @click=${this.onReceiveClick.bind(this)}>Receive funds</wui-link>
    </wui-flex>`;
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
};
W3mAccountNftsWidget.styles = styles_default58;
W3mAccountNftsWidget = __decorate83([
  customElement("w3m-account-nfts-widget")
], W3mAccountNftsWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-tokens-widget/styles.js
var styles_default59 = css`
  :host {
    width: 100%;
  }

  wui-flex {
    width: 100%;
  }

  .contentContainer {
    max-height: 280px;
    overflow: scroll;
    scrollbar-width: none;
  }

  .contentContainer::-webkit-scrollbar {
    display: none;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-tokens-widget/index.js
var __decorate84 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountTokensWidget = class W3mAccountTokensWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.tokenBalance = AccountController.state.tokenBalance;
    this.unsubscribe.push(...[
      AccountController.subscribe((val) => {
        this.tokenBalance = val.tokenBalance;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html`${this.tokenTemplate()}`;
  }
  tokenTemplate() {
    var _a;
    if (this.tokenBalance && ((_a = this.tokenBalance) == null ? void 0 : _a.length) > 0) {
      return html`<wui-flex class="contentContainer" flexDirection="column" gap="xs">
        ${this.tokenItemTemplate()}
      </wui-flex>`;
    }
    return html` <wui-flex flexDirection="column" gap="xs"
      ><wui-list-description
        @click=${this.onBuyClick.bind(this)}
        text="Buy Crypto"
        description="Easy with card or bank account"
        icon="card"
        iconColor="success-100"
        iconBackgroundColor="success-100"
        tag="popular"
      ></wui-list-description
      ><wui-list-description
        @click=${this.onReceiveClick.bind(this)}
        text="Receive funds"
        description="Transfer tokens on your wallet"
        icon="arrowBottomCircle"
        iconColor="fg-200"
        iconBackgroundColor="fg-200"
      ></wui-list-description
    ></wui-flex>`;
  }
  tokenItemTemplate() {
    var _a;
    return (_a = this.tokenBalance) == null ? void 0 : _a.map((token) => html`<wui-list-token
          tokenName=${token.name}
          tokenImageUrl=${token.iconUrl}
          tokenAmount=${token.quantity.numeric}
          tokenValue=${token.value}
          tokenCurrency=${token.symbol}
        ></wui-list-token>`);
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
  onBuyClick() {
    EventsController.sendEvent({
      type: "track",
      event: "SELECT_BUY_CRYPTO",
      properties: {
        isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
      }
    });
    RouterController.push("OnRampProviders");
  }
};
W3mAccountTokensWidget.styles = styles_default59;
__decorate84([
  state()
], W3mAccountTokensWidget.prototype, "tokenBalance", void 0);
W3mAccountTokensWidget = __decorate84([
  customElement("w3m-account-tokens-widget")
], W3mAccountTokensWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-activity-list/styles.js
var styles_default60 = css`
  :host {
    min-height: 100%;
  }

  .group-container[last-group='true'] {
    padding-bottom: var(--wui-spacing-m);
  }

  .contentContainer {
    height: 280px;
  }

  .contentContainer > wui-icon-box {
    width: 40px;
    height: 40px;
    border-radius: var(--wui-border-radius-xxs);
  }

  .contentContainer > .textContent {
    width: 65%;
  }

  .emptyContainer {
    height: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-activity-list/index.js
var __decorate85 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var PAGINATOR_ID2 = "last-transaction";
var LOADING_ITEM_COUNT2 = 7;
var W3mActivityList = class W3mActivityList2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.paginationObserver = void 0;
    this.page = "activity";
    this.caipAddress = ChainController.state.activeCaipAddress;
    this.transactionsByYear = TransactionsController.state.transactionsByYear;
    this.loading = TransactionsController.state.loading;
    this.empty = TransactionsController.state.empty;
    this.next = TransactionsController.state.next;
    TransactionsController.clearCursor();
    this.unsubscribe.push(...[
      ChainController.subscribeKey("activeCaipAddress", (val) => {
        if (val) {
          if (this.caipAddress !== val) {
            TransactionsController.resetTransactions();
            TransactionsController.fetchTransactions(val);
          }
        }
        this.caipAddress = val;
      }),
      ChainController.subscribeKey("activeCaipNetwork", () => {
        this.updateTransactionView();
      }),
      TransactionsController.subscribe((val) => {
        this.transactionsByYear = val.transactionsByYear;
        this.loading = val.loading;
        this.empty = val.empty;
        this.next = val.next;
      })
    ]);
  }
  firstUpdated() {
    this.updateTransactionView();
    this.createPaginationObserver();
  }
  updated() {
    this.setPaginationObserver();
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    return html` ${this.empty ? null : this.templateTransactionsByYear()}
    ${this.loading ? this.templateLoading() : null}
    ${!this.loading && this.empty ? this.templateEmpty() : null}`;
  }
  updateTransactionView() {
    var _a;
    const currentNetwork = (_a = ChainController.state.activeCaipNetwork) == null ? void 0 : _a.id;
    const lastNetworkInView = TransactionsController.state.lastNetworkInView;
    if (lastNetworkInView !== currentNetwork) {
      TransactionsController.resetTransactions();
      if (this.caipAddress) {
        TransactionsController.fetchTransactions(CoreHelperUtil.getPlainAddress(this.caipAddress));
      }
    }
    TransactionsController.setLastNetworkInView(currentNetwork);
  }
  templateTransactionsByYear() {
    const sortedYearKeys = Object.keys(this.transactionsByYear).sort().reverse();
    return sortedYearKeys.map((year) => {
      const yearInt = parseInt(year, 10);
      const sortedMonthIndexes = new Array(12).fill(null).map((_2, idx) => {
        var _a;
        const groupTitle = TransactionUtil.getTransactionGroupTitle(yearInt, idx);
        const transactions = (_a = this.transactionsByYear[yearInt]) == null ? void 0 : _a[idx];
        return {
          groupTitle,
          transactions
        };
      }).filter(({ transactions }) => transactions).reverse();
      return sortedMonthIndexes.map(({ groupTitle, transactions }, index) => {
        const isLastGroup = index === sortedMonthIndexes.length - 1;
        if (!transactions) {
          return null;
        }
        return html`
          <wui-flex
            flexDirection="column"
            class="group-container"
            last-group="${isLastGroup ? "true" : "false"}"
          >
            <wui-flex
              alignItems="center"
              flexDirection="row"
              .padding=${["xs", "s", "s", "s"]}
            >
              <wui-text variant="paragraph-500" color="fg-200">${groupTitle}</wui-text>
            </wui-flex>
            <wui-flex flexDirection="column" gap="xs">
              ${this.templateTransactions(transactions, isLastGroup)}
            </wui-flex>
          </wui-flex>
        `;
      });
    });
  }
  templateRenderTransaction(transaction, isLastTransaction) {
    const { date, descriptions, direction, isAllNFT, images, status, transfers, type } = this.getTransactionListItemProps(transaction);
    const haveMultipleTransfers = (transfers == null ? void 0 : transfers.length) > 1;
    const haveTwoTransfers = (transfers == null ? void 0 : transfers.length) === 2;
    if (haveTwoTransfers && !isAllNFT) {
      return html`
        <wui-transaction-list-item
          date=${date}
          .direction=${direction}
          id=${isLastTransaction && this.next ? PAGINATOR_ID2 : ""}
          status=${status}
          type=${type}
          .images=${images}
          .descriptions=${descriptions}
        ></wui-transaction-list-item>
      `;
    }
    if (haveMultipleTransfers) {
      return transfers.map((transfer, index) => {
        const description = TransactionUtil.getTransferDescription(transfer);
        const isLastTransfer = isLastTransaction && index === transfers.length - 1;
        return html` <wui-transaction-list-item
          date=${date}
          direction=${transfer.direction}
          id=${isLastTransfer && this.next ? PAGINATOR_ID2 : ""}
          status=${status}
          type=${type}
          .onlyDirectionIcon=${true}
          .images=${[images[index]]}
          .descriptions=${[description]}
        ></wui-transaction-list-item>`;
      });
    }
    return html`
      <wui-transaction-list-item
        date=${date}
        .direction=${direction}
        id=${isLastTransaction && this.next ? PAGINATOR_ID2 : ""}
        status=${status}
        type=${type}
        .images=${images}
        .descriptions=${descriptions}
      ></wui-transaction-list-item>
    `;
  }
  templateTransactions(transactions, isLastGroup) {
    return transactions.map((transaction, index) => {
      const isLastTransaction = isLastGroup && index === transactions.length - 1;
      return html`${this.templateRenderTransaction(transaction, isLastTransaction)}`;
    });
  }
  emptyStateActivity() {
    return html`<wui-flex
      class="emptyContainer"
      flexGrow="1"
      flexDirection="column"
      justifyContent="center"
      alignItems="center"
      .padding=${["3xl", "xl", "3xl", "xl"]}
      gap="xl"
    >
      <wui-icon-box
        backgroundColor="gray-glass-005"
        background="gray"
        iconColor="fg-200"
        icon="wallet"
        size="lg"
        ?border=${true}
        borderColor="wui-color-bg-125"
      ></wui-icon-box>
      <wui-flex flexDirection="column" alignItems="center" gap="xs">
        <wui-text align="center" variant="paragraph-500" color="fg-100"
          >No Transactions yet</wui-text
        >
        <wui-text align="center" variant="small-500" color="fg-200"
          >Start trading on dApps <br />
          to grow your wallet!</wui-text
        >
      </wui-flex>
    </wui-flex>`;
  }
  emptyStateAccount() {
    return html`<wui-flex
      class="contentContainer"
      alignItems="center"
      justifyContent="center"
      flexDirection="column"
      gap="l"
    >
      <wui-icon-box
        icon="swapHorizontal"
        size="inherit"
        iconColor="fg-200"
        backgroundColor="fg-200"
        iconSize="lg"
      ></wui-icon-box>
      <wui-flex
        class="textContent"
        gap="xs"
        flexDirection="column"
        justifyContent="center"
        flexDirection="column"
      >
        <wui-text variant="paragraph-500" align="center" color="fg-100">No activity yet</wui-text>
        <wui-text variant="small-400" align="center" color="fg-200"
          >Your next transactions will appear here</wui-text
        >
      </wui-flex>
      <wui-link @click=${this.onReceiveClick.bind(this)}>Trade</wui-link>
    </wui-flex>`;
  }
  templateEmpty() {
    if (this.page === "account") {
      return html`${this.emptyStateAccount()}`;
    }
    return html`${this.emptyStateActivity()}`;
  }
  templateLoading() {
    if (this.page === "activity") {
      return Array(LOADING_ITEM_COUNT2).fill(html` <wui-transaction-list-item-loader></wui-transaction-list-item-loader> `).map((item) => item);
    }
    return null;
  }
  onReceiveClick() {
    RouterController.push("WalletReceive");
  }
  createPaginationObserver() {
    const { projectId } = OptionsController.state;
    this.paginationObserver = new IntersectionObserver(([element]) => {
      if ((element == null ? void 0 : element.isIntersecting) && !this.loading) {
        TransactionsController.fetchTransactions(CoreHelperUtil.getPlainAddress(this.caipAddress));
        EventsController.sendEvent({
          type: "track",
          event: "LOAD_MORE_TRANSACTIONS",
          properties: {
            address: CoreHelperUtil.getPlainAddress(this.caipAddress),
            projectId,
            cursor: this.next,
            isSmartAccount: AccountController.state.preferredAccountType === W3mFrameRpcConstants.ACCOUNT_TYPES.SMART_ACCOUNT
          }
        });
      }
    }, {});
    this.setPaginationObserver();
  }
  setPaginationObserver() {
    var _a, _b, _c;
    (_a = this.paginationObserver) == null ? void 0 : _a.disconnect();
    const lastItem = (_b = this.shadowRoot) == null ? void 0 : _b.querySelector(`#${PAGINATOR_ID2}`);
    if (lastItem) {
      (_c = this.paginationObserver) == null ? void 0 : _c.observe(lastItem);
    }
  }
  getTransactionListItemProps(transaction) {
    var _a, _b, _c, _d, _e4;
    const date = DateUtil.formatDate((_a = transaction == null ? void 0 : transaction.metadata) == null ? void 0 : _a.minedAt);
    const descriptions = TransactionUtil.getTransactionDescriptions(transaction);
    const transfers = transaction == null ? void 0 : transaction.transfers;
    const transfer = (_b = transaction == null ? void 0 : transaction.transfers) == null ? void 0 : _b[0];
    const isAllNFT = Boolean(transfer) && ((_c = transaction == null ? void 0 : transaction.transfers) == null ? void 0 : _c.every((item) => Boolean(item.nft_info)));
    const images = TransactionUtil.getTransactionImages(transfers);
    return {
      date,
      direction: transfer == null ? void 0 : transfer.direction,
      descriptions,
      isAllNFT,
      images,
      status: (_d = transaction.metadata) == null ? void 0 : _d.status,
      transfers,
      type: (_e4 = transaction.metadata) == null ? void 0 : _e4.operationType
    };
  }
};
W3mActivityList.styles = styles_default60;
__decorate85([
  property()
], W3mActivityList.prototype, "page", void 0);
__decorate85([
  state()
], W3mActivityList.prototype, "caipAddress", void 0);
__decorate85([
  state()
], W3mActivityList.prototype, "transactionsByYear", void 0);
__decorate85([
  state()
], W3mActivityList.prototype, "loading", void 0);
__decorate85([
  state()
], W3mActivityList.prototype, "empty", void 0);
__decorate85([
  state()
], W3mActivityList.prototype, "next", void 0);
W3mActivityList = __decorate85([
  customElement("w3m-activity-list")
], W3mActivityList);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-input-token/styles.js
var styles_default61 = css`
  :host {
    width: 100%;
    height: 100px;
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-gray-glass-002);
    background-color: var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  :host(:hover) {
    background-color: var(--wui-color-gray-glass-005);
  }

  wui-flex {
    width: 100%;
    height: fit-content;
  }

  wui-button {
    width: 100%;
    display: flex;
    justify-content: flex-end;
  }

  wui-input-amount {
    mask-image: linear-gradient(
      270deg,
      transparent 0px,
      transparent 8px,
      black 24px,
      black 25px,
      black 32px,
      black 100%
    );
  }

  .totalValue {
    width: 100%;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-input-token/index.js
var __decorate86 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mInputToken = class W3mInputToken2 extends LitElement {
  render() {
    return html` <wui-flex
      flexDirection="column"
      gap="4xs"
      .padding=${["xl", "s", "l", "l"]}
    >
      <wui-flex alignItems="center">
        <wui-input-amount
          @inputChange=${this.onInputChange.bind(this)}
          ?disabled=${!this.token && true}
          .value=${this.sendTokenAmount ? String(this.sendTokenAmount) : ""}
        ></wui-input-amount>
        ${this.buttonTemplate()}
      </wui-flex>
      <wui-flex alignItems="center" justifyContent="space-between">
        ${this.sendValueTemplate()}
        <wui-flex alignItems="center" gap="4xs" justifyContent="flex-end">
          ${this.maxAmountTemplate()} ${this.actionTemplate()}
        </wui-flex>
      </wui-flex>
    </wui-flex>`;
  }
  buttonTemplate() {
    if (this.token) {
      return html`<wui-token-button
        text=${this.token.symbol}
        imageSrc=${this.token.iconUrl}
        @click=${this.handleSelectButtonClick.bind(this)}
      >
      </wui-token-button>`;
    }
    return html`<wui-button
      size="md"
      variant="accent"
      @click=${this.handleSelectButtonClick.bind(this)}
      >Select token</wui-button
    >`;
  }
  handleSelectButtonClick() {
    RouterController.push("WalletSendSelectToken");
  }
  sendValueTemplate() {
    if (this.token && this.sendTokenAmount) {
      const price = this.token.price;
      const totalValue = price * this.sendTokenAmount;
      return html`<wui-text class="totalValue" variant="small-400" color="fg-200"
        >${totalValue ? `$${UiHelperUtil.formatNumberToLocalString(totalValue, 2)}` : "Incorrect value"}</wui-text
      >`;
    }
    return null;
  }
  maxAmountTemplate() {
    if (this.token) {
      if (this.sendTokenAmount && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
        return html` <wui-text variant="small-400" color="error-100">
          ${UiHelperUtil.roundNumber(Number(this.token.quantity.numeric), 6, 5)}
        </wui-text>`;
      }
      return html` <wui-text variant="small-400" color="fg-200">
        ${UiHelperUtil.roundNumber(Number(this.token.quantity.numeric), 6, 5)}
      </wui-text>`;
    }
    return null;
  }
  actionTemplate() {
    if (this.token) {
      if (this.sendTokenAmount && this.sendTokenAmount > Number(this.token.quantity.numeric)) {
        return html`<wui-link @click=${this.onBuyClick.bind(this)}>Buy</wui-link>`;
      }
      return html`<wui-link @click=${this.onMaxClick.bind(this)}>Max</wui-link>`;
    }
    return null;
  }
  onInputChange(event) {
    SendController.setTokenAmount(event.detail);
  }
  onMaxClick() {
    if (this.token && typeof this.gasPrice !== "undefined") {
      const isNetworkToken = this.token.address === void 0 || Object.values(ConstantsUtil2.NATIVE_TOKEN_ADDRESS).some((nativeAddress) => {
        var _a;
        return ((_a = this.token) == null ? void 0 : _a.address) === nativeAddress;
      });
      const numericGas = NumberUtil.bigNumber(this.gasPrice).shiftedBy(-this.token.quantity.decimals);
      const maxValue = isNetworkToken ? NumberUtil.bigNumber(this.token.quantity.numeric).minus(numericGas) : NumberUtil.bigNumber(this.token.quantity.numeric);
      SendController.setTokenAmount(Number(maxValue.toFixed(20)));
    }
  }
  onBuyClick() {
    RouterController.push("OnRampProviders");
  }
};
W3mInputToken.styles = styles_default61;
__decorate86([
  property({ type: Object })
], W3mInputToken.prototype, "token", void 0);
__decorate86([
  property({ type: Number })
], W3mInputToken.prototype, "sendTokenAmount", void 0);
__decorate86([
  property({ type: Number })
], W3mInputToken.prototype, "gasPriceInUSD", void 0);
__decorate86([
  property({ type: Number })
], W3mInputToken.prototype, "gasPrice", void 0);
W3mInputToken = __decorate86([
  customElement("w3m-input-token")
], W3mInputToken);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-input-address/styles.js
var styles_default62 = css`
  :host {
    width: 100%;
    height: 100px;
    border-radius: var(--wui-border-radius-s);
    border: 1px solid var(--wui-color-gray-glass-002);
    background-color: var(--wui-color-gray-glass-002);
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
    position: relative;
  }

  :host(:hover) {
    background-color: var(--wui-color-gray-glass-005);
  }

  wui-flex {
    width: 100%;
    height: fit-content;
  }

  wui-button {
    display: ruby;
    color: var(--wui-color-fg-100);
    margin: 0 var(--wui-spacing-xs);
  }

  .instruction {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    z-index: 2;
  }

  .paste {
    display: inline-flex;
  }

  textarea {
    background: transparent;
    width: 100%;
    font-family: var(--w3m-font-family);
    font-size: var(--wui-font-size-medium);
    font-style: normal;
    font-weight: var(--wui-font-weight-light);
    line-height: 130%;
    letter-spacing: var(--wui-letter-spacing-medium);
    color: var(--wui-color-fg-100);
    caret-color: var(--wui-color-accent-100);
    box-sizing: border-box;
    -webkit-appearance: none;
    -moz-appearance: textfield;
    padding: 0px;
    border: none;
    outline: none;
    appearance: none;
    resize: none;
    overflow: hidden;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-input-address/index.js
var __decorate87 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mInputAddress = class W3mInputAddress2 extends LitElement {
  constructor() {
    super(...arguments);
    this.inputElementRef = createRef();
    this.instructionElementRef = createRef();
    this.instructionHidden = Boolean(this.value);
    this.pasting = false;
    this.onDebouncedSearch = CoreHelperUtil.debounce(async (value) => {
      const address = await ConnectionController.getEnsAddress(value);
      SendController.setLoading(false);
      if (address) {
        SendController.setReceiverProfileName(value);
        SendController.setReceiverAddress(address);
        const avatar = await ConnectionController.getEnsAvatar(value);
        if (avatar) {
          SendController.setReceiverProfileImageUrl(avatar);
        }
      } else {
        SendController.setReceiverAddress(value);
        SendController.setReceiverProfileName(void 0);
        SendController.setReceiverProfileImageUrl(void 0);
      }
    });
  }
  firstUpdated() {
    if (this.value) {
      this.instructionHidden = true;
    }
    this.checkHidden();
  }
  render() {
    return html` <wui-flex
      @click=${this.onBoxClick.bind(this)}
      flexDirection="column"
      justifyContent="center"
      gap="4xs"
      .padding=${["2xl", "l", "xl", "l"]}
    >
      <wui-text
        ${ref2(this.instructionElementRef)}
        class="instruction"
        color="fg-300"
        variant="medium-400"
      >
        Type or
        <wui-button
          class="paste"
          size="md"
          variant="neutral"
          iconLeft="copy"
          @click=${this.onPasteClick.bind(this)}
        >
          <wui-icon size="sm" color="inherit" slot="iconLeft" name="copy"></wui-icon>
          Paste
        </wui-button>
        address
      </wui-text>
      <textarea
        spellcheck="false"
        ?disabled=${!this.instructionHidden}
        ${ref2(this.inputElementRef)}
        @input=${this.onInputChange.bind(this)}
        @blur=${this.onBlur.bind(this)}
        .value=${this.value ?? ""}
        autocomplete="off"
      >
${this.value ?? ""}</textarea
      >
    </wui-flex>`;
  }
  async focusInput() {
    var _a;
    if (this.instructionElementRef.value) {
      this.instructionHidden = true;
      await this.toggleInstructionFocus(false);
      this.instructionElementRef.value.style.pointerEvents = "none";
      (_a = this.inputElementRef.value) == null ? void 0 : _a.focus();
      if (this.inputElementRef.value) {
        this.inputElementRef.value.selectionStart = this.inputElementRef.value.selectionEnd = this.inputElementRef.value.value.length;
      }
    }
  }
  async focusInstruction() {
    var _a;
    if (this.instructionElementRef.value) {
      this.instructionHidden = false;
      await this.toggleInstructionFocus(true);
      this.instructionElementRef.value.style.pointerEvents = "auto";
      (_a = this.inputElementRef.value) == null ? void 0 : _a.blur();
    }
  }
  async toggleInstructionFocus(focus) {
    if (this.instructionElementRef.value) {
      await this.instructionElementRef.value.animate([{ opacity: focus ? 0 : 1 }, { opacity: focus ? 1 : 0 }], {
        duration: 100,
        easing: "ease",
        fill: "forwards"
      }).finished;
    }
  }
  onBoxClick() {
    if (!this.value && !this.instructionHidden) {
      this.focusInput();
    }
  }
  onBlur() {
    if (!this.value && this.instructionHidden && !this.pasting) {
      this.focusInstruction();
    }
  }
  checkHidden() {
    if (this.instructionHidden) {
      this.focusInput();
    }
  }
  async onPasteClick() {
    this.pasting = true;
    const text = await navigator.clipboard.readText();
    SendController.setReceiverAddress(text);
    this.focusInput();
  }
  onInputChange(e2) {
    this.pasting = false;
    const element = e2.target;
    if (element.value && !this.instructionHidden) {
      this.focusInput();
    }
    SendController.setLoading(true);
    this.onDebouncedSearch(element.value);
  }
};
W3mInputAddress.styles = styles_default62;
__decorate87([
  property()
], W3mInputAddress.prototype, "value", void 0);
__decorate87([
  state()
], W3mInputAddress.prototype, "instructionHidden", void 0);
__decorate87([
  state()
], W3mInputAddress.prototype, "pasting", void 0);
W3mInputAddress = __decorate87([
  customElement("w3m-input-address")
], W3mInputAddress);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-wallet-send-details/styles.js
var styles_default63 = css`
  :host {
    display: flex;
    width: auto;
    flex-direction: column;
    gap: var(--wui-border-radius-1xs);
    border-radius: var(--wui-border-radius-s);
    background: var(--wui-color-gray-glass-002);
    padding: var(--wui-spacing-s) var(--wui-spacing-1xs) var(--wui-spacing-1xs)
      var(--wui-spacing-1xs);
  }

  wui-text {
    padding: 0 var(--wui-spacing-1xs);
  }

  wui-flex {
    margin-top: var(--wui-spacing-1xs);
  }

  .network {
    cursor: pointer;
    transition: background-color var(--wui-ease-out-power-1) var(--wui-duration-lg);
    will-change: background-color;
  }

  .network:focus-visible {
    border: 1px solid var(--wui-color-accent-100);
    background-color: var(--wui-color-gray-glass-005);
    -webkit-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    -moz-box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
    box-shadow: 0px 0px 0px 4px var(--wui-box-shadow-blue);
  }

  .network:hover {
    background-color: var(--wui-color-gray-glass-005);
  }

  .network:active {
    background-color: var(--wui-color-gray-glass-010);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-wallet-send-details/index.js
var __decorate88 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mWalletSendDetails = class W3mWalletSendDetails2 extends LitElement {
  render() {
    return html` <wui-text variant="small-400" color="fg-200">Details</wui-text>
      <wui-flex flexDirection="column" gap="xxs">
        <wui-list-content textTitle="Network cost" textValue="$${ifDefined(UiHelperUtil.formatNumberToLocalString(this.networkFee, 2))}"></wui-list-content></wui-list-content>
        <wui-list-content
          textTitle="Address"
          textValue=${UiHelperUtil.getTruncateString({
      string: this.receiverAddress ?? "",
      charsStart: 4,
      charsEnd: 4,
      truncate: "middle"
    })}
        >
        </wui-list-content>
        ${this.networkTemplate()}
      </wui-flex>`;
  }
  networkTemplate() {
    var _a;
    if ((_a = this.caipNetwork) == null ? void 0 : _a.name) {
      return html` <wui-list-content
        @click=${() => this.onNetworkClick(this.caipNetwork)}
        class="network"
        textTitle="Network"
        imageSrc=${ifDefined(AssetUtil.getNetworkImage(this.caipNetwork))}
      ></wui-list-content>`;
    }
    return null;
  }
  onNetworkClick(network) {
    if (network) {
      RouterController.push("Networks", { network });
    }
  }
};
W3mWalletSendDetails.styles = styles_default63;
__decorate88([
  property()
], W3mWalletSendDetails.prototype, "receiverAddress", void 0);
__decorate88([
  property({ type: Object })
], W3mWalletSendDetails.prototype, "caipNetwork", void 0);
__decorate88([
  property({ type: Number })
], W3mWalletSendDetails.prototype, "networkFee", void 0);
W3mWalletSendDetails = __decorate88([
  customElement("w3m-wallet-send-details")
], W3mWalletSendDetails);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-tooltip/styles.js
var styles_default64 = css`
  :host {
    pointer-events: none;
  }

  :host > wui-flex {
    display: var(--w3m-tooltip-display);
    opacity: var(--w3m-tooltip-opacity);
    padding: 9px var(--wui-spacing-s) 10px var(--wui-spacing-s);
    border-radius: var(--wui-border-radius-xxs);
    color: var(--wui-color-bg-100);
    position: fixed;
    top: var(--w3m-tooltip-top);
    left: var(--w3m-tooltip-left);
    transform: translate(calc(-50% + var(--w3m-tooltip-parent-width)), calc(-100% - 8px));
    max-width: calc(var(--w3m-modal-width) - var(--wui-spacing-xl));
    transition: opacity 0.2s var(--wui-ease-out-power-2);
    will-change: opacity;
  }

  :host([data-variant='shade']) > wui-flex {
    background-color: var(--wui-color-bg-150);
    border: 1px solid var(--wui-color-gray-glass-005);
  }

  :host([data-variant='shade']) > wui-flex > wui-text {
    color: var(--wui-color-fg-150);
  }

  :host([data-variant='fill']) > wui-flex {
    background-color: var(--wui-color-fg-100);
    border: none;
  }

  wui-icon {
    position: absolute;
    width: 12px !important;
    height: 4px !important;
    color: var(--wui-color-bg-150);
  }

  wui-icon[data-placement='top'] {
    bottom: 0px;
    left: 50%;
    transform: translate(-50%, 95%);
  }

  wui-icon[data-placement='bottom'] {
    top: 0;
    left: 50%;
    transform: translate(-50%, -95%) rotate(180deg);
  }

  wui-icon[data-placement='right'] {
    top: 50%;
    left: 0;
    transform: translate(-65%, -50%) rotate(90deg);
  }

  wui-icon[data-placement='left'] {
    top: 50%;
    right: 0%;
    transform: translate(65%, -50%) rotate(270deg);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-tooltip/index.js
var __decorate89 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mTooltip = class W3mTooltip2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.open = TooltipController.state.open;
    this.message = TooltipController.state.message;
    this.triggerRect = TooltipController.state.triggerRect;
    this.variant = TooltipController.state.variant;
    this.unsubscribe.push(...[
      TooltipController.subscribe((newState) => {
        this.open = newState.open;
        this.message = newState.message;
        this.triggerRect = newState.triggerRect;
        this.variant = newState.variant;
      })
    ]);
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    this.dataset["variant"] = this.variant;
    const topValue = this.triggerRect.top;
    const leftValue = this.triggerRect.left;
    this.style.cssText = `
    --w3m-tooltip-top: ${topValue}px;
    --w3m-tooltip-left: ${leftValue}px;
    --w3m-tooltip-parent-width: ${this.triggerRect.width / 2}px;
    --w3m-tooltip-display: ${this.open ? "flex" : "none"};
    --w3m-tooltip-opacity: ${this.open ? 1 : 0};
    `;
    return html`<wui-flex>
      <wui-icon data-placement="top" color="fg-100" size="inherit" name="cursor"></wui-icon>
      <wui-text color="inherit" variant="small-500">${this.message}</wui-text>
    </wui-flex>`;
  }
};
W3mTooltip.styles = [styles_default64];
__decorate89([
  state()
], W3mTooltip.prototype, "open", void 0);
__decorate89([
  state()
], W3mTooltip.prototype, "message", void 0);
__decorate89([
  state()
], W3mTooltip.prototype, "triggerRect", void 0);
__decorate89([
  state()
], W3mTooltip.prototype, "variant", void 0);
W3mTooltip = __decorate89([
  customElement("w3m-tooltip")
], W3mTooltip);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-tooltip-trigger/styles.js
var styles_default65 = css`
  :host {
    width: 100%;
    display: block;
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-tooltip-trigger/index.js
var __decorate90 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var WuiTooltipTrigger = class WuiTooltipTrigger2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.text = "";
    this.open = TooltipController.state.open;
    this.unsubscribe.push(RouterController.subscribeKey("view", () => {
      TooltipController.hide();
    }), ModalController.subscribeKey("open", (modalOpen) => {
      if (!modalOpen) {
        TooltipController.hide();
      }
    }), TooltipController.subscribeKey("open", (tooltipOpen) => {
      this.open = tooltipOpen;
    }));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
    TooltipController.hide();
  }
  render() {
    return html`
      <div
        @pointermove=${this.onMouseEnter.bind(this)}
        @pointerleave=${this.onMouseLeave.bind(this)}
      >
        ${this.renderChildren()}
      </div>
    `;
  }
  renderChildren() {
    return html`<slot></slot> `;
  }
  onMouseEnter() {
    const rect = this.getBoundingClientRect();
    if (!this.open) {
      TooltipController.showTooltip({
        message: this.text,
        triggerRect: {
          width: rect.width,
          height: rect.height,
          left: rect.left,
          top: rect.top
        },
        variant: "shade"
      });
    }
  }
  onMouseLeave(event) {
    if (!this.contains(event.relatedTarget)) {
      TooltipController.hide();
    }
  }
};
WuiTooltipTrigger.styles = [styles_default65];
__decorate90([
  property()
], WuiTooltipTrigger.prototype, "text", void 0);
__decorate90([
  state()
], WuiTooltipTrigger.prototype, "open", void 0);
WuiTooltipTrigger = __decorate90([
  customElement("w3m-tooltip-trigger")
], WuiTooltipTrigger);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-social-login-widget/styles.js
var styles_default66 = css`
  :host > wui-flex:first-child {
    margin-top: var(--wui-spacing-s);
  }
  wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-m)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-social-login-widget/index.js
var __decorate91 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var MAX_TOP_VIEW = 2;
var MAXIMUM_LENGTH = 6;
var W3mSocialLoginWidget = class W3mSocialLoginWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.features = OptionsController.state.features;
    this.authConnector = this.connectors.find((c5) => c5.type === "AUTH");
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => {
      this.connectors = val;
      this.authConnector = this.connectors.find((c5) => c5.type === "AUTH");
    }), OptionsController.subscribeKey("features", (val) => this.features = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a;
    const socials = (_a = this.features) == null ? void 0 : _a.socials;
    if (!this.authConnector || !socials || !(socials == null ? void 0 : socials.length)) {
      return null;
    }
    return html`
      <wui-flex
        class="container"
        flexDirection="column"
        gap="xs"
        .padding=${["0", "0", "xs", "0"]}
        data-testid="w3m-social-login-widget"
      >
        ${this.topViewTemplate()}${this.bottomViewTemplate()}
      </wui-flex>
      ${this.separatorTemplate()}
    `;
  }
  topViewTemplate() {
    var _a;
    const socials = (_a = this.features) == null ? void 0 : _a.socials;
    if (!this.authConnector || !socials || !(socials == null ? void 0 : socials.length)) {
      return null;
    }
    if (socials.length === 2) {
      return html` <wui-flex gap="xs">
        ${socials.slice(0, MAX_TOP_VIEW).map((social) => html`<wui-logo-select
              data-testid=${`social-selector-${social}`}
              @click=${() => {
        this.onSocialClick(social);
      }}
              logo=${social}
            ></wui-logo-select>`)}
      </wui-flex>`;
    }
    return html` <wui-list-social
      data-testid=${`social-selector-${socials == null ? void 0 : socials[0]}`}
      @click=${() => {
      this.onSocialClick(socials == null ? void 0 : socials[0]);
    }}
      logo=${ifDefined(socials[0])}
      align="center"
      name=${`Continue with ${socials[0]}`}
    ></wui-list-social>`;
  }
  bottomViewTemplate() {
    var _a;
    const socials = (_a = this.features) == null ? void 0 : _a.socials;
    if (!this.authConnector || !socials || !(socials == null ? void 0 : socials.length)) {
      return null;
    }
    if (socials.length <= MAX_TOP_VIEW) {
      return null;
    }
    if (socials.length > MAXIMUM_LENGTH) {
      return html`<wui-flex gap="xs">
        ${socials.slice(1, MAXIMUM_LENGTH - 1).map((social) => html`<wui-logo-select
              data-testid=${`social-selector-${social}`}
              @click=${() => {
        this.onSocialClick(social);
      }}
              logo=${social}
            ></wui-logo-select>`)}
        <wui-logo-select logo="more" @click=${this.onMoreSocialsClick.bind(this)}></wui-logo-select>
      </wui-flex>`;
    }
    return html`<wui-flex gap="xs">
      ${socials.slice(1, socials.length).map((social) => html`<wui-logo-select
            data-testid=${`social-selector-${social}`}
            @click=${() => {
      this.onSocialClick(social);
    }}
            logo=${social}
          ></wui-logo-select>`)}
    </wui-flex>`;
  }
  separatorTemplate() {
    const walletConnectConnector = this.connectors.find((c5) => c5.type === "WALLET_CONNECT");
    const enableWallets = OptionsController.state.enableWallets;
    if (walletConnectConnector && enableWallets) {
      return html`<wui-separator text="or"></wui-separator>`;
    }
    return null;
  }
  onMoreSocialsClick() {
    RouterController.push("ConnectSocials");
  }
  async onSocialClick(socialProvider) {
    var _a, _b;
    if (socialProvider) {
      AccountController.setSocialProvider(socialProvider, ChainController.state.activeChain);
      EventsController.sendEvent({
        type: "track",
        event: "SOCIAL_LOGIN_STARTED",
        properties: { provider: socialProvider }
      });
    }
    if (socialProvider === SocialProviderEnum.Farcaster) {
      RouterController.push("ConnectingFarcaster");
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        if (!AccountController.state.farcasterUrl) {
          try {
            const { url } = await authConnector.provider.getFarcasterUri();
            AccountController.setFarcasterUrl(url, ChainController.state.activeChain);
          } catch (error) {
            RouterController.goBack();
            SnackController.showError(error);
          }
        }
      }
    } else {
      RouterController.push("ConnectingSocial");
      const authConnector = ConnectorController.getAuthConnector();
      this.popupWindow = CoreHelperUtil.returnOpenHref("", "popupWindow", "width=600,height=800,scrollbars=yes");
      try {
        if (authConnector && socialProvider) {
          const { uri } = await authConnector.provider.getSocialRedirectUri({
            provider: socialProvider
          });
          if (this.popupWindow && uri) {
            AccountController.setSocialWindow(this.popupWindow, ChainController.state.activeChain);
            this.popupWindow.location.href = uri;
          } else {
            (_a = this.popupWindow) == null ? void 0 : _a.close();
            throw new Error("Something went wrong");
          }
        }
      } catch (error) {
        (_b = this.popupWindow) == null ? void 0 : _b.close();
        SnackController.showError("Something went wrong");
      }
    }
  }
};
W3mSocialLoginWidget.styles = styles_default66;
__decorate91([
  state()
], W3mSocialLoginWidget.prototype, "connectors", void 0);
__decorate91([
  state()
], W3mSocialLoginWidget.prototype, "features", void 0);
__decorate91([
  state()
], W3mSocialLoginWidget.prototype, "authConnector", void 0);
W3mSocialLoginWidget = __decorate91([
  customElement("w3m-social-login-widget")
], W3mSocialLoginWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-wallet-login-list/index.js
var __decorate92 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mWalletLoginList = class W3mWalletLoginList2 extends LitElement {
  render() {
    return html`
      <wui-flex flexDirection="column" gap="xs">
        <w3m-connector-list></w3m-connector-list>
        <w3m-all-wallets-widget></w3m-all-wallets-widget>
      </wui-flex>
    `;
  }
};
W3mWalletLoginList = __decorate92([
  customElement("w3m-wallet-login-list")
], W3mWalletLoginList);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-social-login-list/styles.js
var styles_default67 = css`
  :host {
    margin-top: var(--wui-spacing-3xs);
  }
  wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-xs)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-social-login-list/index.js
var __decorate93 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mSocialLoginList = class W3mSocialLoginList2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.authConnector = this.connectors.find((c5) => c5.type === "AUTH");
    this.features = OptionsController.state.features;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => {
      this.connectors = val;
      this.authConnector = this.connectors.find((c5) => c5.type === "AUTH");
    }), OptionsController.subscribeKey("features", (val) => this.features = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a;
    const socials = (_a = this.features) == null ? void 0 : _a.socials;
    if (!this.authConnector || !socials || !(socials == null ? void 0 : socials.length)) {
      return null;
    }
    return html` <wui-flex flexDirection="column" gap="xs">
      ${socials.map((social) => html`<wui-list-social
            @click=${() => {
      this.onSocialClick(social);
    }}
            name=${social}
            logo=${social}
          ></wui-list-social>`)}
    </wui-flex>`;
  }
  async onSocialClick(socialProvider) {
    var _a, _b;
    if (socialProvider) {
      AccountController.setSocialProvider(socialProvider, ChainController.state.activeChain);
      EventsController.sendEvent({
        type: "track",
        event: "SOCIAL_LOGIN_STARTED",
        properties: { provider: socialProvider }
      });
    }
    if (socialProvider === SocialProviderEnum.Farcaster) {
      RouterController.push("ConnectingFarcaster");
      const authConnector = ConnectorController.getAuthConnector();
      if (authConnector) {
        if (!AccountController.state.farcasterUrl) {
          try {
            const { url } = await authConnector.provider.getFarcasterUri();
            AccountController.setFarcasterUrl(url, ChainController.state.activeChain);
          } catch (error) {
            RouterController.goBack();
            SnackController.showError(error);
          }
        }
      }
    } else {
      RouterController.push("ConnectingSocial");
      const authConnector = ConnectorController.getAuthConnector();
      this.popupWindow = CoreHelperUtil.returnOpenHref("", "popupWindow", "width=600,height=800,scrollbars=yes");
      try {
        if (authConnector && socialProvider) {
          const { uri } = await authConnector.provider.getSocialRedirectUri({
            provider: socialProvider
          });
          if (this.popupWindow && uri) {
            AccountController.setSocialWindow(this.popupWindow, ChainController.state.activeChain);
            this.popupWindow.location.href = uri;
          } else {
            (_a = this.popupWindow) == null ? void 0 : _a.close();
            throw new Error("Something went wrong");
          }
        }
      } catch (error) {
        (_b = this.popupWindow) == null ? void 0 : _b.close();
        SnackController.showError("Something went wrong");
      }
    }
  }
};
W3mSocialLoginList.styles = styles_default67;
__decorate93([
  state()
], W3mSocialLoginList.prototype, "connectors", void 0);
__decorate93([
  state()
], W3mSocialLoginList.prototype, "authConnector", void 0);
__decorate93([
  state()
], W3mSocialLoginList.prototype, "features", void 0);
W3mSocialLoginList = __decorate93([
  customElement("w3m-social-login-list")
], W3mSocialLoginList);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-announced-widget/index.js
var __decorate94 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectAnnouncedWidget = class W3mConnectAnnouncedWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const announcedConnectors = this.connectors.filter((connector) => connector.type === "ANNOUNCED");
    if (!(announcedConnectors == null ? void 0 : announcedConnectors.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${announcedConnectors.map((connector) => {
      var _a, _b;
      if (((_a = connector.info) == null ? void 0 : _a.rdns) && ApiController.state.excludedRDNS) {
        if (ApiController.state.excludedRDNS.includes((_b = connector == null ? void 0 : connector.info) == null ? void 0 : _b.rdns)) {
          return null;
        }
      }
      return html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getConnectorImage(connector))}
              name=${connector.name ?? "Unknown"}
              @click=${() => this.onConnector(connector)}
              tagVariant="success"
              tagLabel="installed"
              data-testid=${`wallet-selector-${connector.id}`}
              .installed=${true}
            >
            </wui-list-wallet>
          `;
    })}
      </wui-flex>
    `;
  }
  onConnector(connector) {
    if (connector.type === "WALLET_CONNECT") {
      if (CoreHelperUtil.isMobile()) {
        RouterController.push("AllWallets");
      } else {
        RouterController.push("ConnectingWalletConnect");
      }
    } else {
      RouterController.push("ConnectingExternal", { connector });
    }
  }
};
__decorate94([
  state()
], W3mConnectAnnouncedWidget.prototype, "connectors", void 0);
W3mConnectAnnouncedWidget = __decorate94([
  customElement("w3m-connect-announced-widget")
], W3mConnectAnnouncedWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-custom-widget/index.js
var __decorate95 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectCustomWidget = class W3mConnectCustomWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { customWallets } = OptionsController.state;
    if (!(customWallets == null ? void 0 : customWallets.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    const wallets = this.filterOutDuplicateWallets(customWallets);
    return html`<wui-flex flexDirection="column" gap="xs">
      ${wallets.map((wallet) => html`
          <wui-list-wallet
            imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
            name=${wallet.name ?? "Unknown"}
            @click=${() => this.onConnectWallet(wallet)}
            data-testid=${`wallet-selector-${wallet.id}`}
          >
          </wui-list-wallet>
        `)}
    </wui-flex>`;
  }
  filterOutDuplicateWallets(wallets) {
    const recent = StorageUtil.getRecentWallets();
    const connectorRDNSs = this.connectors.map((connector) => {
      var _a;
      return (_a = connector.info) == null ? void 0 : _a.rdns;
    }).filter(Boolean);
    const recentRDNSs = recent.map((wallet) => wallet.rdns).filter(Boolean);
    const allRDNSs = connectorRDNSs.concat(recentRDNSs);
    if (allRDNSs.includes("io.metamask.mobile") && CoreHelperUtil.isMobile()) {
      const index = allRDNSs.indexOf("io.metamask.mobile");
      allRDNSs[index] = "io.metamask";
    }
    const filtered = wallets.filter((wallet) => !allRDNSs.includes(String(wallet == null ? void 0 : wallet.rdns)));
    return filtered;
  }
  onConnectWallet(wallet) {
    RouterController.push("ConnectingWalletConnect", { wallet });
  }
};
__decorate95([
  state()
], W3mConnectCustomWidget.prototype, "connectors", void 0);
W3mConnectCustomWidget = __decorate95([
  customElement("w3m-connect-custom-widget")
], W3mConnectCustomWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/WalletUtil.js
var WalletUtil = {
  filterOutDuplicatesByRDNS(wallets) {
    const connectors = OptionsController.state.enableEIP6963 ? ConnectorController.state.connectors : [];
    const recent = StorageUtil.getRecentWallets();
    const connectorRDNSs = connectors.map((connector) => {
      var _a;
      return (_a = connector.info) == null ? void 0 : _a.rdns;
    }).filter(Boolean);
    const recentRDNSs = recent.map((wallet) => wallet.rdns).filter(Boolean);
    const allRDNSs = connectorRDNSs.concat(recentRDNSs);
    if (allRDNSs.includes("io.metamask.mobile") && CoreHelperUtil.isMobile()) {
      const index = allRDNSs.indexOf("io.metamask.mobile");
      allRDNSs[index] = "io.metamask";
    }
    const filtered = wallets.filter((wallet) => !allRDNSs.includes(String(wallet == null ? void 0 : wallet.rdns)));
    return filtered;
  },
  filterOutDuplicatesByIds(wallets) {
    const connectors = ConnectorController.state.connectors.filter((connector) => connector.type === "ANNOUNCED" || connector.type === "INJECTED");
    const recent = StorageUtil.getRecentWallets();
    const connectorIds = connectors.map((connector) => connector.explorerId);
    const recentIds = recent.map((wallet) => wallet.id);
    const allIds = connectorIds.concat(recentIds);
    const filtered = wallets.filter((wallet) => !allIds.includes(wallet == null ? void 0 : wallet.id));
    return filtered;
  },
  filterOutDuplicateWallets(wallets) {
    const uniqueByRDNS = this.filterOutDuplicatesByRDNS(wallets);
    const uniqueWallets = this.filterOutDuplicatesByIds(uniqueByRDNS);
    return uniqueWallets;
  }
};

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-featured-widget/index.js
var __decorate96 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectFeaturedWidget = class W3mConnectFeaturedWidget2 extends LitElement {
  constructor() {
    super(...arguments);
    this.unsubscribe = [];
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { featured } = ApiController.state;
    if (!featured.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    const wallets = WalletUtil.filterOutDuplicateWallets(featured);
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${wallets.map((wallet) => html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
              name=${wallet.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnectWallet(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
W3mConnectFeaturedWidget = __decorate96([
  customElement("w3m-connect-featured-widget")
], W3mConnectFeaturedWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-injected-widget/index.js
var __decorate97 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectInjectedWidget = class W3mConnectInjectedWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    var _a;
    const injectedConnectors = this.connectors.filter((connector) => connector.type === "INJECTED");
    if (!(injectedConnectors == null ? void 0 : injectedConnectors.length) || injectedConnectors.length === 1 && ((_a = injectedConnectors[0]) == null ? void 0 : _a.name) === "Browser Wallet" && !CoreHelperUtil.isMobile()) {
      this.style.cssText = `display: none`;
      return null;
    }
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${injectedConnectors.map((connector) => {
      var _a2, _b;
      if (!CoreHelperUtil.isMobile() && connector.name === "Browser Wallet") {
        return null;
      }
      if (!ConnectionController.checkInstalled(void 0, connector.chain)) {
        this.style.cssText = `display: none`;
        return null;
      }
      if (((_a2 = connector.info) == null ? void 0 : _a2.rdns) && ApiController.state.excludedRDNS) {
        if (ApiController.state.excludedRDNS.includes((_b = connector == null ? void 0 : connector.info) == null ? void 0 : _b.rdns)) {
          return null;
        }
      }
      return html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              tagVariant="success"
              tagLabel="installed"
              data-testid=${`wallet-selector-${connector.id}`}
              @click=${() => this.onConnector(connector)}
            >
            </wui-list-wallet>
          `;
    })}
      </wui-flex>
    `;
  }
  onConnector(connector) {
    ChainController.setActiveConnector(connector);
    RouterController.push("ConnectingExternal", { connector });
  }
};
__decorate97([
  state()
], W3mConnectInjectedWidget.prototype, "connectors", void 0);
W3mConnectInjectedWidget = __decorate97([
  customElement("w3m-connect-injected-widget")
], W3mConnectInjectedWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-multi-chain-widget/index.js
var __decorate98 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectMultiChainWidget = class W3mConnectMultiChainWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const multiChainConnectors = this.connectors.filter((connector) => connector.type === "MULTI_CHAIN" && connector.name !== "WalletConnect");
    if (!(multiChainConnectors == null ? void 0 : multiChainConnectors.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${multiChainConnectors.map((connector) => html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              tagVariant="shade"
              tagLabel="multichain"
              data-testid=${`wallet-selector-${connector.id}`}
              @click=${() => this.onConnector(connector)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnector(connector) {
    ChainController.setActiveConnector(connector);
    RouterController.push("ConnectingMultiChain");
  }
};
__decorate98([
  state()
], W3mConnectMultiChainWidget.prototype, "connectors", void 0);
W3mConnectMultiChainWidget = __decorate98([
  customElement("w3m-connect-multi-chain-widget")
], W3mConnectMultiChainWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-external-widget/index.js
var __decorate99 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectExternalWidget = class W3mConnectExternalWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const externalConnectors = this.connectors.filter((connector) => connector.type === "EXTERNAL");
    const filteredOutCoinbaseConnectors = externalConnectors.filter((connector) => connector.id !== "coinbaseWalletSDK");
    if (!(filteredOutCoinbaseConnectors == null ? void 0 : filteredOutCoinbaseConnectors.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${filteredOutCoinbaseConnectors.map((connector) => html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getConnectorImage(connector))}
              .installed=${true}
              name=${connector.name ?? "Unknown"}
              data-testid=${`wallet-selector-external-${connector.id}`}
              @click=${() => this.onConnector(connector)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnector(connector) {
    RouterController.push("ConnectingExternal", { connector });
  }
};
__decorate99([
  state()
], W3mConnectExternalWidget.prototype, "connectors", void 0);
W3mConnectExternalWidget = __decorate99([
  customElement("w3m-connect-external-widget")
], W3mConnectExternalWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-recent-widget/index.js
var __decorate100 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectRecentWidget = class W3mConnectRecentWidget2 extends LitElement {
  render() {
    const recent = StorageUtil.getRecentWallets();
    if (!(recent == null ? void 0 : recent.length)) {
      this.style.cssText = `display: none`;
      return null;
    }
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${recent.map((wallet) => html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
              name=${wallet.name ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
              tagLabel="recent"
              tagVariant="shade"
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnectWallet(wallet) {
    RouterController.push("ConnectingWalletConnect", { wallet });
  }
};
W3mConnectRecentWidget = __decorate100([
  customElement("w3m-connect-recent-widget")
], W3mConnectRecentWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-recommended-widget/index.js
var __decorate101 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectRecommendedWidget = class W3mConnectRecommendedWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const connector = this.connectors.find((c5) => c5.type === "WALLET_CONNECT");
    if (!connector) {
      return null;
    }
    const { recommended } = ApiController.state;
    const { customWallets, featuredWalletIds } = OptionsController.state;
    const { connectors } = ConnectorController.state;
    const recent = StorageUtil.getRecentWallets();
    const injected = connectors.filter((c5) => c5.type === "INJECTED" || c5.type === "ANNOUNCED" || c5.type === "MULTI_CHAIN");
    const injectedWallets = injected.filter((i3) => i3.name !== "Browser Wallet");
    if (featuredWalletIds || customWallets || !recommended.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    const overrideLength = injectedWallets.length + recent.length;
    const maxRecommended = Math.max(0, 2 - overrideLength);
    const wallets = WalletUtil.filterOutDuplicateWallets(recommended).slice(0, maxRecommended);
    if (!wallets.length) {
      this.style.cssText = `display: none`;
      return null;
    }
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${wallets.map((wallet) => html`
            <wui-list-wallet
              imageSrc=${ifDefined(AssetUtil.getWalletImage(wallet))}
              name=${(wallet == null ? void 0 : wallet.name) ?? "Unknown"}
              @click=${() => this.onConnectWallet(wallet)}
            >
            </wui-list-wallet>
          `)}
      </wui-flex>
    `;
  }
  onConnectWallet(wallet) {
    const connector = ConnectorController.getConnector(wallet.id, wallet.rdns);
    if (connector) {
      RouterController.push("ConnectingExternal", { connector });
    } else {
      RouterController.push("ConnectingWalletConnect", { wallet });
    }
  }
};
__decorate101([
  state()
], W3mConnectRecommendedWidget.prototype, "connectors", void 0);
W3mConnectRecommendedWidget = __decorate101([
  customElement("w3m-connect-recommended-widget")
], W3mConnectRecommendedWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connect-walletconnect-widget/index.js
var __decorate102 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectWalletConnectWidget = class W3mConnectWalletConnectWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    if (CoreHelperUtil.isMobile()) {
      this.style.cssText = `display: none`;
      return null;
    }
    const connector = this.connectors.find((c5) => c5.type === "WALLET_CONNECT");
    if (!connector) {
      this.style.cssText = `display: none`;
      return null;
    }
    return html`
      <wui-list-wallet
        imageSrc=${ifDefined(AssetUtil.getConnectorImage(connector))}
        name=${connector.name ?? "Unknown"}
        @click=${() => this.onConnector(connector)}
        tagLabel="qr code"
        tagVariant="main"
        data-testid="wallet-selector-walletconnect"
      >
      </wui-list-wallet>
    `;
  }
  onConnector(connector) {
    ChainController.setActiveConnector(connector);
    RouterController.push("ConnectingWalletConnect");
  }
};
__decorate102([
  state()
], W3mConnectWalletConnectWidget.prototype, "connectors", void 0);
W3mConnectWalletConnectWidget = __decorate102([
  customElement("w3m-connect-walletconnect-widget")
], W3mConnectWalletConnectWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connector-list/styles.js
var styles_default68 = css`
  :host {
    margin-top: var(--wui-spacing-3xs);
  }
  wui-separator {
    margin: var(--wui-spacing-m) calc(var(--wui-spacing-m) * -1) var(--wui-spacing-xs)
      calc(var(--wui-spacing-m) * -1);
    width: calc(100% + var(--wui-spacing-s) * 2);
  }
`;

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-connector-list/index.js
var __decorate103 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mConnectorList = class W3mConnectorList2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const { custom, recent, announced, injected, multiChain, recommended, featured, external } = this.getConnectorsByType();
    const enableWalletConnect = OptionsController.state.enableWalletConnect;
    return html`
      <wui-flex flexDirection="column" gap="xs">
        ${enableWalletConnect ? html`<w3m-connect-walletconnect-widget></w3m-connect-walletconnect-widget>` : null}
        ${recent.length ? html`<w3m-connect-recent-widget></w3m-connect-recent-widget>` : null}
        ${multiChain.length ? html`<w3m-connect-multi-chain-widget></w3m-connect-multi-chain-widget>` : null}
        ${announced.length ? html`<w3m-connect-announced-widget></w3m-connect-announced-widget>` : null}
        ${injected.length ? html`<w3m-connect-injected-widget></w3m-connect-injected-widget>` : null}
        ${featured.length ? html`<w3m-connect-featured-widget></w3m-connect-featured-widget>` : null}
        ${(custom == null ? void 0 : custom.length) ? html`<w3m-connect-custom-widget></w3m-connect-custom-widget>` : null}
        ${external.length ? html`<w3m-connect-external-widget></w3m-connect-external-widget>` : null}
        ${recommended.length ? html`<w3m-connect-recommended-widget></w3m-connect-recommended-widget>` : null}
      </wui-flex>
    `;
  }
  getConnectorsByType() {
    const { featured, recommended } = ApiController.state;
    const { customWallets: custom } = OptionsController.state;
    const recent = StorageUtil.getRecentWallets();
    const filteredRecommended = WalletUtil.filterOutDuplicateWallets(recommended);
    const filteredFeatured = WalletUtil.filterOutDuplicateWallets(featured);
    const multiChain = this.connectors.filter((connector) => connector.type === "MULTI_CHAIN");
    const announced = this.connectors.filter((connector) => connector.type === "ANNOUNCED");
    const injected = this.connectors.filter((connector) => connector.type === "INJECTED");
    const external = this.connectors.filter((connector) => connector.type === "EXTERNAL");
    const isEVM = ChainController.state.activeChain === ConstantsUtil.CHAIN.EVM;
    const includeAnnouncedAndInjected = isEVM ? OptionsController.state.enableEIP6963 : true;
    return {
      custom,
      recent,
      external,
      multiChain,
      announced: includeAnnouncedAndInjected ? announced : [],
      injected: includeAnnouncedAndInjected ? injected : [],
      recommended: filteredRecommended,
      featured: filteredFeatured
    };
  }
};
W3mConnectorList.styles = styles_default68;
__decorate103([
  state()
], W3mConnectorList.prototype, "connectors", void 0);
W3mConnectorList = __decorate103([
  customElement("w3m-connector-list")
], W3mConnectorList);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-all-wallets-widget/index.js
var __decorate104 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAllWalletsWidget = class W3mAllWalletsWidget2 extends LitElement {
  constructor() {
    super();
    this.unsubscribe = [];
    this.connectors = ConnectorController.state.connectors;
    this.count = ApiController.state.count;
    this.unsubscribe.push(ConnectorController.subscribeKey("connectors", (val) => this.connectors = val), ApiController.subscribeKey("count", (val) => this.count = val));
  }
  disconnectedCallback() {
    this.unsubscribe.forEach((unsubscribe) => unsubscribe());
  }
  render() {
    const wcConnector = this.connectors.find((c5) => c5.type === "WALLET_CONNECT");
    const { allWallets } = OptionsController.state;
    if (!wcConnector || allWallets === "HIDE") {
      return null;
    }
    if (allWallets === "ONLY_MOBILE" && !CoreHelperUtil.isMobile()) {
      return null;
    }
    const featuredCount = ApiController.state.featured.length;
    const rawCount = this.count + featuredCount;
    const roundedCount = rawCount < 10 ? rawCount : Math.floor(rawCount / 10) * 10;
    const tagLabel = roundedCount < rawCount ? `${roundedCount}+` : `${roundedCount}`;
    return html`
      <wui-list-wallet
        name="All Wallets"
        walletIcon="allWallets"
        showAllWallets
        @click=${this.onAllWallets.bind(this)}
        tagLabel=${tagLabel}
        tagVariant="shade"
        data-testid="all-wallets"
      ></wui-list-wallet>
    `;
  }
  onAllWallets() {
    EventsController.sendEvent({ type: "track", event: "CLICK_ALL_WALLETS" });
    RouterController.push("AllWallets");
  }
};
__decorate104([
  state()
], W3mAllWalletsWidget.prototype, "connectors", void 0);
__decorate104([
  state()
], W3mAllWalletsWidget.prototype, "count", void 0);
W3mAllWalletsWidget = __decorate104([
  customElement("w3m-all-wallets-widget")
], W3mAllWalletsWidget);

// node_modules/@reown/appkit-scaffold-ui/dist/esm/src/partials/w3m-account-auth-button/index.js
var __decorate105 = function(decorators, target, key, desc) {
  var c5 = arguments.length, r3 = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d3 = decorators[i3]) r3 = (c5 < 3 ? d3(r3) : c5 > 3 ? d3(target, key, r3) : d3(target, key)) || r3;
  return c5 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
};
var W3mAccountAuthButton = class W3mAccountAuthButton2 extends LitElement {
  constructor() {
    super(...arguments);
    this.socialProvider = StorageUtil.getConnectedSocialProvider();
    this.socialUsername = StorageUtil.getConnectedSocialUsername();
  }
  render() {
    const type = StorageUtil.getConnectedConnector();
    const authConnector = ConnectorController.getAuthConnector();
    if (!authConnector || type !== "AUTH") {
      this.style.cssText = `display: none`;
      return null;
    }
    const email = authConnector.provider.getEmail() ?? "";
    return html`
      <wui-list-item
        variant="icon"
        iconVariant="overlay"
        icon=${this.socialProvider ?? "mail"}
        iconSize=${this.socialProvider ? "xxl" : "sm"}
        data-testid="w3m-account-email-update"
        ?chevron=${!this.socialProvider}
        @click=${() => {
      this.onGoToUpdateEmail(email, this.socialProvider);
    }}
      >
        <wui-text variant="paragraph-500" color="fg-100">${this.getAuthName(email)}</wui-text>
      </wui-list-item>
    `;
  }
  onGoToUpdateEmail(email, socialProvider) {
    if (!socialProvider) {
      RouterController.push("UpdateEmailWallet", { email });
    }
  }
  getAuthName(email) {
    if (this.socialUsername) {
      if (this.socialProvider === "discord" && this.socialUsername.endsWith("0")) {
        return this.socialUsername.slice(0, -1);
      }
      return this.socialUsername;
    }
    return email.length > 30 ? `${email.slice(0, -3)}...` : email;
  }
};
W3mAccountAuthButton = __decorate105([
  customElement("w3m-account-auth-button")
], W3mAccountAuthButton);

// node_modules/@reown/appkit/dist/esm/src/utils/ConstantsUtil.js
var WcConstantsUtil = {
  ERROR_CODE_UNRECOGNIZED_CHAIN_ID: 4902,
  ERROR_CODE_DEFAULT: 5e3
};

export {
  ConstantsUtil3 as ConstantsUtil,
  PresetsUtil,
  HelpersUtil,
  WcHelpersUtil,
  ProviderUtil,
  AppKit,
  package_default,
  W3mAccountButton,
  W3mButton,
  W3mConnectButton,
  W3mNetworkButton,
  W3mRouter,
  W3mOnrampWidget,
  W3mAccountSettingsView,
  W3mAccountView,
  W3mAllWalletsView,
  W3mBuyInProgressView,
  W3mConnectView,
  W3mConnectingExternalView,
  W3mConnectingMultiChainView,
  W3mConnectingWcView,
  W3mChooseAccountNameView,
  W3mDownloadsView,
  W3mGetWalletView,
  W3mRegisterAccountNameView,
  W3mRegisterAccountNameSuccess,
  W3mNetworkSwitchView,
  W3mNetworksView,
  W3mOnRampActivityView,
  W3mOnrampFiatSelectView,
  W3mOnRampProvidersView,
  W3mOnrampTokensView,
  W3mSwapView,
  W3mSwitchActiveChainView,
  W3mSwapPreviewView,
  W3mSwapSelectTokenView,
  W3mTransactionsView,
  W3mWhatIsANetworkView,
  W3mWhatIsAWalletView,
  W3mWhatIsABuyView,
  W3mEmailVerifyOtpView,
  W3mEmailVerifyDeviceView,
  W3mApproveTransactionView,
  W3mUpgradeWalletView,
  W3mUpgradeToSmartAccountView,
  W3mUpdateEmailWalletView,
  W3mUpdateEmailPrimaryOtpView,
  W3mUpdateEmailSecondaryOtpView,
  W3mUnsupportedChainView,
  W3mWalletReceiveView,
  W3mWalletCompatibleNetworksView,
  W3mWalletSendView,
  W3mSendSelectTokenView,
  W3mWalletSendPreviewView,
  W3mConnectWalletsView,
  W3mConnectSocialsView,
  W3mConnectingSocialView,
  W3mProfileView,
  W3mSelectAddressesView,
  W3mSwitchAddressView,
  W3mConnectingFarcasterView,
  W3mAllWalletsList,
  W3mAllWalletsListItem,
  W3mAllWalletsSearch,
  W3mConnectingHeader,
  W3mConnectingWcBrowser,
  W3mConnectingWcDesktop,
  W3mConnectingWcMobile,
  W3mConnectingWcQrcode,
  W3mConnectingWcUnsupported,
  W3mConnectingWcWeb,
  WuiSwapDetails,
  W3mSwapInput,
  W3mSwapInputSkeleton,
  W3mHeader,
  W3mHelpWidget,
  W3mOnRampActivityItem,
  W3mInputCurrency,
  W3mOnRampProviderItem,
  W3mLegalFooter,
  W3mMobileDownloadLinks,
  W3mOnRampProvidersFooter,
  W3mSnackBar,
  W3mEmailLoginWidget,
  W3mAccountDefaultWidget,
  W3mAccountWalletFeaturesWidget,
  W3mAccountActivityWidget,
  W3mAccountNftsWidget,
  W3mAccountTokensWidget,
  W3mActivityList,
  W3mInputToken,
  W3mInputAddress,
  W3mWalletSendDetails,
  W3mTooltip,
  WuiTooltipTrigger,
  W3mSocialLoginWidget,
  W3mWalletLoginList,
  W3mSocialLoginList,
  W3mConnectAnnouncedWidget,
  W3mConnectCustomWidget,
  W3mConnectFeaturedWidget,
  W3mConnectInjectedWidget,
  W3mConnectMultiChainWidget,
  W3mConnectExternalWidget,
  W3mConnectRecentWidget,
  W3mConnectRecommendedWidget,
  W3mConnectWalletConnectWidget,
  W3mConnectorList,
  W3mAllWalletsWidget,
  W3mAccountAuthButton,
  WcConstantsUtil
};
/*! Bundled license information:

@walletconnect/universal-provider/dist/index.es.js:
  (**
  * @license
  * Lodash <https://lodash.com/>
  * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
  * Released under MIT license <https://lodash.com/license>
  * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
  * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  *)
*/
//# sourceMappingURL=chunk-O4HLFQ2L.js.map
